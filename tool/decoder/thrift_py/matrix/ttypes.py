#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []

TType.STOP = 127

class msg_header(object):
    """
    Attributes:
     - magic
     - msg_name
     - nonce
     - session_id
     - exten_info
    """


    def __init__(self, magic=None, msg_name=None, nonce=None, session_id=None, exten_info=None,):
        self.magic = magic
        self.msg_name = msg_name
        self.nonce = nonce
        self.session_id = session_id
        self.exten_info = exten_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.magic = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msg_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.nonce = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.session_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 255:
                if ftype == TType.MAP:
                    self.exten_info = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.exten_info[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('msg_header')
        if self.magic is not None:
            oprot.writeFieldBegin('magic', TType.I32, 1)
            oprot.writeI32(self.magic)
            oprot.writeFieldEnd()
        if self.msg_name is not None:
            oprot.writeFieldBegin('msg_name', TType.STRING, 2)
            oprot.writeString(self.msg_name.encode('utf-8') if sys.version_info[0] == 2 else self.msg_name)
            oprot.writeFieldEnd()
        if self.nonce is not None:
            oprot.writeFieldBegin('nonce', TType.STRING, 3)
            oprot.writeString(self.nonce.encode('utf-8') if sys.version_info[0] == 2 else self.nonce)
            oprot.writeFieldEnd()
        if self.session_id is not None:
            oprot.writeFieldBegin('session_id', TType.STRING, 4)
            oprot.writeString(self.session_id.encode('utf-8') if sys.version_info[0] == 2 else self.session_id)
            oprot.writeFieldEnd()
        if self.exten_info is not None:
            oprot.writeFieldBegin('exten_info', TType.MAP, 255)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.exten_info))
            for kiter7, viter8 in self.exten_info.items():
                oprot.writeString(kiter7.encode('utf-8') if sys.version_info[0] == 2 else kiter7)
                oprot.writeString(viter8.encode('utf-8') if sys.version_info[0] == 2 else viter8)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.magic is None:
            raise TProtocolException(message='Required field magic is unset!')
        if self.msg_name is None:
            raise TProtocolException(message='Required field msg_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class empty(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('empty')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class network_address(object):
    """
    Attributes:
     - ip
     - port
    """


    def __init__(self, ip=None, port=None,):
        self.ip = ip
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.port = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('network_address')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I16, 2)
            oprot.writeI16(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ip is None:
            raise TProtocolException(message='Required field ip is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class task_status(object):
    """
    Attributes:
     - task_id
     - status
    """


    def __init__(self, task_id=None, status=None,):
        self.task_id = task_id
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.task_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.status = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('task_status')
        if self.task_id is not None:
            oprot.writeFieldBegin('task_id', TType.STRING, 1)
            oprot.writeString(self.task_id.encode('utf-8') if sys.version_info[0] == 2 else self.task_id)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.BYTE, 2)
            oprot.writeByte(self.status)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.task_id is None:
            raise TProtocolException(message='Required field task_id is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class peer_node_info(object):
    """
    Attributes:
     - peer_node_id
     - core_version
     - protocol_version
     - live_time_stamp
     - addr
     - service_list
    """


    def __init__(self, peer_node_id=None, core_version=None, protocol_version=None, live_time_stamp=None, addr=None, service_list=None,):
        self.peer_node_id = peer_node_id
        self.core_version = core_version
        self.protocol_version = protocol_version
        self.live_time_stamp = live_time_stamp
        self.addr = addr
        self.service_list = service_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.peer_node_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.core_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.live_time_stamp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.addr = network_address()
                    self.addr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.service_list = []
                    (_etype12, _size9) = iprot.readListBegin()
                    for _i13 in range(_size9):
                        _elem14 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.service_list.append(_elem14)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('peer_node_info')
        if self.peer_node_id is not None:
            oprot.writeFieldBegin('peer_node_id', TType.STRING, 1)
            oprot.writeString(self.peer_node_id.encode('utf-8') if sys.version_info[0] == 2 else self.peer_node_id)
            oprot.writeFieldEnd()
        if self.core_version is not None:
            oprot.writeFieldBegin('core_version', TType.I32, 2)
            oprot.writeI32(self.core_version)
            oprot.writeFieldEnd()
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 3)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.live_time_stamp is not None:
            oprot.writeFieldBegin('live_time_stamp', TType.I32, 4)
            oprot.writeI32(self.live_time_stamp)
            oprot.writeFieldEnd()
        if self.addr is not None:
            oprot.writeFieldBegin('addr', TType.STRUCT, 5)
            self.addr.write(oprot)
            oprot.writeFieldEnd()
        if self.service_list is not None:
            oprot.writeFieldBegin('service_list', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.service_list))
            for iter15 in self.service_list:
                oprot.writeString(iter15.encode('utf-8') if sys.version_info[0] == 2 else iter15)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.peer_node_id is None:
            raise TProtocolException(message='Required field peer_node_id is unset!')
        if self.core_version is None:
            raise TProtocolException(message='Required field core_version is unset!')
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.live_time_stamp is None:
            raise TProtocolException(message='Required field live_time_stamp is unset!')
        if self.addr is None:
            raise TProtocolException(message='Required field addr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ver_req_body(object):
    """
    Attributes:
     - node_id
     - core_version
     - protocol_version
     - time_stamp
     - addr_me
     - addr_you
     - start_height
    """


    def __init__(self, node_id=None, core_version=None, protocol_version=None, time_stamp=None, addr_me=None, addr_you=None, start_height=None,):
        self.node_id = node_id
        self.core_version = core_version
        self.protocol_version = protocol_version
        self.time_stamp = time_stamp
        self.addr_me = addr_me
        self.addr_you = addr_you
        self.start_height = start_height

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.core_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.time_stamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.addr_me = network_address()
                    self.addr_me.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.addr_you = network_address()
                    self.addr_you.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.start_height = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ver_req_body')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.STRING, 1)
            oprot.writeString(self.node_id.encode('utf-8') if sys.version_info[0] == 2 else self.node_id)
            oprot.writeFieldEnd()
        if self.core_version is not None:
            oprot.writeFieldBegin('core_version', TType.I32, 2)
            oprot.writeI32(self.core_version)
            oprot.writeFieldEnd()
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 3)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.time_stamp is not None:
            oprot.writeFieldBegin('time_stamp', TType.I64, 4)
            oprot.writeI64(self.time_stamp)
            oprot.writeFieldEnd()
        if self.addr_me is not None:
            oprot.writeFieldBegin('addr_me', TType.STRUCT, 5)
            self.addr_me.write(oprot)
            oprot.writeFieldEnd()
        if self.addr_you is not None:
            oprot.writeFieldBegin('addr_you', TType.STRUCT, 6)
            self.addr_you.write(oprot)
            oprot.writeFieldEnd()
        if self.start_height is not None:
            oprot.writeFieldBegin('start_height', TType.I64, 7)
            oprot.writeI64(self.start_height)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.node_id is None:
            raise TProtocolException(message='Required field node_id is unset!')
        if self.core_version is None:
            raise TProtocolException(message='Required field core_version is unset!')
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.time_stamp is None:
            raise TProtocolException(message='Required field time_stamp is unset!')
        if self.addr_me is None:
            raise TProtocolException(message='Required field addr_me is unset!')
        if self.addr_you is None:
            raise TProtocolException(message='Required field addr_you is unset!')
        if self.start_height is None:
            raise TProtocolException(message='Required field start_height is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ver_req(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = ver_req_body()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ver_req')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ver_resp_body(object):
    """
    Attributes:
     - node_id
     - core_version
     - protocol_version
    """


    def __init__(self, node_id=None, core_version=None, protocol_version=None,):
        self.node_id = node_id
        self.core_version = core_version
        self.protocol_version = protocol_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.core_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ver_resp_body')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.STRING, 1)
            oprot.writeString(self.node_id.encode('utf-8') if sys.version_info[0] == 2 else self.node_id)
            oprot.writeFieldEnd()
        if self.core_version is not None:
            oprot.writeFieldBegin('core_version', TType.I32, 2)
            oprot.writeI32(self.core_version)
            oprot.writeFieldEnd()
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 3)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.node_id is None:
            raise TProtocolException(message='Required field node_id is unset!')
        if self.core_version is None:
            raise TProtocolException(message='Required field core_version is unset!')
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ver_resp(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = ver_resp_body()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ver_resp')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class shake_hand_req(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = empty()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shake_hand_req')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class shake_hand_resp(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = empty()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shake_hand_resp')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_peer_nodes_req(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = empty()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_peer_nodes_req')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_peer_nodes_resp_body(object):
    """
    Attributes:
     - peer_nodes_list
    """


    def __init__(self, peer_nodes_list=None,):
        self.peer_nodes_list = peer_nodes_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.peer_nodes_list = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = peer_node_info()
                        _elem21.read(iprot)
                        self.peer_nodes_list.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_peer_nodes_resp_body')
        if self.peer_nodes_list is not None:
            oprot.writeFieldBegin('peer_nodes_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.peer_nodes_list))
            for iter22 in self.peer_nodes_list:
                iter22.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.peer_nodes_list is None:
            raise TProtocolException(message='Required field peer_nodes_list is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_peer_nodes_resp(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = get_peer_nodes_resp_body()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_peer_nodes_resp')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class peer_nodes_broadcast_req_body(object):
    """
    Attributes:
     - peer_nodes_list
    """


    def __init__(self, peer_nodes_list=None,):
        self.peer_nodes_list = peer_nodes_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.peer_nodes_list = []
                    (_etype26, _size23) = iprot.readListBegin()
                    for _i27 in range(_size23):
                        _elem28 = peer_node_info()
                        _elem28.read(iprot)
                        self.peer_nodes_list.append(_elem28)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('peer_nodes_broadcast_req_body')
        if self.peer_nodes_list is not None:
            oprot.writeFieldBegin('peer_nodes_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.peer_nodes_list))
            for iter29 in self.peer_nodes_list:
                iter29.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.peer_nodes_list is None:
            raise TProtocolException(message='Required field peer_nodes_list is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class peer_nodes_broadcast_req(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = peer_nodes_broadcast_req_body()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('peer_nodes_broadcast_req')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class start_training_req_body(object):
    """
    Attributes:
     - task_id
     - select_mode
     - master
     - peer_nodes_list
     - server_specification
     - server_count
     - training_engine
     - code_dir
     - entry_file
     - data_dir
     - checkpoint_dir
     - hyper_parameters
    """


    def __init__(self, task_id=None, select_mode=None, master=None, peer_nodes_list=None, server_specification=None, server_count=None, training_engine=None, code_dir=None, entry_file=None, data_dir=None, checkpoint_dir=None, hyper_parameters=None,):
        self.task_id = task_id
        self.select_mode = select_mode
        self.master = master
        self.peer_nodes_list = peer_nodes_list
        self.server_specification = server_specification
        self.server_count = server_count
        self.training_engine = training_engine
        self.code_dir = code_dir
        self.entry_file = entry_file
        self.data_dir = data_dir
        self.checkpoint_dir = checkpoint_dir
        self.hyper_parameters = hyper_parameters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.task_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.select_mode = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.master = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.peer_nodes_list = []
                    (_etype33, _size30) = iprot.readListBegin()
                    for _i34 in range(_size30):
                        _elem35 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.peer_nodes_list.append(_elem35)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.server_specification = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.server_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.training_engine = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.code_dir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.entry_file = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.data_dir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.checkpoint_dir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.hyper_parameters = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_training_req_body')
        if self.task_id is not None:
            oprot.writeFieldBegin('task_id', TType.STRING, 1)
            oprot.writeString(self.task_id.encode('utf-8') if sys.version_info[0] == 2 else self.task_id)
            oprot.writeFieldEnd()
        if self.select_mode is not None:
            oprot.writeFieldBegin('select_mode', TType.BYTE, 2)
            oprot.writeByte(self.select_mode)
            oprot.writeFieldEnd()
        if self.master is not None:
            oprot.writeFieldBegin('master', TType.STRING, 3)
            oprot.writeString(self.master.encode('utf-8') if sys.version_info[0] == 2 else self.master)
            oprot.writeFieldEnd()
        if self.peer_nodes_list is not None:
            oprot.writeFieldBegin('peer_nodes_list', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.peer_nodes_list))
            for iter36 in self.peer_nodes_list:
                oprot.writeString(iter36.encode('utf-8') if sys.version_info[0] == 2 else iter36)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.server_specification is not None:
            oprot.writeFieldBegin('server_specification', TType.STRING, 5)
            oprot.writeString(self.server_specification.encode('utf-8') if sys.version_info[0] == 2 else self.server_specification)
            oprot.writeFieldEnd()
        if self.server_count is not None:
            oprot.writeFieldBegin('server_count', TType.I32, 6)
            oprot.writeI32(self.server_count)
            oprot.writeFieldEnd()
        if self.training_engine is not None:
            oprot.writeFieldBegin('training_engine', TType.I32, 7)
            oprot.writeI32(self.training_engine)
            oprot.writeFieldEnd()
        if self.code_dir is not None:
            oprot.writeFieldBegin('code_dir', TType.STRING, 8)
            oprot.writeString(self.code_dir.encode('utf-8') if sys.version_info[0] == 2 else self.code_dir)
            oprot.writeFieldEnd()
        if self.entry_file is not None:
            oprot.writeFieldBegin('entry_file', TType.STRING, 9)
            oprot.writeString(self.entry_file.encode('utf-8') if sys.version_info[0] == 2 else self.entry_file)
            oprot.writeFieldEnd()
        if self.data_dir is not None:
            oprot.writeFieldBegin('data_dir', TType.STRING, 10)
            oprot.writeString(self.data_dir.encode('utf-8') if sys.version_info[0] == 2 else self.data_dir)
            oprot.writeFieldEnd()
        if self.checkpoint_dir is not None:
            oprot.writeFieldBegin('checkpoint_dir', TType.STRING, 11)
            oprot.writeString(self.checkpoint_dir.encode('utf-8') if sys.version_info[0] == 2 else self.checkpoint_dir)
            oprot.writeFieldEnd()
        if self.hyper_parameters is not None:
            oprot.writeFieldBegin('hyper_parameters', TType.STRING, 12)
            oprot.writeString(self.hyper_parameters.encode('utf-8') if sys.version_info[0] == 2 else self.hyper_parameters)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.task_id is None:
            raise TProtocolException(message='Required field task_id is unset!')
        if self.select_mode is None:
            raise TProtocolException(message='Required field select_mode is unset!')
        if self.training_engine is None:
            raise TProtocolException(message='Required field training_engine is unset!')
        if self.code_dir is None:
            raise TProtocolException(message='Required field code_dir is unset!')
        if self.entry_file is None:
            raise TProtocolException(message='Required field entry_file is unset!')
        if self.data_dir is None:
            raise TProtocolException(message='Required field data_dir is unset!')
        if self.checkpoint_dir is None:
            raise TProtocolException(message='Required field checkpoint_dir is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class start_training_req(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = start_training_req_body()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_training_req')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class stop_training_req_body(object):
    """
    Attributes:
     - task_id
    """


    def __init__(self, task_id=None,):
        self.task_id = task_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.task_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_training_req_body')
        if self.task_id is not None:
            oprot.writeFieldBegin('task_id', TType.STRING, 1)
            oprot.writeString(self.task_id.encode('utf-8') if sys.version_info[0] == 2 else self.task_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.task_id is None:
            raise TProtocolException(message='Required field task_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class stop_training_req(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = stop_training_req_body()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_training_req')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class list_training_req_body(object):
    """
    Attributes:
     - task_list
    """


    def __init__(self, task_list=None,):
        self.task_list = task_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.task_list = []
                    (_etype40, _size37) = iprot.readListBegin()
                    for _i41 in range(_size37):
                        _elem42 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.task_list.append(_elem42)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('list_training_req_body')
        if self.task_list is not None:
            oprot.writeFieldBegin('task_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.task_list))
            for iter43 in self.task_list:
                oprot.writeString(iter43.encode('utf-8') if sys.version_info[0] == 2 else iter43)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.task_list is None:
            raise TProtocolException(message='Required field task_list is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class list_training_req(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = list_training_req_body()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('list_training_req')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class list_training_resp_body(object):
    """
    Attributes:
     - task_status_list
    """


    def __init__(self, task_status_list=None,):
        self.task_status_list = task_status_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.task_status_list = []
                    (_etype47, _size44) = iprot.readListBegin()
                    for _i48 in range(_size44):
                        _elem49 = task_status()
                        _elem49.read(iprot)
                        self.task_status_list.append(_elem49)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('list_training_resp_body')
        if self.task_status_list is not None:
            oprot.writeFieldBegin('task_status_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.task_status_list))
            for iter50 in self.task_status_list:
                iter50.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.task_status_list is None:
            raise TProtocolException(message='Required field task_status_list is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class list_training_resp(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = list_training_resp_body()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('list_training_resp')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class logs_req_body(object):
    """
    Attributes:
     - task_id
     - peer_nodes_list
     - head_or_tail
     - number_of_lines
    """


    def __init__(self, task_id=None, peer_nodes_list=None, head_or_tail=None, number_of_lines=None,):
        self.task_id = task_id
        self.peer_nodes_list = peer_nodes_list
        self.head_or_tail = head_or_tail
        self.number_of_lines = number_of_lines

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.task_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.peer_nodes_list = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.peer_nodes_list.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.head_or_tail = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.number_of_lines = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('logs_req_body')
        if self.task_id is not None:
            oprot.writeFieldBegin('task_id', TType.STRING, 1)
            oprot.writeString(self.task_id.encode('utf-8') if sys.version_info[0] == 2 else self.task_id)
            oprot.writeFieldEnd()
        if self.peer_nodes_list is not None:
            oprot.writeFieldBegin('peer_nodes_list', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.peer_nodes_list))
            for iter57 in self.peer_nodes_list:
                oprot.writeString(iter57.encode('utf-8') if sys.version_info[0] == 2 else iter57)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.head_or_tail is not None:
            oprot.writeFieldBegin('head_or_tail', TType.BYTE, 3)
            oprot.writeByte(self.head_or_tail)
            oprot.writeFieldEnd()
        if self.number_of_lines is not None:
            oprot.writeFieldBegin('number_of_lines', TType.I16, 4)
            oprot.writeI16(self.number_of_lines)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.task_id is None:
            raise TProtocolException(message='Required field task_id is unset!')
        if self.peer_nodes_list is None:
            raise TProtocolException(message='Required field peer_nodes_list is unset!')
        if self.head_or_tail is None:
            raise TProtocolException(message='Required field head_or_tail is unset!')
        if self.number_of_lines is None:
            raise TProtocolException(message='Required field number_of_lines is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class logs_req(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = logs_req_body()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('logs_req')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class peer_node_log(object):
    """
    Attributes:
     - peer_node_id
     - log_content
    """


    def __init__(self, peer_node_id=None, log_content=None,):
        self.peer_node_id = peer_node_id
        self.log_content = log_content

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.peer_node_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.log_content = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('peer_node_log')
        if self.peer_node_id is not None:
            oprot.writeFieldBegin('peer_node_id', TType.STRING, 1)
            oprot.writeString(self.peer_node_id.encode('utf-8') if sys.version_info[0] == 2 else self.peer_node_id)
            oprot.writeFieldEnd()
        if self.log_content is not None:
            oprot.writeFieldBegin('log_content', TType.STRING, 2)
            oprot.writeString(self.log_content.encode('utf-8') if sys.version_info[0] == 2 else self.log_content)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.peer_node_id is None:
            raise TProtocolException(message='Required field peer_node_id is unset!')
        if self.log_content is None:
            raise TProtocolException(message='Required field log_content is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class logs_resp_body(object):
    """
    Attributes:
     - log
    """


    def __init__(self, log=None,):
        self.log = log

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.log = peer_node_log()
                    self.log.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('logs_resp_body')
        if self.log is not None:
            oprot.writeFieldBegin('log', TType.STRUCT, 1)
            self.log.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.log is None:
            raise TProtocolException(message='Required field log is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class logs_resp(object):
    """
    Attributes:
     - header
     - body
    """


    def __init__(self, header=None, body=None,):
        self.header = header
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.header = msg_header()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.body = logs_resp_body()
                    self.body.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('logs_resp')
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 1)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRUCT, 2)
            self.body.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(msg_header)
msg_header.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'magic', None, None, ),  # 1
    (2, TType.STRING, 'msg_name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'nonce', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'session_id', 'UTF8', None, ),  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    None,  # 100
    None,  # 101
    None,  # 102
    None,  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    None,  # 200
    None,  # 201
    None,  # 202
    None,  # 203
    None,  # 204
    None,  # 205
    None,  # 206
    None,  # 207
    None,  # 208
    None,  # 209
    None,  # 210
    None,  # 211
    None,  # 212
    None,  # 213
    None,  # 214
    None,  # 215
    None,  # 216
    None,  # 217
    None,  # 218
    None,  # 219
    None,  # 220
    None,  # 221
    None,  # 222
    None,  # 223
    None,  # 224
    None,  # 225
    None,  # 226
    None,  # 227
    None,  # 228
    None,  # 229
    None,  # 230
    None,  # 231
    None,  # 232
    None,  # 233
    None,  # 234
    None,  # 235
    None,  # 236
    None,  # 237
    None,  # 238
    None,  # 239
    None,  # 240
    None,  # 241
    None,  # 242
    None,  # 243
    None,  # 244
    None,  # 245
    None,  # 246
    None,  # 247
    None,  # 248
    None,  # 249
    None,  # 250
    None,  # 251
    None,  # 252
    None,  # 253
    None,  # 254
    (255, TType.MAP, 'exten_info', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 255
)
all_structs.append(empty)
empty.thrift_spec = (
)
all_structs.append(network_address)
network_address.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I16, 'port', None, None, ),  # 2
)
all_structs.append(task_status)
task_status.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'task_id', 'UTF8', None, ),  # 1
    (2, TType.BYTE, 'status', None, None, ),  # 2
)
all_structs.append(peer_node_info)
peer_node_info.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'peer_node_id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'core_version', None, None, ),  # 2
    (3, TType.I32, 'protocol_version', None, None, ),  # 3
    (4, TType.I32, 'live_time_stamp', None, None, ),  # 4
    (5, TType.STRUCT, 'addr', [network_address, None], None, ),  # 5
    (6, TType.LIST, 'service_list', (TType.STRING, 'UTF8', False), None, ),  # 6
)
all_structs.append(ver_req_body)
ver_req_body.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'core_version', None, None, ),  # 2
    (3, TType.I32, 'protocol_version', None, None, ),  # 3
    (4, TType.I64, 'time_stamp', None, None, ),  # 4
    (5, TType.STRUCT, 'addr_me', [network_address, None], None, ),  # 5
    (6, TType.STRUCT, 'addr_you', [network_address, None], None, ),  # 6
    (7, TType.I64, 'start_height', None, None, ),  # 7
)
all_structs.append(ver_req)
ver_req.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [ver_req_body, None], None, ),  # 2
)
all_structs.append(ver_resp_body)
ver_resp_body.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'core_version', None, None, ),  # 2
    (3, TType.I32, 'protocol_version', None, None, ),  # 3
)
all_structs.append(ver_resp)
ver_resp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [ver_resp_body, None], None, ),  # 2
)
all_structs.append(shake_hand_req)
shake_hand_req.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [empty, None], None, ),  # 2
)
all_structs.append(shake_hand_resp)
shake_hand_resp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [empty, None], None, ),  # 2
)
all_structs.append(get_peer_nodes_req)
get_peer_nodes_req.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [empty, None], None, ),  # 2
)
all_structs.append(get_peer_nodes_resp_body)
get_peer_nodes_resp_body.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'peer_nodes_list', (TType.STRUCT, [peer_node_info, None], False), None, ),  # 1
)
all_structs.append(get_peer_nodes_resp)
get_peer_nodes_resp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [get_peer_nodes_resp_body, None], None, ),  # 2
)
all_structs.append(peer_nodes_broadcast_req_body)
peer_nodes_broadcast_req_body.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'peer_nodes_list', (TType.STRUCT, [peer_node_info, None], False), None, ),  # 1
)
all_structs.append(peer_nodes_broadcast_req)
peer_nodes_broadcast_req.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [peer_nodes_broadcast_req_body, None], None, ),  # 2
)
all_structs.append(start_training_req_body)
start_training_req_body.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'task_id', 'UTF8', None, ),  # 1
    (2, TType.BYTE, 'select_mode', None, None, ),  # 2
    (3, TType.STRING, 'master', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'peer_nodes_list', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRING, 'server_specification', 'UTF8', None, ),  # 5
    (6, TType.I32, 'server_count', None, None, ),  # 6
    (7, TType.I32, 'training_engine', None, None, ),  # 7
    (8, TType.STRING, 'code_dir', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'entry_file', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'data_dir', 'UTF8', None, ),  # 10
    (11, TType.STRING, 'checkpoint_dir', 'UTF8', None, ),  # 11
    (12, TType.STRING, 'hyper_parameters', 'UTF8', None, ),  # 12
)
all_structs.append(start_training_req)
start_training_req.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [start_training_req_body, None], None, ),  # 2
)
all_structs.append(stop_training_req_body)
stop_training_req_body.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'task_id', 'UTF8', None, ),  # 1
)
all_structs.append(stop_training_req)
stop_training_req.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [stop_training_req_body, None], None, ),  # 2
)
all_structs.append(list_training_req_body)
list_training_req_body.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'task_list', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(list_training_req)
list_training_req.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [list_training_req_body, None], None, ),  # 2
)
all_structs.append(list_training_resp_body)
list_training_resp_body.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'task_status_list', (TType.STRUCT, [task_status, None], False), None, ),  # 1
)
all_structs.append(list_training_resp)
list_training_resp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [list_training_resp_body, None], None, ),  # 2
)
all_structs.append(logs_req_body)
logs_req_body.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'task_id', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'peer_nodes_list', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.BYTE, 'head_or_tail', None, None, ),  # 3
    (4, TType.I16, 'number_of_lines', None, None, ),  # 4
)
all_structs.append(logs_req)
logs_req.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [logs_req_body, None], None, ),  # 2
)
all_structs.append(peer_node_log)
peer_node_log.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'peer_node_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'log_content', 'UTF8', None, ),  # 2
)
all_structs.append(logs_resp_body)
logs_resp_body.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'log', [peer_node_log, None], None, ),  # 1
)
all_structs.append(logs_resp)
logs_resp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'header', [msg_header, None], None, ),  # 1
    (2, TType.STRUCT, 'body', [logs_resp_body, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs
