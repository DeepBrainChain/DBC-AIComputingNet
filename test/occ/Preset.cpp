/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Preset.h"

#include "network/protocol/protocol.h"

// The T_STOP of enum TType in dbc is not equal to the value of thrift official
// code: ::apache::thrift::protocol::T_STOP
#define ORIGIN_T_STOP 0

#define MAX_RESPONSE_LENGTH 4096

namespace occ {

Preset_ping_args::~Preset_ping_args() noexcept {}

uint32_t Preset_ping_args::read(::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        xfer += iprot->skip(ftype);
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t Preset_ping_args::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("Preset_ping_args");

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

Preset_ping_pargs::~Preset_ping_pargs() noexcept {}

uint32_t Preset_ping_pargs::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("Preset_ping_pargs");

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

Preset_ping_result::~Preset_ping_result() noexcept {}

uint32_t Preset_ping_result::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 0:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->success);
                    this->__isset.success = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t Preset_ping_result::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;

    xfer += oprot->writeStructBegin("Preset_ping_result");

    if (this->__isset.success) {
        xfer += oprot->writeFieldBegin("success",
                                       ::apache::thrift::protocol::T_STRING, 0);
        xfer += oprot->writeString(this->success);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

Preset_ping_presult::~Preset_ping_presult() noexcept {}

uint32_t Preset_ping_presult::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 0:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString((*(this->success)));
                    this->__isset.success = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

Preset_handleMessage_args::~Preset_handleMessage_args() noexcept {}

uint32_t Preset_handleMessage_args::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->msg.read(iprot);
                    this->__isset.msg = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t Preset_handleMessage_args::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("Preset_handleMessage_args");

    xfer +=
        oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->msg.write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

Preset_handleMessage_pargs::~Preset_handleMessage_pargs() noexcept {}

uint32_t Preset_handleMessage_pargs::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("Preset_handleMessage_pargs");

    xfer +=
        oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += (*(this->msg)).write(oprot);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

Preset_handleMessage_result::~Preset_handleMessage_result() noexcept {}

uint32_t Preset_handleMessage_result::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 0:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->success.read(iprot);
                    this->__isset.success = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->ouch.read(iprot);
                    this->__isset.ouch = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t Preset_handleMessage_result::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;

    xfer += oprot->writeStructBegin("Preset_handleMessage_result");

    if (this->__isset.success) {
        xfer += oprot->writeFieldBegin("success",
                                       ::apache::thrift::protocol::T_STRUCT, 0);
        xfer += this->success.write(oprot);
        xfer += oprot->writeFieldEnd();
    } else if (this->__isset.ouch) {
        xfer += oprot->writeFieldBegin("ouch",
                                       ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->ouch.write(oprot);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

Preset_handleMessage_presult::~Preset_handleMessage_presult() noexcept {}

uint32_t Preset_handleMessage_presult::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 0:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += (*(this->success)).read(iprot);
                    this->__isset.success = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->ouch.read(iprot);
                    this->__isset.ouch = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

PresetClient::PresetClient(
    boost::asio::io_context& io_context,
    std::shared_ptr<::apache::thrift::protocol::TProtocol> prot)
    : socket_(io_context), pibuf_(nullptr), pobuf_(nullptr) {
    pibuf_ = std::make_shared<byte_buf>();
    pobuf_ = pibuf_;
    prot->init_buf(pibuf_.get());
    setProtocol(prot);
    response_.resize(MAX_RESPONSE_LENGTH);
}

PresetClient::PresetClient(
    boost::asio::io_context& io_context,
    std::shared_ptr<::apache::thrift::protocol::TProtocol> iprot,
    std::shared_ptr<::apache::thrift::protocol::TProtocol> oprot)
    : socket_(io_context), pibuf_(nullptr), pobuf_(nullptr) {
    pibuf_ = std::make_shared<byte_buf>();
    pobuf_ = std::make_shared<byte_buf>();
    iprot->init_buf(pibuf_.get());
    oprot->init_buf(pobuf_.get());
    setProtocol(iprot, oprot);
    response_.resize(MAX_RESPONSE_LENGTH);
}

bool PresetClient::connect(const std::string& host, uint32_t port) {
    try {
        boost::asio::ip::tcp::endpoint ep(
            boost::asio::ip::address::from_string(host), port);
        socket_.connect(ep);
        return socket_.is_open();
    } catch (std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
        return false;
    }
}

bool PresetClient::sendMessage() {
    try {
        if (!pobuf_ || !socket_.is_open()) return false;
        socket_.write_some(boost::asio::buffer(pobuf_->get_read_ptr(),
                                               pobuf_->get_valid_read_len()));
        return true;
    } catch (std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
        return false;
    }
}

void PresetClient::receiveMessage() {
    try {
        std::memset(&response_[0], 0, MAX_RESPONSE_LENGTH);
        size_t reply_length = socket_.read_some(
            boost::asio::buffer(&response_[0], MAX_RESPONSE_LENGTH));
        // std::cout << "Received: " << response_ << std::endl;
        if (pibuf_) {
            pibuf_->reset();
            pibuf_->write_to_byte_buf(&response_[0], reply_length);
        }
    } catch (std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }
}

void PresetClient::ping(std::string& _return) {
    send_ping();
    recv_ping(_return);
}

void PresetClient::send_ping() {
    int32_t cseqid = 0;
    // oprot_->writeMessageBegin("ping", ::apache::thrift::protocol::T_CALL,
    //                           cseqid);
    oprot_->writeMessageBegin("ping", network::T_CALL, cseqid);

    Preset_ping_pargs args;
    args.write(oprot_);

    oprot_->writeMessageEnd();
    // oprot_->getTransport()->writeEnd();
    // oprot_->getTransport()->flush();
    sendMessage();
    pobuf_->reset();
    receiveMessage();
}

void PresetClient::recv_ping(std::string& _return) {
    int32_t rseqid = 0;
    std::string fname;
    // ::apache::thrift::protocol::TMessageType mtype;
    network::TMessageType mtype;

    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == network::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        // iprot_->getTransport()->readEnd();
        pibuf_->reset();
        throw x;
    }
    if (mtype != network::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        // iprot_->getTransport()->readEnd();
        pibuf_->reset();
    }
    if (fname.compare("ping") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        // iprot_->getTransport()->readEnd();
        pibuf_->reset();
    }
    Preset_ping_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    // iprot_->getTransport()->readEnd();
    pibuf_->reset();

    if (result.__isset.success) {
        // _return pointer has now been filled
        return;
    }
    throw ::apache::thrift::TApplicationException(
        ::apache::thrift::TApplicationException::MISSING_RESULT,
        "ping failed: unknown result");
}

void PresetClient::handleMessage(ResultStruct& _return, const Message& msg) {
    send_handleMessage(msg);
    recv_handleMessage(_return);
}

void PresetClient::send_handleMessage(const Message& msg) {
    int32_t cseqid = 0;
    oprot_->writeMessageBegin("handleMessage", network::T_CALL, cseqid);

    Preset_handleMessage_pargs args;
    args.msg = &msg;
    args.write(oprot_);

    oprot_->writeMessageEnd();
    // oprot_->getTransport()->writeEnd();
    // oprot_->getTransport()->flush();
    sendMessage();
    pobuf_->reset();
    receiveMessage();
}

void PresetClient::recv_handleMessage(ResultStruct& _return) {
    int32_t rseqid = 0;
    std::string fname;
    // ::apache::thrift::protocol::TMessageType mtype;
    network::TMessageType mtype;

    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == network::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        // iprot_->getTransport()->readEnd();
        pibuf_->reset();
        throw x;
    }
    if (mtype != network::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        // iprot_->getTransport()->readEnd();
        pibuf_->reset();
    }
    if (fname.compare("handleMessage") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        // iprot_->getTransport()->readEnd();
        pibuf_->reset();
    }
    Preset_handleMessage_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    // iprot_->getTransport()->readEnd();
    pibuf_->reset();

    if (result.__isset.success) {
        // _return pointer has now been filled
        return;
    }
    if (result.__isset.ouch) {
        throw result.ouch;
    }
    throw ::apache::thrift::TApplicationException(
        ::apache::thrift::TApplicationException::MISSING_RESULT,
        "handleMessage failed: unknown result");
}

}  // namespace occ
