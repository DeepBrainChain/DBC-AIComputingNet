/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "matrix_types.h"

#include <algorithm>
#include <ostream>

namespace matrix { namespace service_core {


network_address::~network_address() throw() {
}


void network_address::__set_ip(const std::string& val) {
  this->ip = val;
}

void network_address::__set_port(const int16_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const network_address& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t network_address::read(protocol* iprot) {


  uint32_t xfer = 0;
  std::string fname;
  TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == T_I16) {
          xfer += iprot->readI16(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t network_address::write(protocol* oprot) const {
  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("network_address");

  xfer += oprot->writeFieldBegin("ip", T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", T_I16, 2);
  xfer += oprot->writeI16(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(network_address &a, network_address &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

network_address::network_address(const network_address& other0) {
  ip = other0.ip;
  port = other0.port;
  __isset = other0.__isset;
}
network_address& network_address::operator=(const network_address& other1) {
  ip = other1.ip;
  port = other1.port;
  __isset = other1.__isset;
  return *this;
}
void network_address::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "network_address(";
  out << "ip=" << to_string(ip);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


msg_header::~msg_header() throw() {
}


void msg_header::__set_length(const int32_t val) {
  this->length = val;
}

void msg_header::__set_magic(const int32_t val) {
  this->magic = val;
}

void msg_header::__set_msg_name(const std::string& val) {
  this->msg_name = val;
}

void msg_header::__set_check_sum(const int32_t val) {
  this->check_sum = val;
}

void msg_header::__set_session_id(const int32_t val) {
  this->session_id = val;
}

void msg_header::__set_exten_info(const std::map<std::string, std::string> & val) {
  this->exten_info = val;
__isset.exten_info = true;
}
std::ostream& operator<<(std::ostream& out, const msg_header& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t msg_header::read(protocol* iprot) {


  uint32_t xfer = 0;
  std::string fname;
  TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_I32) {
          xfer += iprot->readI32(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == T_I32) {
          xfer += iprot->readI32(this->magic);
          this->__isset.magic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->msg_name);
          this->__isset.msg_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == T_I32) {
          xfer += iprot->readI32(this->check_sum);
          this->__isset.check_sum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == T_I32) {
          xfer += iprot->readI32(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == T_MAP) {
          {
            this->exten_info.clear();
            uint32_t _size2;
            TType _ktype3;
            TType _vtype4;
            xfer += iprot->readMapBegin(_ktype3, _vtype4, _size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              std::string _key7;
              xfer += iprot->readString(_key7);
              std::string& _val8 = this->exten_info[_key7];
              xfer += iprot->readString(_val8);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.exten_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t msg_header::write(protocol* oprot) const {
  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("msg_header");

  xfer += oprot->writeFieldBegin("length", T_I32, 1);
  xfer += oprot->writeI32(this->length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("magic", T_I32, 2);
  xfer += oprot->writeI32(this->magic);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msg_name", T_STRING, 3);
  xfer += oprot->writeString(this->msg_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("check_sum", T_I32, 4);
  xfer += oprot->writeI32(this->check_sum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", T_I32, 5);
  xfer += oprot->writeI32(this->session_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.exten_info) {
    xfer += oprot->writeFieldBegin("exten_info", T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(T_STRING, T_STRING, static_cast<uint32_t>(this->exten_info.size()));
      std::map<std::string, std::string> ::const_iterator _iter9;
      for (_iter9 = this->exten_info.begin(); _iter9 != this->exten_info.end(); ++_iter9)
      {
        xfer += oprot->writeString(_iter9->first);
        xfer += oprot->writeString(_iter9->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(msg_header &a, msg_header &b) {
  using ::std::swap;
  swap(a.length, b.length);
  swap(a.magic, b.magic);
  swap(a.msg_name, b.msg_name);
  swap(a.check_sum, b.check_sum);
  swap(a.session_id, b.session_id);
  swap(a.exten_info, b.exten_info);
  swap(a.__isset, b.__isset);
}

msg_header::msg_header(const msg_header& other10) {
  length = other10.length;
  magic = other10.magic;
  msg_name = other10.msg_name;
  check_sum = other10.check_sum;
  session_id = other10.session_id;
  exten_info = other10.exten_info;
  __isset = other10.__isset;
}
msg_header& msg_header::operator=(const msg_header& other11) {
  length = other11.length;
  magic = other11.magic;
  msg_name = other11.msg_name;
  check_sum = other11.check_sum;
  session_id = other11.session_id;
  exten_info = other11.exten_info;
  __isset = other11.__isset;
  return *this;
}
void msg_header::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "msg_header(";
  out << "length=" << to_string(length);
  out << ", " << "magic=" << to_string(magic);
  out << ", " << "msg_name=" << to_string(msg_name);
  out << ", " << "check_sum=" << to_string(check_sum);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "exten_info="; (__isset.exten_info ? (out << to_string(exten_info)) : (out << "<null>"));
  out << ")";
}


ver_req_body::~ver_req_body() throw() {
}


void ver_req_body::__set_version(const int32_t val) {
  this->version = val;
}

void ver_req_body::__set_time_stamp(const int64_t val) {
  this->time_stamp = val;
}

void ver_req_body::__set_addr_me(const network_address& val) {
  this->addr_me = val;
}

void ver_req_body::__set_addr_you(const network_address& val) {
  this->addr_you = val;
}

void ver_req_body::__set_nonce(const int64_t val) {
  this->nonce = val;
}

void ver_req_body::__set_start_height(const int32_t val) {
  this->start_height = val;
}
std::ostream& operator<<(std::ostream& out, const ver_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ver_req_body::read(protocol* iprot) {


  uint32_t xfer = 0;
  std::string fname;
  TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == T_I64) {
          xfer += iprot->readI64(this->time_stamp);
          this->__isset.time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == T_STRUCT) {
          xfer += this->addr_me.read(iprot);
          this->__isset.addr_me = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == T_STRUCT) {
          xfer += this->addr_you.read(iprot);
          this->__isset.addr_you = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == T_I64) {
          xfer += iprot->readI64(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == T_I32) {
          xfer += iprot->readI32(this->start_height);
          this->__isset.start_height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ver_req_body::write(protocol* oprot) const {
  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ver_req_body");

  xfer += oprot->writeFieldBegin("version", T_I32, 1);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_stamp", T_I64, 2);
  xfer += oprot->writeI64(this->time_stamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr_me", T_STRUCT, 3);
  xfer += this->addr_me.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr_you", T_STRUCT, 4);
  xfer += this->addr_you.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", T_I64, 5);
  xfer += oprot->writeI64(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_height", T_I32, 6);
  xfer += oprot->writeI32(this->start_height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ver_req_body &a, ver_req_body &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.time_stamp, b.time_stamp);
  swap(a.addr_me, b.addr_me);
  swap(a.addr_you, b.addr_you);
  swap(a.nonce, b.nonce);
  swap(a.start_height, b.start_height);
  swap(a.__isset, b.__isset);
}

ver_req_body::ver_req_body(const ver_req_body& other12) {
  version = other12.version;
  time_stamp = other12.time_stamp;
  addr_me = other12.addr_me;
  addr_you = other12.addr_you;
  nonce = other12.nonce;
  start_height = other12.start_height;
  __isset = other12.__isset;
}
ver_req_body& ver_req_body::operator=(const ver_req_body& other13) {
  version = other13.version;
  time_stamp = other13.time_stamp;
  addr_me = other13.addr_me;
  addr_you = other13.addr_you;
  nonce = other13.nonce;
  start_height = other13.start_height;
  __isset = other13.__isset;
  return *this;
}
void ver_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ver_req_body(";
  out << "version=" << to_string(version);
  out << ", " << "time_stamp=" << to_string(time_stamp);
  out << ", " << "addr_me=" << to_string(addr_me);
  out << ", " << "addr_you=" << to_string(addr_you);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "start_height=" << to_string(start_height);
  out << ")";
}


ver_req::~ver_req() throw() {
}


void ver_req::__set_header(const msg_header& val) {
  this->header = val;
}

void ver_req::__set_body(const ver_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const ver_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ver_req::read(protocol* iprot) {


  uint32_t xfer = 0;
  std::string fname;
  TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ver_req::write(protocol* oprot) const {
  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ver_req");

  xfer += oprot->writeFieldBegin("header", T_STRUCT, 1);
  xfer += this->header.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", T_STRUCT, 2);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ver_req &a, ver_req &b) {
  using ::std::swap;
  swap(a.header, b.header);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

ver_req::ver_req(const ver_req& other14) {
  header = other14.header;
  body = other14.body;
  __isset = other14.__isset;
}
ver_req& ver_req::operator=(const ver_req& other15) {
  header = other15.header;
  body = other15.body;
  __isset = other15.__isset;
  return *this;
}
void ver_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ver_req(";
  out << "header=" << to_string(header);
  out << ", " << "body=" << to_string(body);
  out << ")";
}


ver_resp_body::~ver_resp_body() throw() {
}


void ver_resp_body::__set_version(const int32_t val) {
  this->version = val;
}
std::ostream& operator<<(std::ostream& out, const ver_resp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ver_resp_body::read(protocol* iprot) {


  uint32_t xfer = 0;
  std::string fname;
  TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ver_resp_body::write(protocol* oprot) const {
  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ver_resp_body");

  xfer += oprot->writeFieldBegin("version", T_I32, 1);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ver_resp_body &a, ver_resp_body &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

ver_resp_body::ver_resp_body(const ver_resp_body& other16) {
  version = other16.version;
  __isset = other16.__isset;
}
ver_resp_body& ver_resp_body::operator=(const ver_resp_body& other17) {
  version = other17.version;
  __isset = other17.__isset;
  return *this;
}
void ver_resp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ver_resp_body(";
  out << "version=" << to_string(version);
  out << ")";
}


ver_resp::~ver_resp() throw() {
}


void ver_resp::__set_header(const msg_header& val) {
  this->header = val;
}

void ver_resp::__set_body(const ver_resp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const ver_resp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ver_resp::read(protocol* iprot) {


  uint32_t xfer = 0;
  std::string fname;
  TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ver_resp::write(protocol* oprot) const {
  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ver_resp");

  xfer += oprot->writeFieldBegin("header", T_STRUCT, 1);
  xfer += this->header.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", T_STRUCT, 2);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ver_resp &a, ver_resp &b) {
  using ::std::swap;
  swap(a.header, b.header);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

ver_resp::ver_resp(const ver_resp& other18) {
  header = other18.header;
  body = other18.body;
  __isset = other18.__isset;
}
ver_resp& ver_resp::operator=(const ver_resp& other19) {
  header = other19.header;
  body = other19.body;
  __isset = other19.__isset;
  return *this;
}
void ver_resp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ver_resp(";
  out << "header=" << to_string(header);
  out << ", " << "body=" << to_string(body);
  out << ")";
}


shake_hand_req::~shake_hand_req() throw() {
}


void shake_hand_req::__set_header(const msg_header& val) {
  this->header = val;
}
std::ostream& operator<<(std::ostream& out, const shake_hand_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t shake_hand_req::read(protocol* iprot) {


  uint32_t xfer = 0;
  std::string fname;
  TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t shake_hand_req::write(protocol* oprot) const {
  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("shake_hand_req");

  xfer += oprot->writeFieldBegin("header", T_STRUCT, 1);
  xfer += this->header.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(shake_hand_req &a, shake_hand_req &b) {
  using ::std::swap;
  swap(a.header, b.header);
  swap(a.__isset, b.__isset);
}

shake_hand_req::shake_hand_req(const shake_hand_req& other20) {
  header = other20.header;
  __isset = other20.__isset;
}
shake_hand_req& shake_hand_req::operator=(const shake_hand_req& other21) {
  header = other21.header;
  __isset = other21.__isset;
  return *this;
}
void shake_hand_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "shake_hand_req(";
  out << "header=" << to_string(header);
  out << ")";
}


shake_hand_resp::~shake_hand_resp() throw() {
}


void shake_hand_resp::__set_header(const msg_header& val) {
  this->header = val;
}
std::ostream& operator<<(std::ostream& out, const shake_hand_resp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t shake_hand_resp::read(protocol* iprot) {


  uint32_t xfer = 0;
  std::string fname;
  TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t shake_hand_resp::write(protocol* oprot) const {
  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("shake_hand_resp");

  xfer += oprot->writeFieldBegin("header", T_STRUCT, 1);
  xfer += this->header.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(shake_hand_resp &a, shake_hand_resp &b) {
  using ::std::swap;
  swap(a.header, b.header);
  swap(a.__isset, b.__isset);
}

shake_hand_resp::shake_hand_resp(const shake_hand_resp& other22) {
  header = other22.header;
  __isset = other22.__isset;
}
shake_hand_resp& shake_hand_resp::operator=(const shake_hand_resp& other23) {
  header = other23.header;
  __isset = other23.__isset;
  return *this;
}
void shake_hand_resp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "shake_hand_resp(";
  out << "header=" << to_string(header);
  out << ")";
}

}} // namespace
