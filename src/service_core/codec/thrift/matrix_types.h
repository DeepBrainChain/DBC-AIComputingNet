/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef MATRIX_TYPES_H
#define MATRIX_TYPES_H

#include <iosfwd>

#include "protocol.h"
#include "service_message.h"
#include "TToString.h"

using namespace matrix::core;


namespace matrix { namespace service_core {

class network_address;

class msg_header;

class ver_req_body;

class ver_req;

class ver_resp_body;

class ver_resp;

class shake_hand_req;

class shake_hand_resp;

typedef struct _network_address__isset {
  _network_address__isset() : ip(false), port(false) {}
  bool ip :1;
  bool port :1;
} _network_address__isset;

class network_address : public virtual base {
 public:

  network_address(const network_address&);
  network_address& operator=(const network_address&);
  network_address() : ip(), port(0) {
  }

  virtual ~network_address() throw();
  std::string ip;
  int16_t port;

  _network_address__isset __isset;

  void __set_ip(const std::string& val);

  void __set_port(const int16_t val);

  bool operator == (const network_address & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const network_address &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const network_address & ) const;

  uint32_t read(protocol* iprot);
  uint32_t write(protocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(network_address &a, network_address &b);

std::ostream& operator<<(std::ostream& out, const network_address& obj);

typedef struct _msg_header__isset {
  _msg_header__isset() : length(false), magic(false), msg_name(false), check_sum(false), session_id(false), exten_info(false) {}
  bool length :1;
  bool magic :1;
  bool msg_name :1;
  bool check_sum :1;
  bool session_id :1;
  bool exten_info :1;
} _msg_header__isset;

class msg_header : public virtual base {
 public:

  msg_header(const msg_header&);
  msg_header& operator=(const msg_header&);
  msg_header() : length(0), magic(0), msg_name(), check_sum(0), session_id(0) {
  }

  virtual ~msg_header() throw();
  int32_t length;
  int32_t magic;
  std::string msg_name;
  int32_t check_sum;
  int32_t session_id;
  std::map<std::string, std::string>  exten_info;

  _msg_header__isset __isset;

  void __set_length(const int32_t val);

  void __set_magic(const int32_t val);

  void __set_msg_name(const std::string& val);

  void __set_check_sum(const int32_t val);

  void __set_session_id(const int32_t val);

  void __set_exten_info(const std::map<std::string, std::string> & val);

  bool operator == (const msg_header & rhs) const
  {
    if (!(length == rhs.length))
      return false;
    if (!(magic == rhs.magic))
      return false;
    if (!(msg_name == rhs.msg_name))
      return false;
    if (!(check_sum == rhs.check_sum))
      return false;
    if (!(session_id == rhs.session_id))
      return false;
    if (__isset.exten_info != rhs.__isset.exten_info)
      return false;
    else if (__isset.exten_info && !(exten_info == rhs.exten_info))
      return false;
    return true;
  }
  bool operator != (const msg_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const msg_header & ) const;

  uint32_t read(protocol* iprot);
  uint32_t write(protocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(msg_header &a, msg_header &b);

std::ostream& operator<<(std::ostream& out, const msg_header& obj);

typedef struct _ver_req_body__isset {
  _ver_req_body__isset() : version(false), time_stamp(false), addr_me(false), addr_you(false), nonce(false), start_height(false) {}
  bool version :1;
  bool time_stamp :1;
  bool addr_me :1;
  bool addr_you :1;
  bool nonce :1;
  bool start_height :1;
} _ver_req_body__isset;

class ver_req_body : public virtual base {
 public:

  ver_req_body(const ver_req_body&);
  ver_req_body& operator=(const ver_req_body&);
  ver_req_body() : version(0), time_stamp(0), nonce(0), start_height(0) {
  }

  virtual ~ver_req_body() throw();
  int32_t version;
  int64_t time_stamp;
  network_address addr_me;
  network_address addr_you;
  int64_t nonce;
  int32_t start_height;

  _ver_req_body__isset __isset;

  void __set_version(const int32_t val);

  void __set_time_stamp(const int64_t val);

  void __set_addr_me(const network_address& val);

  void __set_addr_you(const network_address& val);

  void __set_nonce(const int64_t val);

  void __set_start_height(const int32_t val);

  bool operator == (const ver_req_body & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (!(time_stamp == rhs.time_stamp))
      return false;
    if (!(addr_me == rhs.addr_me))
      return false;
    if (!(addr_you == rhs.addr_you))
      return false;
    if (!(nonce == rhs.nonce))
      return false;
    if (!(start_height == rhs.start_height))
      return false;
    return true;
  }
  bool operator != (const ver_req_body &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ver_req_body & ) const;

  uint32_t read(protocol* iprot);
  uint32_t write(protocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ver_req_body &a, ver_req_body &b);

std::ostream& operator<<(std::ostream& out, const ver_req_body& obj);

typedef struct _ver_req__isset {
  _ver_req__isset() : header(false), body(false) {}
  bool header :1;
  bool body :1;
} _ver_req__isset;

class ver_req : public virtual base {
 public:

  ver_req(const ver_req&);
  ver_req& operator=(const ver_req&);
  ver_req() {
  }

  virtual ~ver_req() throw();
  msg_header header;
  ver_req_body body;

  _ver_req__isset __isset;

  void __set_header(const msg_header& val);

  void __set_body(const ver_req_body& val);

  bool operator == (const ver_req & rhs) const
  {
    if (!(header == rhs.header))
      return false;
    if (!(body == rhs.body))
      return false;
    return true;
  }
  bool operator != (const ver_req &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ver_req & ) const;

  uint32_t read(protocol* iprot);
  uint32_t write(protocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ver_req &a, ver_req &b);

std::ostream& operator<<(std::ostream& out, const ver_req& obj);

typedef struct _ver_resp_body__isset {
  _ver_resp_body__isset() : version(false) {}
  bool version :1;
} _ver_resp_body__isset;

class ver_resp_body : public virtual base {
 public:

  ver_resp_body(const ver_resp_body&);
  ver_resp_body& operator=(const ver_resp_body&);
  ver_resp_body() : version(0) {
  }

  virtual ~ver_resp_body() throw();
  int32_t version;

  _ver_resp_body__isset __isset;

  void __set_version(const int32_t val);

  bool operator == (const ver_resp_body & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const ver_resp_body &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ver_resp_body & ) const;

  uint32_t read(protocol* iprot);
  uint32_t write(protocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ver_resp_body &a, ver_resp_body &b);

std::ostream& operator<<(std::ostream& out, const ver_resp_body& obj);

typedef struct _ver_resp__isset {
  _ver_resp__isset() : header(false), body(false) {}
  bool header :1;
  bool body :1;
} _ver_resp__isset;

class ver_resp : public virtual base {
 public:

  ver_resp(const ver_resp&);
  ver_resp& operator=(const ver_resp&);
  ver_resp() {
  }

  virtual ~ver_resp() throw();
  msg_header header;
  ver_resp_body body;

  _ver_resp__isset __isset;

  void __set_header(const msg_header& val);

  void __set_body(const ver_resp_body& val);

  bool operator == (const ver_resp & rhs) const
  {
    if (!(header == rhs.header))
      return false;
    if (!(body == rhs.body))
      return false;
    return true;
  }
  bool operator != (const ver_resp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ver_resp & ) const;

  uint32_t read(protocol* iprot);
  uint32_t write(protocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  };

void swap(ver_resp &a, ver_resp &b);

std::ostream& operator<<(std::ostream& out, const ver_resp& obj);

typedef struct _shake_hand_req__isset {
  _shake_hand_req__isset() : header(false) {}
  bool header :1;
} _shake_hand_req__isset;

class shake_hand_req : public virtual base {
 public:

  shake_hand_req(const shake_hand_req&);
  shake_hand_req& operator=(const shake_hand_req&);
  shake_hand_req() {
  }

  virtual ~shake_hand_req() throw();
  msg_header header;

  _shake_hand_req__isset __isset;

  void __set_header(const msg_header& val);

  bool operator == (const shake_hand_req & rhs) const
  {
    if (!(header == rhs.header))
      return false;
    return true;
  }
  bool operator != (const shake_hand_req &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const shake_hand_req & ) const;

  uint32_t read(protocol* iprot);
  uint32_t write(protocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(shake_hand_req &a, shake_hand_req &b);

std::ostream& operator<<(std::ostream& out, const shake_hand_req& obj);

typedef struct _shake_hand_resp__isset {
  _shake_hand_resp__isset() : header(false) {}
  bool header :1;
} _shake_hand_resp__isset;

class shake_hand_resp : public virtual base {
 public:

  shake_hand_resp(const shake_hand_resp&);
  shake_hand_resp& operator=(const shake_hand_resp&);
  shake_hand_resp() {
  }

  virtual ~shake_hand_resp() throw();
  msg_header header;

  _shake_hand_resp__isset __isset;

  void __set_header(const msg_header& val);

  bool operator == (const shake_hand_resp & rhs) const
  {
    if (!(header == rhs.header))
      return false;
    return true;
  }
  bool operator != (const shake_hand_resp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const shake_hand_resp & ) const;

  uint32_t read(protocol* iprot);
  uint32_t write(protocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(shake_hand_resp &a, shake_hand_resp &b);

std::ostream& operator<<(std::ostream& out, const shake_hand_resp& obj);

}} // namespace

#endif
