/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef db_TYPES_H
#define db_TYPES_H

#include <iosfwd>

#include "protocol.h"
#include "service_message.h"
#include "TToString.h"

using namespace matrix::core;



namespace ai { namespace dbc {

class ai_training_task;

typedef struct _ai_training_task__isset {
  _ai_training_task__isset() : task_id(false), select_mode(false), master(false), peer_nodes_list(false), server_specification(false), server_count(false), training_engine(false), code_dir(false), entry_file(false), data_dir(false), checkpoint_dir(false), hyper_parameters(false), retry_times(false), container_id(false), received_time_stamp(false), status(false) {}
  bool task_id :1;
  bool select_mode :1;
  bool master :1;
  bool peer_nodes_list :1;
  bool server_specification :1;
  bool server_count :1;
  bool training_engine :1;
  bool code_dir :1;
  bool entry_file :1;
  bool data_dir :1;
  bool checkpoint_dir :1;
  bool hyper_parameters :1;
  bool retry_times :1;
  bool container_id :1;
  bool received_time_stamp :1;
  bool status :1;
} _ai_training_task__isset;

class ai_training_task : public virtual base {
 public:

  ai_training_task(const ai_training_task&);
  ai_training_task& operator=(const ai_training_task&);
  ai_training_task() : task_id(), select_mode(0), master(), server_specification(), server_count(0), training_engine(0), code_dir(), entry_file(), data_dir(), checkpoint_dir(), hyper_parameters(), retry_times(0), container_id(), received_time_stamp(0), status(0) {
  }

  virtual ~ai_training_task() throw();
  std::string task_id;
  int8_t select_mode;
  std::string master;
  std::vector<std::string>  peer_nodes_list;
  std::string server_specification;
  int32_t server_count;
  int32_t training_engine;
  std::string code_dir;
  std::string entry_file;
  std::string data_dir;
  std::string checkpoint_dir;
  std::string hyper_parameters;
  int8_t retry_times;
  std::string container_id;
  int64_t received_time_stamp;
  int8_t status;

  _ai_training_task__isset __isset;

  void __set_task_id(const std::string& val);

  void __set_select_mode(const int8_t val);

  void __set_master(const std::string& val);

  void __set_peer_nodes_list(const std::vector<std::string> & val);

  void __set_server_specification(const std::string& val);

  void __set_server_count(const int32_t val);

  void __set_training_engine(const int32_t val);

  void __set_code_dir(const std::string& val);

  void __set_entry_file(const std::string& val);

  void __set_data_dir(const std::string& val);

  void __set_checkpoint_dir(const std::string& val);

  void __set_hyper_parameters(const std::string& val);

  void __set_retry_times(const int8_t val);

  void __set_container_id(const std::string& val);

  void __set_received_time_stamp(const int64_t val);

  void __set_status(const int8_t val);

  bool operator == (const ai_training_task & rhs) const
  {
    if (!(task_id == rhs.task_id))
      return false;
    if (!(select_mode == rhs.select_mode))
      return false;
    if (!(master == rhs.master))
      return false;
    if (!(peer_nodes_list == rhs.peer_nodes_list))
      return false;
    if (!(server_specification == rhs.server_specification))
      return false;
    if (!(server_count == rhs.server_count))
      return false;
    if (!(training_engine == rhs.training_engine))
      return false;
    if (!(code_dir == rhs.code_dir))
      return false;
    if (!(entry_file == rhs.entry_file))
      return false;
    if (!(data_dir == rhs.data_dir))
      return false;
    if (!(checkpoint_dir == rhs.checkpoint_dir))
      return false;
    if (!(hyper_parameters == rhs.hyper_parameters))
      return false;
    if (!(retry_times == rhs.retry_times))
      return false;
    if (!(container_id == rhs.container_id))
      return false;
    if (!(received_time_stamp == rhs.received_time_stamp))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const ai_training_task &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ai_training_task & ) const;

  uint32_t read(protocol* iprot);
  uint32_t write(protocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ai_training_task &a, ai_training_task &b);

std::ostream& operator<<(std::ostream& out, const ai_training_task& obj);

}} // namespace

#endif
