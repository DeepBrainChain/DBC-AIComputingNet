/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "db_types.h"

#include <algorithm>
#include <ostream>



namespace ai { namespace dbc {


ai_training_task::~ai_training_task() throw() {
}


void ai_training_task::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void ai_training_task::__set_select_mode(const int8_t val) {
  this->select_mode = val;
}

void ai_training_task::__set_master(const std::string& val) {
  this->master = val;
}

void ai_training_task::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void ai_training_task::__set_server_specification(const std::string& val) {
  this->server_specification = val;
}

void ai_training_task::__set_server_count(const int32_t val) {
  this->server_count = val;
}

void ai_training_task::__set_training_engine(const int32_t val) {
  this->training_engine = val;
}

void ai_training_task::__set_code_dir(const std::string& val) {
  this->code_dir = val;
}

void ai_training_task::__set_entry_file(const std::string& val) {
  this->entry_file = val;
}

void ai_training_task::__set_data_dir(const std::string& val) {
  this->data_dir = val;
}

void ai_training_task::__set_checkpoint_dir(const std::string& val) {
  this->checkpoint_dir = val;
}

void ai_training_task::__set_hyper_parameters(const std::string& val) {
  this->hyper_parameters = val;
}

void ai_training_task::__set_retry_times(const int8_t val) {
  this->retry_times = val;
}

void ai_training_task::__set_container_id(const std::string& val) {
  this->container_id = val;
}

void ai_training_task::__set_received_time_stamp(const int64_t val) {
  this->received_time_stamp = val;
}

void ai_training_task::__set_status(const int8_t val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const ai_training_task& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ai_training_task::read(protocol* iprot) {

  
  uint32_t xfer = 0;
  std::string fname;
  TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == T_BYTE) {
          xfer += iprot->readByte(this->select_mode);
          this->__isset.select_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->master);
          this->__isset.master = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size0;
            TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->peer_nodes_list.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->server_specification);
          this->__isset.server_specification = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == T_I32) {
          xfer += iprot->readI32(this->server_count);
          this->__isset.server_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == T_I32) {
          xfer += iprot->readI32(this->training_engine);
          this->__isset.training_engine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->code_dir);
          this->__isset.code_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->entry_file);
          this->__isset.entry_file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->data_dir);
          this->__isset.data_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->checkpoint_dir);
          this->__isset.checkpoint_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->hyper_parameters);
          this->__isset.hyper_parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 252:
        if (ftype == T_BYTE) {
          xfer += iprot->readByte(this->retry_times);
          this->__isset.retry_times = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 253:
        if (ftype == T_STRING) {
          xfer += iprot->readString(this->container_id);
          this->__isset.container_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 254:
        if (ftype == T_I64) {
          xfer += iprot->readI64(this->received_time_stamp);
          this->__isset.received_time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 255:
        if (ftype == T_BYTE) {
          xfer += iprot->readByte(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ai_training_task::write(protocol* oprot) const {
  uint32_t xfer = 0;
  
  xfer += oprot->writeStructBegin("ai_training_task");

  xfer += oprot->writeFieldBegin("task_id", T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_mode", T_BYTE, 2);
  xfer += oprot->writeByte(this->select_mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("master", T_STRING, 3);
  xfer += oprot->writeString(this->master);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", T_LIST, 4);
  {
    xfer += oprot->writeListBegin(T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter5;
    for (_iter5 = this->peer_nodes_list.begin(); _iter5 != this->peer_nodes_list.end(); ++_iter5)
    {
      xfer += oprot->writeString((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("server_specification", T_STRING, 5);
  xfer += oprot->writeString(this->server_specification);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("server_count", T_I32, 6);
  xfer += oprot->writeI32(this->server_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("training_engine", T_I32, 7);
  xfer += oprot->writeI32(this->training_engine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code_dir", T_STRING, 8);
  xfer += oprot->writeString(this->code_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry_file", T_STRING, 9);
  xfer += oprot->writeString(this->entry_file);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_dir", T_STRING, 10);
  xfer += oprot->writeString(this->data_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("checkpoint_dir", T_STRING, 11);
  xfer += oprot->writeString(this->checkpoint_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hyper_parameters", T_STRING, 12);
  xfer += oprot->writeString(this->hyper_parameters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retry_times", T_BYTE, 252);
  xfer += oprot->writeByte(this->retry_times);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("container_id", T_STRING, 253);
  xfer += oprot->writeString(this->container_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("received_time_stamp", T_I64, 254);
  xfer += oprot->writeI64(this->received_time_stamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", T_BYTE, 255);
  xfer += oprot->writeByte(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ai_training_task &a, ai_training_task &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.select_mode, b.select_mode);
  swap(a.master, b.master);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.server_specification, b.server_specification);
  swap(a.server_count, b.server_count);
  swap(a.training_engine, b.training_engine);
  swap(a.code_dir, b.code_dir);
  swap(a.entry_file, b.entry_file);
  swap(a.data_dir, b.data_dir);
  swap(a.checkpoint_dir, b.checkpoint_dir);
  swap(a.hyper_parameters, b.hyper_parameters);
  swap(a.retry_times, b.retry_times);
  swap(a.container_id, b.container_id);
  swap(a.received_time_stamp, b.received_time_stamp);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

ai_training_task::ai_training_task(const ai_training_task& other6) {
  task_id = other6.task_id;
  select_mode = other6.select_mode;
  master = other6.master;
  peer_nodes_list = other6.peer_nodes_list;
  server_specification = other6.server_specification;
  server_count = other6.server_count;
  training_engine = other6.training_engine;
  code_dir = other6.code_dir;
  entry_file = other6.entry_file;
  data_dir = other6.data_dir;
  checkpoint_dir = other6.checkpoint_dir;
  hyper_parameters = other6.hyper_parameters;
  retry_times = other6.retry_times;
  container_id = other6.container_id;
  received_time_stamp = other6.received_time_stamp;
  status = other6.status;
  __isset = other6.__isset;
}
ai_training_task& ai_training_task::operator=(const ai_training_task& other7) {
  task_id = other7.task_id;
  select_mode = other7.select_mode;
  master = other7.master;
  peer_nodes_list = other7.peer_nodes_list;
  server_specification = other7.server_specification;
  server_count = other7.server_count;
  training_engine = other7.training_engine;
  code_dir = other7.code_dir;
  entry_file = other7.entry_file;
  data_dir = other7.data_dir;
  checkpoint_dir = other7.checkpoint_dir;
  hyper_parameters = other7.hyper_parameters;
  retry_times = other7.retry_times;
  container_id = other7.container_id;
  received_time_stamp = other7.received_time_stamp;
  status = other7.status;
  __isset = other7.__isset;
  return *this;
}
void ai_training_task::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ai_training_task(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "select_mode=" << to_string(select_mode);
  out << ", " << "master=" << to_string(master);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "server_specification=" << to_string(server_specification);
  out << ", " << "server_count=" << to_string(server_count);
  out << ", " << "training_engine=" << to_string(training_engine);
  out << ", " << "code_dir=" << to_string(code_dir);
  out << ", " << "entry_file=" << to_string(entry_file);
  out << ", " << "data_dir=" << to_string(data_dir);
  out << ", " << "checkpoint_dir=" << to_string(checkpoint_dir);
  out << ", " << "hyper_parameters=" << to_string(hyper_parameters);
  out << ", " << "retry_times=" << to_string(retry_times);
  out << ", " << "container_id=" << to_string(container_id);
  out << ", " << "received_time_stamp=" << to_string(received_time_stamp);
  out << ", " << "status=" << to_string(status);
  out << ")";
}

}} // namespace
