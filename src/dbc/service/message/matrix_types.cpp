/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "matrix_types.h"

#include <algorithm>
#include <ostream>

namespace dbc {


    empty::~empty() throw() {
    }

    std::ostream& operator<<(std::ostream& out, const empty& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t empty::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            xfer += iprot->skip(ftype);
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t empty::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("empty");

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(empty &a, empty &b) {
        using ::std::swap;
        (void) a;
        (void) b;
    }

    empty::empty(const empty& other0) {
        (void) other0;
    }
    empty& empty::operator=(const empty& other1) {
        (void) other1;
        return *this;
    }
    void empty::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "empty(";
        out << ")";
    }


    network_address::~network_address() throw() {
    }


    void network_address::__set_ip(const std::string& val) {
        this->ip = val;
    }

    void network_address::__set_port(const int16_t val) {
        this->port = val;
    }
    std::ostream& operator<<(std::ostream& out, const network_address& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t network_address::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_ip = false;
        bool isset_port = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->ip);
                        isset_ip = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I16) {
                            xfer += iprot->readI16(this->port);
                            isset_port = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_ip)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_port)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t network_address::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("network_address");

        xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->ip);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 2);
        xfer += oprot->writeI16(this->port);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(network_address &a, network_address &b) {
        using ::std::swap;
        swap(a.ip, b.ip);
        swap(a.port, b.port);
    }

    network_address::network_address(const network_address& other2) {
        ip = other2.ip;
        port = other2.port;
    }
    network_address& network_address::operator=(const network_address& other3) {
        ip = other3.ip;
        port = other3.port;
        return *this;
    }
    void network_address::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "network_address(";
        out << "ip=" << to_string(ip);
        out << ", " << "port=" << to_string(port);
        out << ")";
    }


    peer_node_info::~peer_node_info() throw() {
    }


    void peer_node_info::__set_peer_node_id(const std::string& val) {
        this->peer_node_id = val;
    }

    void peer_node_info::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void peer_node_info::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }

    void peer_node_info::__set_live_time_stamp(const int32_t val) {
        this->live_time_stamp = val;
    }

    void peer_node_info::__set_addr(const network_address& val) {
        this->addr = val;
    }

    void peer_node_info::__set_service_list(const std::vector<std::string> & val) {
        this->service_list = val;
        __isset.service_list = true;
    }
    std::ostream& operator<<(std::ostream& out, const peer_node_info& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;
        bool isset_live_time_stamp = false;
        bool isset_addr = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->peer_node_id);
                        isset_peer_node_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->core_version);
                            isset_core_version = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_I32) {
                                xfer += iprot->readI32(this->protocol_version);
                                isset_protocol_version = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_I32) {
                                    xfer += iprot->readI32(this->live_time_stamp);
                                    isset_live_time_stamp = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                                        xfer += this->addr.read(iprot);
                                        isset_addr = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    case 6:
                                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                                            {
                                                this->service_list.clear();
                                                uint32_t _size4;
                                                ::apache::thrift::protocol::TType _etype7;
                                                xfer += iprot->readListBegin(_etype7, _size4);
                                                this->service_list.resize(_size4);
                                                uint32_t _i8;
                                                for (_i8 = 0; _i8 < _size4; ++_i8)
                                                {
                                                    xfer += iprot->readString(this->service_list[_i8]);
                                                }
                                                xfer += iprot->readListEnd();
                                            }
                                            this->__isset.service_list = true;
                                        } else {
                                            xfer += iprot->skip(ftype);
                                        }
                                        break;
                                        default:
                                            xfer += iprot->skip(ftype);
                                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_live_time_stamp)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t peer_node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_node_info");

        xfer += oprot->writeFieldBegin("peer_node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->peer_node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("live_time_stamp", ::apache::thrift::protocol::T_I32, 4);
        xfer += oprot->writeI32(this->live_time_stamp);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRUCT, 5);
        xfer += this->addr.write(oprot);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.service_list) {
            xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 6);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
                std::vector<std::string> ::const_iterator _iter9;
                for (_iter9 = this->service_list.begin(); _iter9 != this->service_list.end(); ++_iter9)
                {
                    xfer += oprot->writeString((*_iter9));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_node_info &a, peer_node_info &b) {
        using ::std::swap;
        swap(a.peer_node_id, b.peer_node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
        swap(a.live_time_stamp, b.live_time_stamp);
        swap(a.addr, b.addr);
        swap(a.service_list, b.service_list);
        swap(a.__isset, b.__isset);
    }

    peer_node_info::peer_node_info(const peer_node_info& other10) {
        peer_node_id = other10.peer_node_id;
        core_version = other10.core_version;
        protocol_version = other10.protocol_version;
        live_time_stamp = other10.live_time_stamp;
        addr = other10.addr;
        service_list = other10.service_list;
        __isset = other10.__isset;
    }
    peer_node_info& peer_node_info::operator=(const peer_node_info& other11) {
        peer_node_id = other11.peer_node_id;
        core_version = other11.core_version;
        protocol_version = other11.protocol_version;
        live_time_stamp = other11.live_time_stamp;
        addr = other11.addr;
        service_list = other11.service_list;
        __isset = other11.__isset;
        return *this;
    }
    void peer_node_info::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_node_info(";
        out << "peer_node_id=" << to_string(peer_node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ", " << "live_time_stamp=" << to_string(live_time_stamp);
        out << ", " << "addr=" << to_string(addr);
        out << ", " << "service_list="; (__isset.service_list ? (out << to_string(service_list)) : (out << "<null>"));
        out << ")";
    }


    shake_hand_req::~shake_hand_req() throw() {
    }


    void shake_hand_req::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const shake_hand_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t shake_hand_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t shake_hand_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("shake_hand_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(shake_hand_req &a, shake_hand_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    shake_hand_req::shake_hand_req(const shake_hand_req& other12) {
        body = other12.body;
        __isset = other12.__isset;
    }
    shake_hand_req& shake_hand_req::operator=(const shake_hand_req& other13) {
        body = other13.body;
        __isset = other13.__isset;
        return *this;
    }
    void shake_hand_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "shake_hand_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    shake_hand_resp::~shake_hand_resp() throw() {
    }


    void shake_hand_resp::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const shake_hand_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t shake_hand_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t shake_hand_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("shake_hand_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(shake_hand_resp &a, shake_hand_resp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    shake_hand_resp::shake_hand_resp(const shake_hand_resp& other14) {
        body = other14.body;
        __isset = other14.__isset;
    }
    shake_hand_resp& shake_hand_resp::operator=(const shake_hand_resp& other15) {
        body = other15.body;
        __isset = other15.__isset;
        return *this;
    }
    void shake_hand_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "shake_hand_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    get_peer_nodes_req::~get_peer_nodes_req() throw() {
    }


    void get_peer_nodes_req::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t get_peer_nodes_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_req &a, get_peer_nodes_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    get_peer_nodes_req::get_peer_nodes_req(const get_peer_nodes_req& other16) {
        body = other16.body;
        __isset = other16.__isset;
    }
    get_peer_nodes_req& get_peer_nodes_req::operator=(const get_peer_nodes_req& other17) {
        body = other17.body;
        __isset = other17.__isset;
        return *this;
    }
    void get_peer_nodes_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    get_peer_nodes_resp_body::~get_peer_nodes_resp_body() throw() {
    }


    void get_peer_nodes_resp_body::__set_peer_nodes_list(const std::vector<peer_node_info> & val) {
        this->peer_nodes_list = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size18;
                            ::apache::thrift::protocol::TType _etype21;
                            xfer += iprot->readListBegin(_etype21, _size18);
                            this->peer_nodes_list.resize(_size18);
                            uint32_t _i22;
                            for (_i22 = 0; _i22 < _size18; ++_i22)
                            {
                                xfer += this->peer_nodes_list[_i22].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t get_peer_nodes_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_resp_body");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<peer_node_info> ::const_iterator _iter23;
            for (_iter23 = this->peer_nodes_list.begin(); _iter23 != this->peer_nodes_list.end(); ++_iter23)
            {
                xfer += (*_iter23).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_resp_body &a, get_peer_nodes_resp_body &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
    }

    get_peer_nodes_resp_body::get_peer_nodes_resp_body(const get_peer_nodes_resp_body& other24) {
        peer_nodes_list = other24.peer_nodes_list;
    }
    get_peer_nodes_resp_body& get_peer_nodes_resp_body::operator=(const get_peer_nodes_resp_body& other25) {
        peer_nodes_list = other25.peer_nodes_list;
        return *this;
    }
    void get_peer_nodes_resp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_resp_body(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ")";
    }


    get_peer_nodes_resp::~get_peer_nodes_resp() throw() {
    }


    void get_peer_nodes_resp::__set_body(const get_peer_nodes_resp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t get_peer_nodes_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_resp &a, get_peer_nodes_resp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    get_peer_nodes_resp::get_peer_nodes_resp(const get_peer_nodes_resp& other26) {
        body = other26.body;
        __isset = other26.__isset;
    }
    get_peer_nodes_resp& get_peer_nodes_resp::operator=(const get_peer_nodes_resp& other27) {
        body = other27.body;
        __isset = other27.__isset;
        return *this;
    }
    void get_peer_nodes_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    peer_nodes_broadcast_req_body::~peer_nodes_broadcast_req_body() throw() {
    }


    void peer_nodes_broadcast_req_body::__set_peer_nodes_list(const std::vector<peer_node_info> & val) {
        this->peer_nodes_list = val;
    }
    std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_nodes_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size28;
                            ::apache::thrift::protocol::TType _etype31;
                            xfer += iprot->readListBegin(_etype31, _size28);
                            this->peer_nodes_list.resize(_size28);
                            uint32_t _i32;
                            for (_i32 = 0; _i32 < _size28; ++_i32)
                            {
                                xfer += this->peer_nodes_list[_i32].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t peer_nodes_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_nodes_broadcast_req_body");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<peer_node_info> ::const_iterator _iter33;
            for (_iter33 = this->peer_nodes_list.begin(); _iter33 != this->peer_nodes_list.end(); ++_iter33)
            {
                xfer += (*_iter33).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_nodes_broadcast_req_body &a, peer_nodes_broadcast_req_body &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
    }

    peer_nodes_broadcast_req_body::peer_nodes_broadcast_req_body(const peer_nodes_broadcast_req_body& other34) {
        peer_nodes_list = other34.peer_nodes_list;
    }
    peer_nodes_broadcast_req_body& peer_nodes_broadcast_req_body::operator=(const peer_nodes_broadcast_req_body& other35) {
        peer_nodes_list = other35.peer_nodes_list;
        return *this;
    }
    void peer_nodes_broadcast_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_nodes_broadcast_req_body(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ")";
    }


    peer_nodes_broadcast_req::~peer_nodes_broadcast_req() throw() {
    }


    void peer_nodes_broadcast_req::__set_body(const peer_nodes_broadcast_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_nodes_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t peer_nodes_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_nodes_broadcast_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_nodes_broadcast_req &a, peer_nodes_broadcast_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    peer_nodes_broadcast_req::peer_nodes_broadcast_req(const peer_nodes_broadcast_req& other36) {
        body = other36.body;
        __isset = other36.__isset;
    }
    peer_nodes_broadcast_req& peer_nodes_broadcast_req::operator=(const peer_nodes_broadcast_req& other37) {
        body = other37.body;
        __isset = other37.__isset;
        return *this;
    }
    void peer_nodes_broadcast_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_nodes_broadcast_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_task_req_data::~node_create_task_req_data() throw() {
    }


    void node_create_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_create_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_create_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_create_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_create_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size38;
                            ::apache::thrift::protocol::TType _etype41;
                            xfer += iprot->readListBegin(_etype41, _size38);
                            this->peer_nodes_list.resize(_size38);
                            uint32_t _i42;
                            for (_i42 = 0; _i42 < _size38; ++_i42)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i42]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->additional);
                            isset_additional = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                xfer += iprot->readString(this->wallet);
                                isset_wallet = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                    xfer += iprot->readString(this->session_id);
                                    isset_session_id = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->session_id_sign);
                                        isset_session_id_sign = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    default:
                                        xfer += iprot->skip(ftype);
                                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter43;
            for (_iter43 = this->peer_nodes_list.begin(); _iter43 != this->peer_nodes_list.end(); ++_iter43)
            {
                xfer += oprot->writeString((*_iter43));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req_data &a, node_create_task_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_create_task_req_data::node_create_task_req_data(const node_create_task_req_data& other44) {
        peer_nodes_list = other44.peer_nodes_list;
        additional = other44.additional;
        wallet = other44.wallet;
        session_id = other44.session_id;
        session_id_sign = other44.session_id_sign;
    }
    node_create_task_req_data& node_create_task_req_data::operator=(const node_create_task_req_data& other45) {
        peer_nodes_list = other45.peer_nodes_list;
        additional = other45.additional;
        wallet = other45.wallet;
        session_id = other45.session_id;
        session_id_sign = other45.session_id_sign;
        return *this;
    }
    void node_create_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_create_task_req_body::~node_create_task_req_body() throw() {
    }


    void node_create_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req_body &a, node_create_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_task_req_body::node_create_task_req_body(const node_create_task_req_body& other46) {
        data = other46.data;
    }
    node_create_task_req_body& node_create_task_req_body::operator=(const node_create_task_req_body& other47) {
        data = other47.data;
        return *this;
    }
    void node_create_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_task_req::~node_create_task_req() throw() {
    }


    void node_create_task_req::__set_body(const node_create_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req &a, node_create_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_task_req::node_create_task_req(const node_create_task_req& other48) {
        body = other48.body;
        __isset = other48.__isset;
    }
    node_create_task_req& node_create_task_req::operator=(const node_create_task_req& other49) {
        body = other49.body;
        __isset = other49.__isset;
        return *this;
    }
    void node_create_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_task_rsp_data::~node_create_task_rsp_data() throw() {
    }


    void node_create_task_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_create_task_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_rsp_data &a, node_create_task_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_create_task_rsp_data::node_create_task_rsp_data(const node_create_task_rsp_data& other50) {
        result = other50.result;
        result_msg = other50.result_msg;
    }
    node_create_task_rsp_data& node_create_task_rsp_data::operator=(const node_create_task_rsp_data& other51) {
        result = other51.result;
        result_msg = other51.result_msg;
        return *this;
    }
    void node_create_task_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_create_task_rsp_body::~node_create_task_rsp_body() throw() {
    }


    void node_create_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_rsp_body &a, node_create_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_task_rsp_body::node_create_task_rsp_body(const node_create_task_rsp_body& other52) {
        data = other52.data;
    }
    node_create_task_rsp_body& node_create_task_rsp_body::operator=(const node_create_task_rsp_body& other53) {
        data = other53.data;
        return *this;
    }
    void node_create_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_task_rsp::~node_create_task_rsp() throw() {
    }


    void node_create_task_rsp::__set_body(const node_create_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_rsp &a, node_create_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_task_rsp::node_create_task_rsp(const node_create_task_rsp& other54) {
        body = other54.body;
        __isset = other54.__isset;
    }
    node_create_task_rsp& node_create_task_rsp::operator=(const node_create_task_rsp& other55) {
        body = other55.body;
        __isset = other55.__isset;
        return *this;
    }
    void node_create_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_start_task_req_data::~node_start_task_req_data() throw() {
    }


    void node_start_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_start_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_start_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_start_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_start_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_start_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size56;
                                ::apache::thrift::protocol::TType _etype59;
                                xfer += iprot->readListBegin(_etype59, _size56);
                                this->peer_nodes_list.resize(_size56);
                                uint32_t _i60;
                                for (_i60 = 0; _i60 < _size56; ++_i60)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i60]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                xfer += iprot->readString(this->additional);
                                isset_additional = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                    xfer += iprot->readString(this->wallet);
                                    isset_wallet = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->session_id);
                                        isset_session_id = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    case 6:
                                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                                            xfer += iprot->readString(this->session_id_sign);
                                            isset_session_id_sign = true;
                                        } else {
                                            xfer += iprot->skip(ftype);
                                        }
                                        break;
                                        default:
                                            xfer += iprot->skip(ftype);
                                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter61;
            for (_iter61 = this->peer_nodes_list.begin(); _iter61 != this->peer_nodes_list.end(); ++_iter61)
            {
                xfer += oprot->writeString((*_iter61));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req_data &a, node_start_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_start_task_req_data::node_start_task_req_data(const node_start_task_req_data& other62) {
        task_id = other62.task_id;
        peer_nodes_list = other62.peer_nodes_list;
        additional = other62.additional;
        wallet = other62.wallet;
        session_id = other62.session_id;
        session_id_sign = other62.session_id_sign;
    }
    node_start_task_req_data& node_start_task_req_data::operator=(const node_start_task_req_data& other63) {
        task_id = other63.task_id;
        peer_nodes_list = other63.peer_nodes_list;
        additional = other63.additional;
        wallet = other63.wallet;
        session_id = other63.session_id;
        session_id_sign = other63.session_id_sign;
        return *this;
    }
    void node_start_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_start_task_req_body::~node_start_task_req_body() throw() {
    }


    void node_start_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req_body &a, node_start_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_start_task_req_body::node_start_task_req_body(const node_start_task_req_body& other64) {
        data = other64.data;
    }
    node_start_task_req_body& node_start_task_req_body::operator=(const node_start_task_req_body& other65) {
        data = other65.data;
        return *this;
    }
    void node_start_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_start_task_req::~node_start_task_req() throw() {
    }


    void node_start_task_req::__set_body(const node_start_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_start_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req &a, node_start_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_start_task_req::node_start_task_req(const node_start_task_req& other66) {
        body = other66.body;
        __isset = other66.__isset;
    }
    node_start_task_req& node_start_task_req::operator=(const node_start_task_req& other67) {
        body = other67.body;
        __isset = other67.__isset;
        return *this;
    }
    void node_start_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_start_task_rsp_data::~node_start_task_rsp_data() throw() {
    }


    void node_start_task_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_start_task_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_rsp_data &a, node_start_task_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_start_task_rsp_data::node_start_task_rsp_data(const node_start_task_rsp_data& other68) {
        result = other68.result;
        result_msg = other68.result_msg;
    }
    node_start_task_rsp_data& node_start_task_rsp_data::operator=(const node_start_task_rsp_data& other69) {
        result = other69.result;
        result_msg = other69.result_msg;
        return *this;
    }
    void node_start_task_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_start_task_rsp_body::~node_start_task_rsp_body() throw() {
    }


    void node_start_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_rsp_body &a, node_start_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_start_task_rsp_body::node_start_task_rsp_body(const node_start_task_rsp_body& other70) {
        data = other70.data;
    }
    node_start_task_rsp_body& node_start_task_rsp_body::operator=(const node_start_task_rsp_body& other71) {
        data = other71.data;
        return *this;
    }
    void node_start_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_start_task_rsp::~node_start_task_rsp() throw() {
    }


    void node_start_task_rsp::__set_body(const node_start_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_start_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_rsp &a, node_start_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_start_task_rsp::node_start_task_rsp(const node_start_task_rsp& other72) {
        body = other72.body;
        __isset = other72.__isset;
    }
    node_start_task_rsp& node_start_task_rsp::operator=(const node_start_task_rsp& other73) {
        body = other73.body;
        __isset = other73.__isset;
        return *this;
    }
    void node_start_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_task_req_data::~node_stop_task_req_data() throw() {
    }


    void node_stop_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_stop_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_stop_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_stop_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_stop_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_stop_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size74;
                                ::apache::thrift::protocol::TType _etype77;
                                xfer += iprot->readListBegin(_etype77, _size74);
                                this->peer_nodes_list.resize(_size74);
                                uint32_t _i78;
                                for (_i78 = 0; _i78 < _size74; ++_i78)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i78]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                xfer += iprot->readString(this->additional);
                                isset_additional = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                    xfer += iprot->readString(this->wallet);
                                    isset_wallet = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->session_id);
                                        isset_session_id = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    case 6:
                                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                                            xfer += iprot->readString(this->session_id_sign);
                                            isset_session_id_sign = true;
                                        } else {
                                            xfer += iprot->skip(ftype);
                                        }
                                        break;
                                        default:
                                            xfer += iprot->skip(ftype);
                                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter79;
            for (_iter79 = this->peer_nodes_list.begin(); _iter79 != this->peer_nodes_list.end(); ++_iter79)
            {
                xfer += oprot->writeString((*_iter79));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req_data &a, node_stop_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_stop_task_req_data::node_stop_task_req_data(const node_stop_task_req_data& other80) {
        task_id = other80.task_id;
        peer_nodes_list = other80.peer_nodes_list;
        additional = other80.additional;
        wallet = other80.wallet;
        session_id = other80.session_id;
        session_id_sign = other80.session_id_sign;
    }
    node_stop_task_req_data& node_stop_task_req_data::operator=(const node_stop_task_req_data& other81) {
        task_id = other81.task_id;
        peer_nodes_list = other81.peer_nodes_list;
        additional = other81.additional;
        wallet = other81.wallet;
        session_id = other81.session_id;
        session_id_sign = other81.session_id_sign;
        return *this;
    }
    void node_stop_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_stop_task_req_body::~node_stop_task_req_body() throw() {
    }


    void node_stop_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req_body &a, node_stop_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_task_req_body::node_stop_task_req_body(const node_stop_task_req_body& other82) {
        data = other82.data;
    }
    node_stop_task_req_body& node_stop_task_req_body::operator=(const node_stop_task_req_body& other83) {
        data = other83.data;
        return *this;
    }
    void node_stop_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_task_req::~node_stop_task_req() throw() {
    }


    void node_stop_task_req::__set_body(const node_stop_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req &a, node_stop_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_task_req::node_stop_task_req(const node_stop_task_req& other84) {
        body = other84.body;
        __isset = other84.__isset;
    }
    node_stop_task_req& node_stop_task_req::operator=(const node_stop_task_req& other85) {
        body = other85.body;
        __isset = other85.__isset;
        return *this;
    }
    void node_stop_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_task_rsp_data::~node_stop_task_rsp_data() throw() {
    }


    void node_stop_task_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_stop_task_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_rsp_data &a, node_stop_task_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_stop_task_rsp_data::node_stop_task_rsp_data(const node_stop_task_rsp_data& other86) {
        result = other86.result;
        result_msg = other86.result_msg;
    }
    node_stop_task_rsp_data& node_stop_task_rsp_data::operator=(const node_stop_task_rsp_data& other87) {
        result = other87.result;
        result_msg = other87.result_msg;
        return *this;
    }
    void node_stop_task_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_stop_task_rsp_body::~node_stop_task_rsp_body() throw() {
    }


    void node_stop_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_rsp_body &a, node_stop_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_task_rsp_body::node_stop_task_rsp_body(const node_stop_task_rsp_body& other88) {
        data = other88.data;
    }
    node_stop_task_rsp_body& node_stop_task_rsp_body::operator=(const node_stop_task_rsp_body& other89) {
        data = other89.data;
        return *this;
    }
    void node_stop_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_task_rsp::~node_stop_task_rsp() throw() {
    }


    void node_stop_task_rsp::__set_body(const node_stop_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_rsp &a, node_stop_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_task_rsp::node_stop_task_rsp(const node_stop_task_rsp& other90) {
        body = other90.body;
        __isset = other90.__isset;
    }
    node_stop_task_rsp& node_stop_task_rsp::operator=(const node_stop_task_rsp& other91) {
        body = other91.body;
        __isset = other91.__isset;
        return *this;
    }
    void node_stop_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_restart_task_req_data::~node_restart_task_req_data() throw() {
    }


    void node_restart_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_restart_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_restart_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_restart_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_restart_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_restart_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size92;
                                ::apache::thrift::protocol::TType _etype95;
                                xfer += iprot->readListBegin(_etype95, _size92);
                                this->peer_nodes_list.resize(_size92);
                                uint32_t _i96;
                                for (_i96 = 0; _i96 < _size92; ++_i96)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i96]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                xfer += iprot->readString(this->additional);
                                isset_additional = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                    xfer += iprot->readString(this->wallet);
                                    isset_wallet = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->session_id);
                                        isset_session_id = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    case 6:
                                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                                            xfer += iprot->readString(this->session_id_sign);
                                            isset_session_id_sign = true;
                                        } else {
                                            xfer += iprot->skip(ftype);
                                        }
                                        break;
                                        default:
                                            xfer += iprot->skip(ftype);
                                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter97;
            for (_iter97 = this->peer_nodes_list.begin(); _iter97 != this->peer_nodes_list.end(); ++_iter97)
            {
                xfer += oprot->writeString((*_iter97));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req_data &a, node_restart_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_restart_task_req_data::node_restart_task_req_data(const node_restart_task_req_data& other98) {
        task_id = other98.task_id;
        peer_nodes_list = other98.peer_nodes_list;
        additional = other98.additional;
        wallet = other98.wallet;
        session_id = other98.session_id;
        session_id_sign = other98.session_id_sign;
    }
    node_restart_task_req_data& node_restart_task_req_data::operator=(const node_restart_task_req_data& other99) {
        task_id = other99.task_id;
        peer_nodes_list = other99.peer_nodes_list;
        additional = other99.additional;
        wallet = other99.wallet;
        session_id = other99.session_id;
        session_id_sign = other99.session_id_sign;
        return *this;
    }
    void node_restart_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_restart_task_req_body::~node_restart_task_req_body() throw() {
    }


    void node_restart_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req_body &a, node_restart_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_restart_task_req_body::node_restart_task_req_body(const node_restart_task_req_body& other100) {
        data = other100.data;
    }
    node_restart_task_req_body& node_restart_task_req_body::operator=(const node_restart_task_req_body& other101) {
        data = other101.data;
        return *this;
    }
    void node_restart_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_restart_task_req::~node_restart_task_req() throw() {
    }


    void node_restart_task_req::__set_body(const node_restart_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_restart_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req &a, node_restart_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_restart_task_req::node_restart_task_req(const node_restart_task_req& other102) {
        body = other102.body;
        __isset = other102.__isset;
    }
    node_restart_task_req& node_restart_task_req::operator=(const node_restart_task_req& other103) {
        body = other103.body;
        __isset = other103.__isset;
        return *this;
    }
    void node_restart_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_restart_task_rsp_data::~node_restart_task_rsp_data() throw() {
    }


    void node_restart_task_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_restart_task_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_rsp_data &a, node_restart_task_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_restart_task_rsp_data::node_restart_task_rsp_data(const node_restart_task_rsp_data& other104) {
        result = other104.result;
        result_msg = other104.result_msg;
    }
    node_restart_task_rsp_data& node_restart_task_rsp_data::operator=(const node_restart_task_rsp_data& other105) {
        result = other105.result;
        result_msg = other105.result_msg;
        return *this;
    }
    void node_restart_task_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_restart_task_rsp_body::~node_restart_task_rsp_body() throw() {
    }


    void node_restart_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_rsp_body &a, node_restart_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_restart_task_rsp_body::node_restart_task_rsp_body(const node_restart_task_rsp_body& other106) {
        data = other106.data;
    }
    node_restart_task_rsp_body& node_restart_task_rsp_body::operator=(const node_restart_task_rsp_body& other107) {
        data = other107.data;
        return *this;
    }
    void node_restart_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_restart_task_rsp::~node_restart_task_rsp() throw() {
    }


    void node_restart_task_rsp::__set_body(const node_restart_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_restart_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_rsp &a, node_restart_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_restart_task_rsp::node_restart_task_rsp(const node_restart_task_rsp& other108) {
        body = other108.body;
        __isset = other108.__isset;
    }
    node_restart_task_rsp& node_restart_task_rsp::operator=(const node_restart_task_rsp& other109) {
        body = other109.body;
        __isset = other109.__isset;
        return *this;
    }
    void node_restart_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_reset_task_req_data::~node_reset_task_req_data() throw() {
    }


    void node_reset_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_reset_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_reset_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_reset_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_reset_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_reset_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size110;
                                ::apache::thrift::protocol::TType _etype113;
                                xfer += iprot->readListBegin(_etype113, _size110);
                                this->peer_nodes_list.resize(_size110);
                                uint32_t _i114;
                                for (_i114 = 0; _i114 < _size110; ++_i114)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i114]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                xfer += iprot->readString(this->additional);
                                isset_additional = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                    xfer += iprot->readString(this->wallet);
                                    isset_wallet = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->session_id);
                                        isset_session_id = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    case 6:
                                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                                            xfer += iprot->readString(this->session_id_sign);
                                            isset_session_id_sign = true;
                                        } else {
                                            xfer += iprot->skip(ftype);
                                        }
                                        break;
                                        default:
                                            xfer += iprot->skip(ftype);
                                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter115;
            for (_iter115 = this->peer_nodes_list.begin(); _iter115 != this->peer_nodes_list.end(); ++_iter115)
            {
                xfer += oprot->writeString((*_iter115));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req_data &a, node_reset_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_reset_task_req_data::node_reset_task_req_data(const node_reset_task_req_data& other116) {
        task_id = other116.task_id;
        peer_nodes_list = other116.peer_nodes_list;
        additional = other116.additional;
        wallet = other116.wallet;
        session_id = other116.session_id;
        session_id_sign = other116.session_id_sign;
    }
    node_reset_task_req_data& node_reset_task_req_data::operator=(const node_reset_task_req_data& other117) {
        task_id = other117.task_id;
        peer_nodes_list = other117.peer_nodes_list;
        additional = other117.additional;
        wallet = other117.wallet;
        session_id = other117.session_id;
        session_id_sign = other117.session_id_sign;
        return *this;
    }
    void node_reset_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_reset_task_req_body::~node_reset_task_req_body() throw() {
    }


    void node_reset_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req_body &a, node_reset_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_reset_task_req_body::node_reset_task_req_body(const node_reset_task_req_body& other118) {
        data = other118.data;
    }
    node_reset_task_req_body& node_reset_task_req_body::operator=(const node_reset_task_req_body& other119) {
        data = other119.data;
        return *this;
    }
    void node_reset_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_reset_task_req::~node_reset_task_req() throw() {
    }


    void node_reset_task_req::__set_body(const node_reset_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_reset_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req &a, node_reset_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_reset_task_req::node_reset_task_req(const node_reset_task_req& other120) {
        body = other120.body;
        __isset = other120.__isset;
    }
    node_reset_task_req& node_reset_task_req::operator=(const node_reset_task_req& other121) {
        body = other121.body;
        __isset = other121.__isset;
        return *this;
    }
    void node_reset_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_reset_task_rsp_data::~node_reset_task_rsp_data() throw() {
    }


    void node_reset_task_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_reset_task_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_rsp_data &a, node_reset_task_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_reset_task_rsp_data::node_reset_task_rsp_data(const node_reset_task_rsp_data& other122) {
        result = other122.result;
        result_msg = other122.result_msg;
    }
    node_reset_task_rsp_data& node_reset_task_rsp_data::operator=(const node_reset_task_rsp_data& other123) {
        result = other123.result;
        result_msg = other123.result_msg;
        return *this;
    }
    void node_reset_task_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_reset_task_rsp_body::~node_reset_task_rsp_body() throw() {
    }


    void node_reset_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_rsp_body &a, node_reset_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_reset_task_rsp_body::node_reset_task_rsp_body(const node_reset_task_rsp_body& other124) {
        data = other124.data;
    }
    node_reset_task_rsp_body& node_reset_task_rsp_body::operator=(const node_reset_task_rsp_body& other125) {
        data = other125.data;
        return *this;
    }
    void node_reset_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_reset_task_rsp::~node_reset_task_rsp() throw() {
    }


    void node_reset_task_rsp::__set_body(const node_reset_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_reset_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_rsp &a, node_reset_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_reset_task_rsp::node_reset_task_rsp(const node_reset_task_rsp& other126) {
        body = other126.body;
        __isset = other126.__isset;
    }
    node_reset_task_rsp& node_reset_task_rsp::operator=(const node_reset_task_rsp& other127) {
        body = other127.body;
        __isset = other127.__isset;
        return *this;
    }
    void node_reset_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_task_req_data::~node_delete_task_req_data() throw() {
    }


    void node_delete_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_delete_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_delete_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_delete_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_delete_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_delete_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size128;
                                ::apache::thrift::protocol::TType _etype131;
                                xfer += iprot->readListBegin(_etype131, _size128);
                                this->peer_nodes_list.resize(_size128);
                                uint32_t _i132;
                                for (_i132 = 0; _i132 < _size128; ++_i132)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i132]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                xfer += iprot->readString(this->additional);
                                isset_additional = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                    xfer += iprot->readString(this->wallet);
                                    isset_wallet = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->session_id);
                                        isset_session_id = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    case 6:
                                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                                            xfer += iprot->readString(this->session_id_sign);
                                            isset_session_id_sign = true;
                                        } else {
                                            xfer += iprot->skip(ftype);
                                        }
                                        break;
                                        default:
                                            xfer += iprot->skip(ftype);
                                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter133;
            for (_iter133 = this->peer_nodes_list.begin(); _iter133 != this->peer_nodes_list.end(); ++_iter133)
            {
                xfer += oprot->writeString((*_iter133));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req_data &a, node_delete_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_delete_task_req_data::node_delete_task_req_data(const node_delete_task_req_data& other134) {
        task_id = other134.task_id;
        peer_nodes_list = other134.peer_nodes_list;
        additional = other134.additional;
        wallet = other134.wallet;
        session_id = other134.session_id;
        session_id_sign = other134.session_id_sign;
    }
    node_delete_task_req_data& node_delete_task_req_data::operator=(const node_delete_task_req_data& other135) {
        task_id = other135.task_id;
        peer_nodes_list = other135.peer_nodes_list;
        additional = other135.additional;
        wallet = other135.wallet;
        session_id = other135.session_id;
        session_id_sign = other135.session_id_sign;
        return *this;
    }
    void node_delete_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_delete_task_req_body::~node_delete_task_req_body() throw() {
    }


    void node_delete_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req_body &a, node_delete_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_task_req_body::node_delete_task_req_body(const node_delete_task_req_body& other136) {
        data = other136.data;
    }
    node_delete_task_req_body& node_delete_task_req_body::operator=(const node_delete_task_req_body& other137) {
        data = other137.data;
        return *this;
    }
    void node_delete_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_task_req::~node_delete_task_req() throw() {
    }


    void node_delete_task_req::__set_body(const node_delete_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req &a, node_delete_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_task_req::node_delete_task_req(const node_delete_task_req& other138) {
        body = other138.body;
        __isset = other138.__isset;
    }
    node_delete_task_req& node_delete_task_req::operator=(const node_delete_task_req& other139) {
        body = other139.body;
        __isset = other139.__isset;
        return *this;
    }
    void node_delete_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_task_rsp_data::~node_delete_task_rsp_data() throw() {
    }


    void node_delete_task_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_delete_task_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_rsp_data &a, node_delete_task_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_delete_task_rsp_data::node_delete_task_rsp_data(const node_delete_task_rsp_data& other140) {
        result = other140.result;
        result_msg = other140.result_msg;
    }
    node_delete_task_rsp_data& node_delete_task_rsp_data::operator=(const node_delete_task_rsp_data& other141) {
        result = other141.result;
        result_msg = other141.result_msg;
        return *this;
    }
    void node_delete_task_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_delete_task_rsp_body::~node_delete_task_rsp_body() throw() {
    }


    void node_delete_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_rsp_body &a, node_delete_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_task_rsp_body::node_delete_task_rsp_body(const node_delete_task_rsp_body& other142) {
        data = other142.data;
    }
    node_delete_task_rsp_body& node_delete_task_rsp_body::operator=(const node_delete_task_rsp_body& other143) {
        data = other143.data;
        return *this;
    }
    void node_delete_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_task_rsp::~node_delete_task_rsp() throw() {
    }


    void node_delete_task_rsp::__set_body(const node_delete_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_rsp &a, node_delete_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_task_rsp::node_delete_task_rsp(const node_delete_task_rsp& other144) {
        body = other144.body;
        __isset = other144.__isset;
    }
    node_delete_task_rsp& node_delete_task_rsp::operator=(const node_delete_task_rsp& other145) {
        body = other145.body;
        __isset = other145.__isset;
        return *this;
    }
    void node_delete_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_task_logs_req_data::~node_task_logs_req_data() throw() {
    }


    void node_task_logs_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_task_logs_req_data::__set_head_or_tail(const int16_t val) {
        this->head_or_tail = val;
    }

    void node_task_logs_req_data::__set_number_of_lines(const int32_t val) {
        this->number_of_lines = val;
    }

    void node_task_logs_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_task_logs_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_task_logs_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_task_logs_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_task_logs_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_head_or_tail = false;
        bool isset_number_of_lines = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I16) {
                            xfer += iprot->readI16(this->head_or_tail);
                            isset_head_or_tail = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_I32) {
                                xfer += iprot->readI32(this->number_of_lines);
                                isset_number_of_lines = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_LIST) {
                                    {
                                        this->peer_nodes_list.clear();
                                        uint32_t _size146;
                                        ::apache::thrift::protocol::TType _etype149;
                                        xfer += iprot->readListBegin(_etype149, _size146);
                                        this->peer_nodes_list.resize(_size146);
                                        uint32_t _i150;
                                        for (_i150 = 0; _i150 < _size146; ++_i150)
                                        {
                                            xfer += iprot->readString(this->peer_nodes_list[_i150]);
                                        }
                                        xfer += iprot->readListEnd();
                                    }
                                    isset_peer_nodes_list = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->additional);
                                        isset_additional = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    case 6:
                                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                                            xfer += iprot->readString(this->wallet);
                                            isset_wallet = true;
                                        } else {
                                            xfer += iprot->skip(ftype);
                                        }
                                        break;
                                        case 7:
                                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                                xfer += iprot->readString(this->session_id);
                                                isset_session_id = true;
                                            } else {
                                                xfer += iprot->skip(ftype);
                                            }
                                            break;
                                            case 8:
                                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                                    xfer += iprot->readString(this->session_id_sign);
                                                    isset_session_id_sign = true;
                                                } else {
                                                    xfer += iprot->skip(ftype);
                                                }
                                                break;
                                                default:
                                                    xfer += iprot->skip(ftype);
                                                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_head_or_tail)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_number_of_lines)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("head_or_tail", ::apache::thrift::protocol::T_I16, 2);
        xfer += oprot->writeI16(this->head_or_tail);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("number_of_lines", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->number_of_lines);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 4);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter151;
            for (_iter151 = this->peer_nodes_list.begin(); _iter151 != this->peer_nodes_list.end(); ++_iter151)
            {
                xfer += oprot->writeString((*_iter151));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 8);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req_data &a, node_task_logs_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.head_or_tail, b.head_or_tail);
        swap(a.number_of_lines, b.number_of_lines);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_task_logs_req_data::node_task_logs_req_data(const node_task_logs_req_data& other152) {
        task_id = other152.task_id;
        head_or_tail = other152.head_or_tail;
        number_of_lines = other152.number_of_lines;
        peer_nodes_list = other152.peer_nodes_list;
        additional = other152.additional;
        wallet = other152.wallet;
        session_id = other152.session_id;
        session_id_sign = other152.session_id_sign;
    }
    node_task_logs_req_data& node_task_logs_req_data::operator=(const node_task_logs_req_data& other153) {
        task_id = other153.task_id;
        head_or_tail = other153.head_or_tail;
        number_of_lines = other153.number_of_lines;
        peer_nodes_list = other153.peer_nodes_list;
        additional = other153.additional;
        wallet = other153.wallet;
        session_id = other153.session_id;
        session_id_sign = other153.session_id_sign;
        return *this;
    }
    void node_task_logs_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "head_or_tail=" << to_string(head_or_tail);
        out << ", " << "number_of_lines=" << to_string(number_of_lines);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_task_logs_req_body::~node_task_logs_req_body() throw() {
    }


    void node_task_logs_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req_body &a, node_task_logs_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_task_logs_req_body::node_task_logs_req_body(const node_task_logs_req_body& other154) {
        data = other154.data;
    }
    node_task_logs_req_body& node_task_logs_req_body::operator=(const node_task_logs_req_body& other155) {
        data = other155.data;
        return *this;
    }
    void node_task_logs_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_task_logs_req::~node_task_logs_req() throw() {
    }


    void node_task_logs_req::__set_body(const node_task_logs_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_task_logs_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req &a, node_task_logs_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_task_logs_req::node_task_logs_req(const node_task_logs_req& other156) {
        body = other156.body;
        __isset = other156.__isset;
    }
    node_task_logs_req& node_task_logs_req::operator=(const node_task_logs_req& other157) {
        body = other157.body;
        __isset = other157.__isset;
        return *this;
    }
    void node_task_logs_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_task_logs_rsp_data::~node_task_logs_rsp_data() throw() {
    }


    void node_task_logs_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_task_logs_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_rsp_data &a, node_task_logs_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_task_logs_rsp_data::node_task_logs_rsp_data(const node_task_logs_rsp_data& other158) {
        result = other158.result;
        result_msg = other158.result_msg;
    }
    node_task_logs_rsp_data& node_task_logs_rsp_data::operator=(const node_task_logs_rsp_data& other159) {
        result = other159.result;
        result_msg = other159.result_msg;
        return *this;
    }
    void node_task_logs_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_task_logs_rsp_body::~node_task_logs_rsp_body() throw() {
    }


    void node_task_logs_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_rsp_body &a, node_task_logs_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_task_logs_rsp_body::node_task_logs_rsp_body(const node_task_logs_rsp_body& other160) {
        data = other160.data;
    }
    node_task_logs_rsp_body& node_task_logs_rsp_body::operator=(const node_task_logs_rsp_body& other161) {
        data = other161.data;
        return *this;
    }
    void node_task_logs_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_task_logs_rsp::~node_task_logs_rsp() throw() {
    }


    void node_task_logs_rsp::__set_body(const node_task_logs_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_task_logs_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_rsp &a, node_task_logs_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_task_logs_rsp::node_task_logs_rsp(const node_task_logs_rsp& other162) {
        body = other162.body;
        __isset = other162.__isset;
    }
    node_task_logs_rsp& node_task_logs_rsp::operator=(const node_task_logs_rsp& other163) {
        body = other163.body;
        __isset = other163.__isset;
        return *this;
    }
    void node_task_logs_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_task_req_data::~node_list_task_req_data() throw() {
    }


    void node_list_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_list_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_list_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_list_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_list_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_list_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size164;
                                ::apache::thrift::protocol::TType _etype167;
                                xfer += iprot->readListBegin(_etype167, _size164);
                                this->peer_nodes_list.resize(_size164);
                                uint32_t _i168;
                                for (_i168 = 0; _i168 < _size164; ++_i168)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i168]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                xfer += iprot->readString(this->additional);
                                isset_additional = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                    xfer += iprot->readString(this->wallet);
                                    isset_wallet = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->session_id);
                                        isset_session_id = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    case 6:
                                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                                            xfer += iprot->readString(this->session_id_sign);
                                            isset_session_id_sign = true;
                                        } else {
                                            xfer += iprot->skip(ftype);
                                        }
                                        break;
                                        default:
                                            xfer += iprot->skip(ftype);
                                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter169;
            for (_iter169 = this->peer_nodes_list.begin(); _iter169 != this->peer_nodes_list.end(); ++_iter169)
            {
                xfer += oprot->writeString((*_iter169));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req_data &a, node_list_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_list_task_req_data::node_list_task_req_data(const node_list_task_req_data& other170) {
        task_id = other170.task_id;
        peer_nodes_list = other170.peer_nodes_list;
        additional = other170.additional;
        wallet = other170.wallet;
        session_id = other170.session_id;
        session_id_sign = other170.session_id_sign;
    }
    node_list_task_req_data& node_list_task_req_data::operator=(const node_list_task_req_data& other171) {
        task_id = other171.task_id;
        peer_nodes_list = other171.peer_nodes_list;
        additional = other171.additional;
        wallet = other171.wallet;
        session_id = other171.session_id;
        session_id_sign = other171.session_id_sign;
        return *this;
    }
    void node_list_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_list_task_req_body::~node_list_task_req_body() throw() {
    }


    void node_list_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req_body &a, node_list_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_task_req_body::node_list_task_req_body(const node_list_task_req_body& other172) {
        data = other172.data;
    }
    node_list_task_req_body& node_list_task_req_body::operator=(const node_list_task_req_body& other173) {
        data = other173.data;
        return *this;
    }
    void node_list_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_task_req::~node_list_task_req() throw() {
    }


    void node_list_task_req::__set_body(const node_list_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req &a, node_list_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_task_req::node_list_task_req(const node_list_task_req& other174) {
        body = other174.body;
        __isset = other174.__isset;
    }
    node_list_task_req& node_list_task_req::operator=(const node_list_task_req& other175) {
        body = other175.body;
        __isset = other175.__isset;
        return *this;
    }
    void node_list_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_task_rsp_data::~node_list_task_rsp_data() throw() {
    }


    void node_list_task_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_list_task_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_rsp_data &a, node_list_task_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_list_task_rsp_data::node_list_task_rsp_data(const node_list_task_rsp_data& other176) {
        result = other176.result;
        result_msg = other176.result_msg;
    }
    node_list_task_rsp_data& node_list_task_rsp_data::operator=(const node_list_task_rsp_data& other177) {
        result = other177.result;
        result_msg = other177.result_msg;
        return *this;
    }
    void node_list_task_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_list_task_rsp_body::~node_list_task_rsp_body() throw() {
    }


    void node_list_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_rsp_body &a, node_list_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_task_rsp_body::node_list_task_rsp_body(const node_list_task_rsp_body& other178) {
        data = other178.data;
    }
    node_list_task_rsp_body& node_list_task_rsp_body::operator=(const node_list_task_rsp_body& other179) {
        data = other179.data;
        return *this;
    }
    void node_list_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_task_rsp::~node_list_task_rsp() throw() {
    }


    void node_list_task_rsp::__set_body(const node_list_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_rsp &a, node_list_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_task_rsp::node_list_task_rsp(const node_list_task_rsp& other180) {
        body = other180.body;
        __isset = other180.__isset;
    }
    node_list_task_rsp& node_list_task_rsp::operator=(const node_list_task_rsp& other181) {
        body = other181.body;
        __isset = other181.__isset;
        return *this;
    }
    void node_list_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_modify_task_req_data::~node_modify_task_req_data() throw() {
    }


    void node_modify_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_modify_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_modify_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_modify_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_modify_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_modify_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size182;
                                ::apache::thrift::protocol::TType _etype185;
                                xfer += iprot->readListBegin(_etype185, _size182);
                                this->peer_nodes_list.resize(_size182);
                                uint32_t _i186;
                                for (_i186 = 0; _i186 < _size182; ++_i186)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i186]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                xfer += iprot->readString(this->additional);
                                isset_additional = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                    xfer += iprot->readString(this->wallet);
                                    isset_wallet = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->session_id);
                                        isset_session_id = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    case 6:
                                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                                            xfer += iprot->readString(this->session_id_sign);
                                            isset_session_id_sign = true;
                                        } else {
                                            xfer += iprot->skip(ftype);
                                        }
                                        break;
                                        default:
                                            xfer += iprot->skip(ftype);
                                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter187;
            for (_iter187 = this->peer_nodes_list.begin(); _iter187 != this->peer_nodes_list.end(); ++_iter187)
            {
                xfer += oprot->writeString((*_iter187));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req_data &a, node_modify_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_modify_task_req_data::node_modify_task_req_data(const node_modify_task_req_data& other188) {
        task_id = other188.task_id;
        peer_nodes_list = other188.peer_nodes_list;
        additional = other188.additional;
        wallet = other188.wallet;
        session_id = other188.session_id;
        session_id_sign = other188.session_id_sign;
    }
    node_modify_task_req_data& node_modify_task_req_data::operator=(const node_modify_task_req_data& other189) {
        task_id = other189.task_id;
        peer_nodes_list = other189.peer_nodes_list;
        additional = other189.additional;
        wallet = other189.wallet;
        session_id = other189.session_id;
        session_id_sign = other189.session_id_sign;
        return *this;
    }
    void node_modify_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_modify_task_req_body::~node_modify_task_req_body() throw() {
    }


    void node_modify_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req_body &a, node_modify_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_modify_task_req_body::node_modify_task_req_body(const node_modify_task_req_body& other190) {
        data = other190.data;
    }
    node_modify_task_req_body& node_modify_task_req_body::operator=(const node_modify_task_req_body& other191) {
        data = other191.data;
        return *this;
    }
    void node_modify_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_modify_task_req::~node_modify_task_req() throw() {
    }


    void node_modify_task_req::__set_body(const node_modify_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_modify_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req &a, node_modify_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_modify_task_req::node_modify_task_req(const node_modify_task_req& other192) {
        body = other192.body;
        __isset = other192.__isset;
    }
    node_modify_task_req& node_modify_task_req::operator=(const node_modify_task_req& other193) {
        body = other193.body;
        __isset = other193.__isset;
        return *this;
    }
    void node_modify_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_modify_task_rsp_data::~node_modify_task_rsp_data() throw() {
    }


    void node_modify_task_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_modify_task_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_rsp_data &a, node_modify_task_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_modify_task_rsp_data::node_modify_task_rsp_data(const node_modify_task_rsp_data& other194) {
        result = other194.result;
        result_msg = other194.result_msg;
    }
    node_modify_task_rsp_data& node_modify_task_rsp_data::operator=(const node_modify_task_rsp_data& other195) {
        result = other195.result;
        result_msg = other195.result_msg;
        return *this;
    }
    void node_modify_task_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_modify_task_rsp_body::~node_modify_task_rsp_body() throw() {
    }


    void node_modify_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_rsp_body &a, node_modify_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_modify_task_rsp_body::node_modify_task_rsp_body(const node_modify_task_rsp_body& other196) {
        data = other196.data;
    }
    node_modify_task_rsp_body& node_modify_task_rsp_body::operator=(const node_modify_task_rsp_body& other197) {
        data = other197.data;
        return *this;
    }
    void node_modify_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_modify_task_rsp::~node_modify_task_rsp() throw() {
    }


    void node_modify_task_rsp::__set_body(const node_modify_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_modify_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_rsp &a, node_modify_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_modify_task_rsp::node_modify_task_rsp(const node_modify_task_rsp& other198) {
        body = other198.body;
        __isset = other198.__isset;
    }
    node_modify_task_rsp& node_modify_task_rsp::operator=(const node_modify_task_rsp& other199) {
        body = other199.body;
        __isset = other199.__isset;
        return *this;
    }
    void node_modify_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_session_id_req_data::~node_session_id_req_data() throw() {
    }


    void node_session_id_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_session_id_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_session_id_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_session_id_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_session_id_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size200;
                            ::apache::thrift::protocol::TType _etype203;
                            xfer += iprot->readListBegin(_etype203, _size200);
                            this->peer_nodes_list.resize(_size200);
                            uint32_t _i204;
                            for (_i204 = 0; _i204 < _size200; ++_i204)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i204]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->additional);
                            isset_additional = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                xfer += iprot->readString(this->wallet);
                                isset_wallet = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                    xfer += iprot->readString(this->session_id);
                                    isset_session_id = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->session_id_sign);
                                        isset_session_id_sign = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    default:
                                        xfer += iprot->skip(ftype);
                                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter205;
            for (_iter205 = this->peer_nodes_list.begin(); _iter205 != this->peer_nodes_list.end(); ++_iter205)
            {
                xfer += oprot->writeString((*_iter205));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req_data &a, node_session_id_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_session_id_req_data::node_session_id_req_data(const node_session_id_req_data& other206) {
        peer_nodes_list = other206.peer_nodes_list;
        additional = other206.additional;
        wallet = other206.wallet;
        session_id = other206.session_id;
        session_id_sign = other206.session_id_sign;
    }
    node_session_id_req_data& node_session_id_req_data::operator=(const node_session_id_req_data& other207) {
        peer_nodes_list = other207.peer_nodes_list;
        additional = other207.additional;
        wallet = other207.wallet;
        session_id = other207.session_id;
        session_id_sign = other207.session_id_sign;
        return *this;
    }
    void node_session_id_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_session_id_req_body::~node_session_id_req_body() throw() {
    }


    void node_session_id_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req_body &a, node_session_id_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_session_id_req_body::node_session_id_req_body(const node_session_id_req_body& other208) {
        data = other208.data;
    }
    node_session_id_req_body& node_session_id_req_body::operator=(const node_session_id_req_body& other209) {
        data = other209.data;
        return *this;
    }
    void node_session_id_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_session_id_req::~node_session_id_req() throw() {
    }


    void node_session_id_req::__set_body(const node_session_id_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_session_id_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req &a, node_session_id_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_session_id_req::node_session_id_req(const node_session_id_req& other210) {
        body = other210.body;
        __isset = other210.__isset;
    }
    node_session_id_req& node_session_id_req::operator=(const node_session_id_req& other211) {
        body = other211.body;
        __isset = other211.__isset;
        return *this;
    }
    void node_session_id_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_session_id_rsp_data::~node_session_id_rsp_data() throw() {
    }


    void node_session_id_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_session_id_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_rsp_data &a, node_session_id_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_session_id_rsp_data::node_session_id_rsp_data(const node_session_id_rsp_data& other212) {
        result = other212.result;
        result_msg = other212.result_msg;
    }
    node_session_id_rsp_data& node_session_id_rsp_data::operator=(const node_session_id_rsp_data& other213) {
        result = other213.result;
        result_msg = other213.result_msg;
        return *this;
    }
    void node_session_id_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_session_id_rsp_body::~node_session_id_rsp_body() throw() {
    }


    void node_session_id_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_rsp_body &a, node_session_id_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_session_id_rsp_body::node_session_id_rsp_body(const node_session_id_rsp_body& other214) {
        data = other214.data;
    }
    node_session_id_rsp_body& node_session_id_rsp_body::operator=(const node_session_id_rsp_body& other215) {
        data = other215.data;
        return *this;
    }
    void node_session_id_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_session_id_rsp::~node_session_id_rsp() throw() {
    }


    void node_session_id_rsp::__set_body(const node_session_id_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_session_id_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_rsp &a, node_session_id_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_session_id_rsp::node_session_id_rsp(const node_session_id_rsp& other216) {
        body = other216.body;
        __isset = other216.__isset;
    }
    node_session_id_rsp& node_session_id_rsp::operator=(const node_session_id_rsp& other217) {
        body = other217.body;
        __isset = other217.__isset;
        return *this;
    }
    void node_session_id_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_query_node_info_req_data::~node_query_node_info_req_data() throw() {
    }


    void node_query_node_info_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_query_node_info_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_query_node_info_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_query_node_info_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_query_node_info_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size218;
                            ::apache::thrift::protocol::TType _etype221;
                            xfer += iprot->readListBegin(_etype221, _size218);
                            this->peer_nodes_list.resize(_size218);
                            uint32_t _i222;
                            for (_i222 = 0; _i222 < _size218; ++_i222)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i222]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->additional);
                            isset_additional = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_STRING) {
                                xfer += iprot->readString(this->wallet);
                                isset_wallet = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_STRING) {
                                    xfer += iprot->readString(this->session_id);
                                    isset_session_id = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                                        xfer += iprot->readString(this->session_id_sign);
                                        isset_session_id_sign = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    default:
                                        xfer += iprot->skip(ftype);
                                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter223;
            for (_iter223 = this->peer_nodes_list.begin(); _iter223 != this->peer_nodes_list.end(); ++_iter223)
            {
                xfer += oprot->writeString((*_iter223));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req_data &a, node_query_node_info_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_query_node_info_req_data::node_query_node_info_req_data(const node_query_node_info_req_data& other224) {
        peer_nodes_list = other224.peer_nodes_list;
        additional = other224.additional;
        wallet = other224.wallet;
        session_id = other224.session_id;
        session_id_sign = other224.session_id_sign;
    }
    node_query_node_info_req_data& node_query_node_info_req_data::operator=(const node_query_node_info_req_data& other225) {
        peer_nodes_list = other225.peer_nodes_list;
        additional = other225.additional;
        wallet = other225.wallet;
        session_id = other225.session_id;
        session_id_sign = other225.session_id_sign;
        return *this;
    }
    void node_query_node_info_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_query_node_info_req_body::~node_query_node_info_req_body() throw() {
    }


    void node_query_node_info_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req_body &a, node_query_node_info_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_query_node_info_req_body::node_query_node_info_req_body(const node_query_node_info_req_body& other226) {
        data = other226.data;
    }
    node_query_node_info_req_body& node_query_node_info_req_body::operator=(const node_query_node_info_req_body& other227) {
        data = other227.data;
        return *this;
    }
    void node_query_node_info_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_query_node_info_req::~node_query_node_info_req() throw() {
    }


    void node_query_node_info_req::__set_body(const node_query_node_info_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_query_node_info_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req &a, node_query_node_info_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_query_node_info_req::node_query_node_info_req(const node_query_node_info_req& other228) {
        body = other228.body;
        __isset = other228.__isset;
    }
    node_query_node_info_req& node_query_node_info_req::operator=(const node_query_node_info_req& other229) {
        body = other229.body;
        __isset = other229.__isset;
        return *this;
    }
    void node_query_node_info_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_query_node_info_rsp_data::~node_query_node_info_rsp_data() throw() {
    }


    void node_query_node_info_rsp_data::__set_result(const int32_t val) {
        this->result = val;
    }

    void node_query_node_info_rsp_data::__set_result_msg(const std::string& val) {
        this->result_msg = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_rsp_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_result = false;
        bool isset_result_msg = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->result);
                        isset_result = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->result_msg);
                            isset_result_msg = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        default:
                            xfer += iprot->skip(ftype);
                            break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_result)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_result_msg)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_rsp_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_rsp_data");

        xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 1);
        xfer += oprot->writeI32(this->result);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("result_msg", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->result_msg);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_rsp_data &a, node_query_node_info_rsp_data &b) {
        using ::std::swap;
        swap(a.result, b.result);
        swap(a.result_msg, b.result_msg);
    }

    node_query_node_info_rsp_data::node_query_node_info_rsp_data(const node_query_node_info_rsp_data& other230) {
        result = other230.result;
        result_msg = other230.result_msg;
    }
    node_query_node_info_rsp_data& node_query_node_info_rsp_data::operator=(const node_query_node_info_rsp_data& other231) {
        result = other231.result;
        result_msg = other231.result_msg;
        return *this;
    }
    void node_query_node_info_rsp_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_rsp_data(";
        out << "result=" << to_string(result);
        out << ", " << "result_msg=" << to_string(result_msg);
        out << ")";
    }


    node_query_node_info_rsp_body::~node_query_node_info_rsp_body() throw() {
    }


    void node_query_node_info_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_rsp_body &a, node_query_node_info_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_query_node_info_rsp_body::node_query_node_info_rsp_body(const node_query_node_info_rsp_body& other232) {
        data = other232.data;
    }
    node_query_node_info_rsp_body& node_query_node_info_rsp_body::operator=(const node_query_node_info_rsp_body& other233) {
        data = other233.data;
        return *this;
    }
    void node_query_node_info_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_query_node_info_rsp::~node_query_node_info_rsp() throw() {
    }


    void node_query_node_info_rsp::__set_body(const node_query_node_info_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_query_node_info_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_rsp &a, node_query_node_info_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_query_node_info_rsp::node_query_node_info_rsp(const node_query_node_info_rsp& other234) {
        body = other234.body;
        __isset = other234.__isset;
    }
    node_query_node_info_rsp& node_query_node_info_rsp::operator=(const node_query_node_info_rsp& other235) {
        body = other235.body;
        __isset = other235.__isset;
        return *this;
    }
    void node_query_node_info_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_service_info::~node_service_info() throw() {
    }


    void node_service_info::__set_service_list(const std::vector<std::string> & val) {
        this->service_list = val;
    }

    void node_service_info::__set_name(const std::string& val) {
        this->name = val;
        __isset.name = true;
    }

    void node_service_info::__set_time_stamp(const int64_t val) {
        this->time_stamp = val;
        __isset.time_stamp = true;
    }

    void node_service_info::__set_kvs(const std::map<std::string, std::string> & val) {
        this->kvs = val;
        __isset.kvs = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_service_info& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_service_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->service_list.clear();
                            uint32_t _size236;
                            ::apache::thrift::protocol::TType _etype239;
                            xfer += iprot->readListBegin(_etype239, _size236);
                            this->service_list.resize(_size236);
                            uint32_t _i240;
                            for (_i240 = 0; _i240 < _size236; ++_i240)
                            {
                                xfer += iprot->readString(this->service_list[_i240]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_service_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->name);
                            this->__isset.name = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_I64) {
                                xfer += iprot->readI64(this->time_stamp);
                                this->__isset.time_stamp = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_MAP) {
                                    {
                                        this->kvs.clear();
                                        uint32_t _size241;
                                        ::apache::thrift::protocol::TType _ktype242;
                                        ::apache::thrift::protocol::TType _vtype243;
                                        xfer += iprot->readMapBegin(_ktype242, _vtype243, _size241);
                                        uint32_t _i245;
                                        for (_i245 = 0; _i245 < _size241; ++_i245)
                                        {
                                            std::string _key246;
                                            xfer += iprot->readString(_key246);
                                            std::string& _val247 = this->kvs[_key246];
                                            xfer += iprot->readString(_val247);
                                        }
                                        xfer += iprot->readMapEnd();
                                    }
                                    this->__isset.kvs = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                default:
                                    xfer += iprot->skip(ftype);
                                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_service_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_service_info");

        xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
            std::vector<std::string> ::const_iterator _iter248;
            for (_iter248 = this->service_list.begin(); _iter248 != this->service_list.end(); ++_iter248)
            {
                xfer += oprot->writeString((*_iter248));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        if (this->__isset.name) {
            xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
            xfer += oprot->writeString(this->name);
            xfer += oprot->writeFieldEnd();
        }
        if (this->__isset.time_stamp) {
            xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 3);
            xfer += oprot->writeI64(this->time_stamp);
            xfer += oprot->writeFieldEnd();
        }
        if (this->__isset.kvs) {
            xfer += oprot->writeFieldBegin("kvs", ::apache::thrift::protocol::T_MAP, 4);
            {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kvs.size()));
                std::map<std::string, std::string> ::const_iterator _iter249;
                for (_iter249 = this->kvs.begin(); _iter249 != this->kvs.end(); ++_iter249)
                {
                    xfer += oprot->writeString(_iter249->first);
                    xfer += oprot->writeString(_iter249->second);
                }
                xfer += oprot->writeMapEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_service_info &a, node_service_info &b) {
        using ::std::swap;
        swap(a.service_list, b.service_list);
        swap(a.name, b.name);
        swap(a.time_stamp, b.time_stamp);
        swap(a.kvs, b.kvs);
        swap(a.__isset, b.__isset);
    }

    node_service_info::node_service_info(const node_service_info& other250) {
        service_list = other250.service_list;
        name = other250.name;
        time_stamp = other250.time_stamp;
        kvs = other250.kvs;
        __isset = other250.__isset;
    }
    node_service_info& node_service_info::operator=(const node_service_info& other251) {
        service_list = other251.service_list;
        name = other251.name;
        time_stamp = other251.time_stamp;
        kvs = other251.kvs;
        __isset = other251.__isset;
        return *this;
    }
    void node_service_info::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_service_info(";
        out << "service_list=" << to_string(service_list);
        out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
        out << ", " << "time_stamp="; (__isset.time_stamp ? (out << to_string(time_stamp)) : (out << "<null>"));
        out << ", " << "kvs="; (__isset.kvs ? (out << to_string(kvs)) : (out << "<null>"));
        out << ")";
    }


    service_broadcast_req_body::~service_broadcast_req_body() throw() {
    }


    void service_broadcast_req_body::__set_node_service_info_map(const std::map<std::string, node_service_info> & val) {
        this->node_service_info_map = val;
    }
    std::ostream& operator<<(std::ostream& out, const service_broadcast_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t service_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_service_info_map = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_MAP) {
                        {
                            this->node_service_info_map.clear();
                            uint32_t _size252;
                            ::apache::thrift::protocol::TType _ktype253;
                            ::apache::thrift::protocol::TType _vtype254;
                            xfer += iprot->readMapBegin(_ktype253, _vtype254, _size252);
                            uint32_t _i256;
                            for (_i256 = 0; _i256 < _size252; ++_i256)
                            {
                                std::string _key257;
                                xfer += iprot->readString(_key257);
                                node_service_info& _val258 = this->node_service_info_map[_key257];
                                xfer += _val258.read(iprot);
                            }
                            xfer += iprot->readMapEnd();
                        }
                        isset_node_service_info_map = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_service_info_map)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t service_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("service_broadcast_req_body");

        xfer += oprot->writeFieldBegin("node_service_info_map", ::apache::thrift::protocol::T_MAP, 1);
        {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_service_info_map.size()));
            std::map<std::string, node_service_info> ::const_iterator _iter259;
            for (_iter259 = this->node_service_info_map.begin(); _iter259 != this->node_service_info_map.end(); ++_iter259)
            {
                xfer += oprot->writeString(_iter259->first);
                xfer += _iter259->second.write(oprot);
            }
            xfer += oprot->writeMapEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(service_broadcast_req_body &a, service_broadcast_req_body &b) {
        using ::std::swap;
        swap(a.node_service_info_map, b.node_service_info_map);
    }

    service_broadcast_req_body::service_broadcast_req_body(const service_broadcast_req_body& other260) {
        node_service_info_map = other260.node_service_info_map;
    }
    service_broadcast_req_body& service_broadcast_req_body::operator=(const service_broadcast_req_body& other261) {
        node_service_info_map = other261.node_service_info_map;
        return *this;
    }
    void service_broadcast_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "service_broadcast_req_body(";
        out << "node_service_info_map=" << to_string(node_service_info_map);
        out << ")";
    }


    service_broadcast_req::~service_broadcast_req() throw() {
    }


    void service_broadcast_req::__set_body(const service_broadcast_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const service_broadcast_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t service_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t service_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("service_broadcast_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(service_broadcast_req &a, service_broadcast_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    service_broadcast_req::service_broadcast_req(const service_broadcast_req& other262) {
        body = other262.body;
        __isset = other262.__isset;
    }
    service_broadcast_req& service_broadcast_req::operator=(const service_broadcast_req& other263) {
        body = other263.body;
        __isset = other263.__isset;
        return *this;
    }
    void service_broadcast_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "service_broadcast_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    ver_req_body::~ver_req_body() throw() {
    }


    void ver_req_body::__set_node_id(const std::string& val) {
        this->node_id = val;
    }

    void ver_req_body::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void ver_req_body::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }

    void ver_req_body::__set_time_stamp(const int64_t val) {
        this->time_stamp = val;
    }

    void ver_req_body::__set_addr_me(const network_address& val) {
        this->addr_me = val;
    }

    void ver_req_body::__set_addr_you(const network_address& val) {
        this->addr_you = val;
    }

    void ver_req_body::__set_start_height(const int64_t val) {
        this->start_height = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;
        bool isset_time_stamp = false;
        bool isset_addr_me = false;
        bool isset_addr_you = false;
        bool isset_start_height = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->node_id);
                        isset_node_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->core_version);
                            isset_core_version = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_I32) {
                                xfer += iprot->readI32(this->protocol_version);
                                isset_protocol_version = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            case 4:
                                if (ftype == ::apache::thrift::protocol::T_I64) {
                                    xfer += iprot->readI64(this->time_stamp);
                                    isset_time_stamp = true;
                                } else {
                                    xfer += iprot->skip(ftype);
                                }
                                break;
                                case 5:
                                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                                        xfer += this->addr_me.read(iprot);
                                        isset_addr_me = true;
                                    } else {
                                        xfer += iprot->skip(ftype);
                                    }
                                    break;
                                    case 6:
                                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                                            xfer += this->addr_you.read(iprot);
                                            isset_addr_you = true;
                                        } else {
                                            xfer += iprot->skip(ftype);
                                        }
                                        break;
                                        case 7:
                                            if (ftype == ::apache::thrift::protocol::T_I64) {
                                                xfer += iprot->readI64(this->start_height);
                                                isset_start_height = true;
                                            } else {
                                                xfer += iprot->skip(ftype);
                                            }
                                            break;
                                            default:
                                                xfer += iprot->skip(ftype);
                                                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_time_stamp)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr_me)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr_you)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_start_height)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t ver_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_req_body");

        xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 4);
        xfer += oprot->writeI64(this->time_stamp);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr_me", ::apache::thrift::protocol::T_STRUCT, 5);
        xfer += this->addr_me.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr_you", ::apache::thrift::protocol::T_STRUCT, 6);
        xfer += this->addr_you.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("start_height", ::apache::thrift::protocol::T_I64, 7);
        xfer += oprot->writeI64(this->start_height);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_req_body &a, ver_req_body &b) {
        using ::std::swap;
        swap(a.node_id, b.node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
        swap(a.time_stamp, b.time_stamp);
        swap(a.addr_me, b.addr_me);
        swap(a.addr_you, b.addr_you);
        swap(a.start_height, b.start_height);
    }

    ver_req_body::ver_req_body(const ver_req_body& other264) {
        node_id = other264.node_id;
        core_version = other264.core_version;
        protocol_version = other264.protocol_version;
        time_stamp = other264.time_stamp;
        addr_me = other264.addr_me;
        addr_you = other264.addr_you;
        start_height = other264.start_height;
    }
    ver_req_body& ver_req_body::operator=(const ver_req_body& other265) {
        node_id = other265.node_id;
        core_version = other265.core_version;
        protocol_version = other265.protocol_version;
        time_stamp = other265.time_stamp;
        addr_me = other265.addr_me;
        addr_you = other265.addr_you;
        start_height = other265.start_height;
        return *this;
    }
    void ver_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_req_body(";
        out << "node_id=" << to_string(node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ", " << "time_stamp=" << to_string(time_stamp);
        out << ", " << "addr_me=" << to_string(addr_me);
        out << ", " << "addr_you=" << to_string(addr_you);
        out << ", " << "start_height=" << to_string(start_height);
        out << ")";
    }


    ver_req::~ver_req() throw() {
    }


    void ver_req::__set_body(const ver_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t ver_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_req &a, ver_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    ver_req::ver_req(const ver_req& other266) {
        body = other266.body;
        __isset = other266.__isset;
    }
    ver_req& ver_req::operator=(const ver_req& other267) {
        body = other267.body;
        __isset = other267.__isset;
        return *this;
    }
    void ver_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    ver_resp_body::~ver_resp_body() throw() {
    }


    void ver_resp_body::__set_node_id(const std::string& val) {
        this->node_id = val;
    }

    void ver_resp_body::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void ver_resp_body::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_resp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->node_id);
                        isset_node_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->core_version);
                            isset_core_version = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                        case 3:
                            if (ftype == ::apache::thrift::protocol::T_I32) {
                                xfer += iprot->readI32(this->protocol_version);
                                isset_protocol_version = true;
                            } else {
                                xfer += iprot->skip(ftype);
                            }
                            break;
                            default:
                                xfer += iprot->skip(ftype);
                                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t ver_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_resp_body");

        xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_resp_body &a, ver_resp_body &b) {
        using ::std::swap;
        swap(a.node_id, b.node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
    }

    ver_resp_body::ver_resp_body(const ver_resp_body& other268) {
        node_id = other268.node_id;
        core_version = other268.core_version;
        protocol_version = other268.protocol_version;
    }
    ver_resp_body& ver_resp_body::operator=(const ver_resp_body& other269) {
        node_id = other269.node_id;
        core_version = other269.core_version;
        protocol_version = other269.protocol_version;
        return *this;
    }
    void ver_resp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_resp_body(";
        out << "node_id=" << to_string(node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ")";
    }


    ver_resp::~ver_resp() throw() {
    }


    void ver_resp::__set_body(const ver_resp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t ver_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_resp &a, ver_resp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    ver_resp::ver_resp(const ver_resp& other270) {
        body = other270.body;
        __isset = other270.__isset;
    }
    ver_resp& ver_resp::operator=(const ver_resp& other271) {
        body = other271.body;
        __isset = other271.__isset;
        return *this;
    }
    void ver_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }

} // namespace
