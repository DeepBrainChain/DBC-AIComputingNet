/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "matrix_types.h"

#include <algorithm>
#include <ostream>

#include "TToString.h"

namespace matrix { namespace service_core {


        empty::~empty() throw() {
        }

        std::ostream& operator<<(std::ostream& out, const empty& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t empty::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                xfer += iprot->skip(ftype);
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t empty::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("empty");

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(empty &a, empty &b) {
            using ::std::swap;
            (void) a;
            (void) b;
        }

        empty::empty(const empty& other0) {
            (void) other0;
        }
        empty& empty::operator=(const empty& other1) {
            (void) other1;
            return *this;
        }
        void empty::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "empty(";
            out << ")";
        }


        network_address::~network_address() throw() {
        }


        void network_address::__set_ip(const std::string& val) {
            this->ip = val;
        }

        void network_address::__set_port(const int16_t val) {
            this->port = val;
        }
        std::ostream& operator<<(std::ostream& out, const network_address& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t network_address::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_ip = false;
            bool isset_port = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->ip);
                            isset_ip = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I16) {
                            xfer += iprot->readI16(this->port);
                            isset_port = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_ip)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_port)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t network_address::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("network_address");

            xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->ip);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 2);
            xfer += oprot->writeI16(this->port);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(network_address &a, network_address &b) {
            using ::std::swap;
            swap(a.ip, b.ip);
            swap(a.port, b.port);
        }

        network_address::network_address(const network_address& other2) {
            ip = other2.ip;
            port = other2.port;
        }
        network_address& network_address::operator=(const network_address& other3) {
            ip = other3.ip;
            port = other3.port;
            return *this;
        }
        void network_address::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "network_address(";
            out << "ip=" << to_string(ip);
            out << ", " << "port=" << to_string(port);
            out << ")";
        }


        task_status::~task_status() throw() {
        }


        void task_status::__set_task_id(const std::string& val) {
            this->task_id = val;
        }

        void task_status::__set_status(const int8_t val) {
            this->status = val;
        }

        void task_status::__set_pwd(const std::string& val) {
            this->pwd = val;
        }
        std::ostream& operator<<(std::ostream& out, const task_status& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t task_status::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_task_id = false;
            bool isset_status = false;
            bool isset_pwd = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->task_id);
                            isset_task_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_BYTE) {
                            xfer += iprot->readByte(this->status);
                            isset_status = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->pwd);
                            isset_pwd = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_task_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_status)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_pwd)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t task_status::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("task_status");

            xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->task_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BYTE, 2);
            xfer += oprot->writeByte(this->status);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("pwd", ::apache::thrift::protocol::T_STRING, 3);
            xfer += oprot->writeString(this->pwd);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(task_status &a, task_status &b) {
            using ::std::swap;
            swap(a.task_id, b.task_id);
            swap(a.status, b.status);
            swap(a.pwd, b.pwd);
        }

        task_status::task_status(const task_status& other4) {
            task_id = other4.task_id;
            status = other4.status;
            pwd = other4.pwd;
        }
        task_status& task_status::operator=(const task_status& other5) {
            task_id = other5.task_id;
            status = other5.status;
            pwd = other5.pwd;
            return *this;
        }
        void task_status::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "task_status(";
            out << "task_id=" << to_string(task_id);
            out << ", " << "status=" << to_string(status);
            out << ", " << "pwd=" << to_string(pwd);
            out << ")";
        }


        peer_node_info::~peer_node_info() throw() {
        }


        void peer_node_info::__set_peer_node_id(const std::string& val) {
            this->peer_node_id = val;
        }

        void peer_node_info::__set_core_version(const int32_t val) {
            this->core_version = val;
        }

        void peer_node_info::__set_protocol_version(const int32_t val) {
            this->protocol_version = val;
        }

        void peer_node_info::__set_live_time_stamp(const int32_t val) {
            this->live_time_stamp = val;
        }

        void peer_node_info::__set_addr(const network_address& val) {
            this->addr = val;
        }

        void peer_node_info::__set_service_list(const std::vector<std::string> & val) {
            this->service_list = val;
            __isset.service_list = true;
        }
        std::ostream& operator<<(std::ostream& out, const peer_node_info& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t peer_node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_peer_node_id = false;
            bool isset_core_version = false;
            bool isset_protocol_version = false;
            bool isset_live_time_stamp = false;
            bool isset_addr = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->peer_node_id);
                            isset_peer_node_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->core_version);
                            isset_core_version = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->protocol_version);
                            isset_protocol_version = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->live_time_stamp);
                            isset_live_time_stamp = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 5:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->addr.read(iprot);
                            isset_addr = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 6:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->service_list.clear();
                                uint32_t _size6;
                                ::apache::thrift::protocol::TType _etype9;
                                xfer += iprot->readListBegin(_etype9, _size6);
                                this->service_list.resize(_size6);
                                uint32_t _i10;
                                for (_i10 = 0; _i10 < _size6; ++_i10)
                                {
                                    xfer += iprot->readString(this->service_list[_i10]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            this->__isset.service_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_peer_node_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_core_version)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_protocol_version)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_live_time_stamp)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_addr)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t peer_node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("peer_node_info");

            xfer += oprot->writeFieldBegin("peer_node_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->peer_node_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32(this->core_version);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
            xfer += oprot->writeI32(this->protocol_version);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("live_time_stamp", ::apache::thrift::protocol::T_I32, 4);
            xfer += oprot->writeI32(this->live_time_stamp);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRUCT, 5);
            xfer += this->addr.write(oprot);
            xfer += oprot->writeFieldEnd();

            if (this->__isset.service_list) {
                xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 6);
                {
                    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
                    std::vector<std::string> ::const_iterator _iter11;
                    for (_iter11 = this->service_list.begin(); _iter11 != this->service_list.end(); ++_iter11)
                    {
                        xfer += oprot->writeString((*_iter11));
                    }
                    xfer += oprot->writeListEnd();
                }
                xfer += oprot->writeFieldEnd();
            }
            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(peer_node_info &a, peer_node_info &b) {
            using ::std::swap;
            swap(a.peer_node_id, b.peer_node_id);
            swap(a.core_version, b.core_version);
            swap(a.protocol_version, b.protocol_version);
            swap(a.live_time_stamp, b.live_time_stamp);
            swap(a.addr, b.addr);
            swap(a.service_list, b.service_list);
            swap(a.__isset, b.__isset);
        }

        peer_node_info::peer_node_info(const peer_node_info& other12) {
            peer_node_id = other12.peer_node_id;
            core_version = other12.core_version;
            protocol_version = other12.protocol_version;
            live_time_stamp = other12.live_time_stamp;
            addr = other12.addr;
            service_list = other12.service_list;
            __isset = other12.__isset;
        }
        peer_node_info& peer_node_info::operator=(const peer_node_info& other13) {
            peer_node_id = other13.peer_node_id;
            core_version = other13.core_version;
            protocol_version = other13.protocol_version;
            live_time_stamp = other13.live_time_stamp;
            addr = other13.addr;
            service_list = other13.service_list;
            __isset = other13.__isset;
            return *this;
        }
        void peer_node_info::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "peer_node_info(";
            out << "peer_node_id=" << to_string(peer_node_id);
            out << ", " << "core_version=" << to_string(core_version);
            out << ", " << "protocol_version=" << to_string(protocol_version);
            out << ", " << "live_time_stamp=" << to_string(live_time_stamp);
            out << ", " << "addr=" << to_string(addr);
            out << ", " << "service_list="; (__isset.service_list ? (out << to_string(service_list)) : (out << "<null>"));
            out << ")";
        }


        shake_hand_req::~shake_hand_req() throw() {
        }


        void shake_hand_req::__set_body(const empty& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const shake_hand_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t shake_hand_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t shake_hand_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("shake_hand_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(shake_hand_req &a, shake_hand_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        shake_hand_req::shake_hand_req(const shake_hand_req& other14) {
            body = other14.body;
            __isset = other14.__isset;
        }
        shake_hand_req& shake_hand_req::operator=(const shake_hand_req& other15) {
            body = other15.body;
            __isset = other15.__isset;
            return *this;
        }
        void shake_hand_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "shake_hand_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        shake_hand_resp::~shake_hand_resp() throw() {
        }


        void shake_hand_resp::__set_body(const empty& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const shake_hand_resp& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t shake_hand_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t shake_hand_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("shake_hand_resp");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(shake_hand_resp &a, shake_hand_resp &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        shake_hand_resp::shake_hand_resp(const shake_hand_resp& other16) {
            body = other16.body;
            __isset = other16.__isset;
        }
        shake_hand_resp& shake_hand_resp::operator=(const shake_hand_resp& other17) {
            body = other17.body;
            __isset = other17.__isset;
            return *this;
        }
        void shake_hand_resp::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "shake_hand_resp(";
            out << "body=" << to_string(body);
            out << ")";
        }


        get_peer_nodes_req::~get_peer_nodes_req() throw() {
        }


        void get_peer_nodes_req::__set_body(const empty& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const get_peer_nodes_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t get_peer_nodes_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t get_peer_nodes_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("get_peer_nodes_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(get_peer_nodes_req &a, get_peer_nodes_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        get_peer_nodes_req::get_peer_nodes_req(const get_peer_nodes_req& other18) {
            body = other18.body;
            __isset = other18.__isset;
        }
        get_peer_nodes_req& get_peer_nodes_req::operator=(const get_peer_nodes_req& other19) {
            body = other19.body;
            __isset = other19.__isset;
            return *this;
        }
        void get_peer_nodes_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "get_peer_nodes_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        get_peer_nodes_resp_body::~get_peer_nodes_resp_body() throw() {
        }


        void get_peer_nodes_resp_body::__set_peer_nodes_list(const std::vector<peer_node_info> & val) {
            this->peer_nodes_list = val;
        }
        std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t get_peer_nodes_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_peer_nodes_list = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size20;
                                ::apache::thrift::protocol::TType _etype23;
                                xfer += iprot->readListBegin(_etype23, _size20);
                                this->peer_nodes_list.resize(_size20);
                                uint32_t _i24;
                                for (_i24 = 0; _i24 < _size20; ++_i24)
                                {
                                    xfer += this->peer_nodes_list[_i24].read(iprot);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_peer_nodes_list)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t get_peer_nodes_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("get_peer_nodes_resp_body");

            xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
                std::vector<peer_node_info> ::const_iterator _iter25;
                for (_iter25 = this->peer_nodes_list.begin(); _iter25 != this->peer_nodes_list.end(); ++_iter25)
                {
                    xfer += (*_iter25).write(oprot);
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(get_peer_nodes_resp_body &a, get_peer_nodes_resp_body &b) {
            using ::std::swap;
            swap(a.peer_nodes_list, b.peer_nodes_list);
        }

        get_peer_nodes_resp_body::get_peer_nodes_resp_body(const get_peer_nodes_resp_body& other26) {
            peer_nodes_list = other26.peer_nodes_list;
        }
        get_peer_nodes_resp_body& get_peer_nodes_resp_body::operator=(const get_peer_nodes_resp_body& other27) {
            peer_nodes_list = other27.peer_nodes_list;
            return *this;
        }
        void get_peer_nodes_resp_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "get_peer_nodes_resp_body(";
            out << "peer_nodes_list=" << to_string(peer_nodes_list);
            out << ")";
        }


        get_peer_nodes_resp::~get_peer_nodes_resp() throw() {
        }


        void get_peer_nodes_resp::__set_body(const get_peer_nodes_resp_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t get_peer_nodes_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t get_peer_nodes_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("get_peer_nodes_resp");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(get_peer_nodes_resp &a, get_peer_nodes_resp &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        get_peer_nodes_resp::get_peer_nodes_resp(const get_peer_nodes_resp& other28) {
            body = other28.body;
            __isset = other28.__isset;
        }
        get_peer_nodes_resp& get_peer_nodes_resp::operator=(const get_peer_nodes_resp& other29) {
            body = other29.body;
            __isset = other29.__isset;
            return *this;
        }
        void get_peer_nodes_resp::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "get_peer_nodes_resp(";
            out << "body=" << to_string(body);
            out << ")";
        }


        peer_nodes_broadcast_req_body::~peer_nodes_broadcast_req_body() throw() {
        }


        void peer_nodes_broadcast_req_body::__set_peer_nodes_list(const std::vector<peer_node_info> & val) {
            this->peer_nodes_list = val;
        }
        std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t peer_nodes_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_peer_nodes_list = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size30;
                                ::apache::thrift::protocol::TType _etype33;
                                xfer += iprot->readListBegin(_etype33, _size30);
                                this->peer_nodes_list.resize(_size30);
                                uint32_t _i34;
                                for (_i34 = 0; _i34 < _size30; ++_i34)
                                {
                                    xfer += this->peer_nodes_list[_i34].read(iprot);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_peer_nodes_list)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t peer_nodes_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("peer_nodes_broadcast_req_body");

            xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
                std::vector<peer_node_info> ::const_iterator _iter35;
                for (_iter35 = this->peer_nodes_list.begin(); _iter35 != this->peer_nodes_list.end(); ++_iter35)
                {
                    xfer += (*_iter35).write(oprot);
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(peer_nodes_broadcast_req_body &a, peer_nodes_broadcast_req_body &b) {
            using ::std::swap;
            swap(a.peer_nodes_list, b.peer_nodes_list);
        }

        peer_nodes_broadcast_req_body::peer_nodes_broadcast_req_body(const peer_nodes_broadcast_req_body& other36) {
            peer_nodes_list = other36.peer_nodes_list;
        }
        peer_nodes_broadcast_req_body& peer_nodes_broadcast_req_body::operator=(const peer_nodes_broadcast_req_body& other37) {
            peer_nodes_list = other37.peer_nodes_list;
            return *this;
        }
        void peer_nodes_broadcast_req_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "peer_nodes_broadcast_req_body(";
            out << "peer_nodes_list=" << to_string(peer_nodes_list);
            out << ")";
        }


        peer_nodes_broadcast_req::~peer_nodes_broadcast_req() throw() {
        }


        void peer_nodes_broadcast_req::__set_body(const peer_nodes_broadcast_req_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t peer_nodes_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t peer_nodes_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("peer_nodes_broadcast_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(peer_nodes_broadcast_req &a, peer_nodes_broadcast_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        peer_nodes_broadcast_req::peer_nodes_broadcast_req(const peer_nodes_broadcast_req& other38) {
            body = other38.body;
            __isset = other38.__isset;
        }
        peer_nodes_broadcast_req& peer_nodes_broadcast_req::operator=(const peer_nodes_broadcast_req& other39) {
            body = other39.body;
            __isset = other39.__isset;
            return *this;
        }
        void peer_nodes_broadcast_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "peer_nodes_broadcast_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        node_create_task_req_body::~node_create_task_req_body() throw() {
        }


        void node_create_task_req_body::__set_task_id(const std::string& val) {
            this->task_id = val;
        }

        void node_create_task_req_body::__set_peer_nodes_list(const std::vector<std::string> & val) {
            this->peer_nodes_list = val;
        }

        void node_create_task_req_body::__set_additional(const std::string& val) {
            this->additional = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_create_task_req_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_create_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_task_id = false;
            bool isset_peer_nodes_list = false;
            bool isset_additional = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->task_id);
                            isset_task_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size40;
                                ::apache::thrift::protocol::TType _etype43;
                                xfer += iprot->readListBegin(_etype43, _size40);
                                this->peer_nodes_list.resize(_size40);
                                uint32_t _i44;
                                for (_i44 = 0; _i44 < _size40; ++_i44)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i44]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->additional);
                            isset_additional = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_task_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_peer_nodes_list)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_additional)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t node_create_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_create_task_req_body");

            xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->task_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 3);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
                std::vector<std::string> ::const_iterator _iter45;
                for (_iter45 = this->peer_nodes_list.begin(); _iter45 != this->peer_nodes_list.end(); ++_iter45)
                {
                    xfer += oprot->writeString((*_iter45));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 4);
            xfer += oprot->writeString(this->additional);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_create_task_req_body &a, node_create_task_req_body &b) {
            using ::std::swap;
            swap(a.task_id, b.task_id);
            swap(a.peer_nodes_list, b.peer_nodes_list);
            swap(a.additional, b.additional);
        }

        node_create_task_req_body::node_create_task_req_body(const node_create_task_req_body& other46) {
            task_id = other46.task_id;
            peer_nodes_list = other46.peer_nodes_list;
            additional = other46.additional;
        }
        node_create_task_req_body& node_create_task_req_body::operator=(const node_create_task_req_body& other47) {
            task_id = other47.task_id;
            peer_nodes_list = other47.peer_nodes_list;
            additional = other47.additional;
            return *this;
        }
        void node_create_task_req_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_create_task_req_body(";
            out << "task_id=" << to_string(task_id);
            out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
            out << ", " << "additional=" << to_string(additional);
            out << ")";
        }


        node_create_task_req::~node_create_task_req() throw() {
        }


        void node_create_task_req::__set_body(const node_create_task_req_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_create_task_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_create_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t node_create_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_create_task_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_create_task_req &a, node_create_task_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        node_create_task_req::node_create_task_req(const node_create_task_req& other48) {
            body = other48.body;
            __isset = other48.__isset;
        }
        node_create_task_req& node_create_task_req::operator=(const node_create_task_req& other49) {
            body = other49.body;
            __isset = other49.__isset;
            return *this;
        }
        void node_create_task_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_create_task_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        node_start_task_req_body::~node_start_task_req_body() throw() {
        }


        void node_start_task_req_body::__set_task_id(const std::string& val) {
            this->task_id = val;
        }

        void node_start_task_req_body::__set_peer_nodes_list(const std::vector<std::string> & val) {
            this->peer_nodes_list = val;
        }

        void node_start_task_req_body::__set_additional(const std::string& val) {
            this->additional = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_start_task_req_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_start_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_task_id = false;
            bool isset_peer_nodes_list = false;
            bool isset_additional = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->task_id);
                            isset_task_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size50;
                                ::apache::thrift::protocol::TType _etype53;
                                xfer += iprot->readListBegin(_etype53, _size50);
                                this->peer_nodes_list.resize(_size50);
                                uint32_t _i54;
                                for (_i54 = 0; _i54 < _size50; ++_i54)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i54]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->additional);
                            isset_additional = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_task_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_peer_nodes_list)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_additional)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t node_start_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_start_task_req_body");

            xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->task_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
                std::vector<std::string> ::const_iterator _iter55;
                for (_iter55 = this->peer_nodes_list.begin(); _iter55 != this->peer_nodes_list.end(); ++_iter55)
                {
                    xfer += oprot->writeString((*_iter55));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
            xfer += oprot->writeString(this->additional);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_start_task_req_body &a, node_start_task_req_body &b) {
            using ::std::swap;
            swap(a.task_id, b.task_id);
            swap(a.peer_nodes_list, b.peer_nodes_list);
            swap(a.additional, b.additional);
        }

        node_start_task_req_body::node_start_task_req_body(const node_start_task_req_body& other56) {
            task_id = other56.task_id;
            peer_nodes_list = other56.peer_nodes_list;
            additional = other56.additional;
        }
        node_start_task_req_body& node_start_task_req_body::operator=(const node_start_task_req_body& other57) {
            task_id = other57.task_id;
            peer_nodes_list = other57.peer_nodes_list;
            additional = other57.additional;
            return *this;
        }
        void node_start_task_req_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_start_task_req_body(";
            out << "task_id=" << to_string(task_id);
            out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
            out << ", " << "additional=" << to_string(additional);
            out << ")";
        }


        node_start_task_req::~node_start_task_req() throw() {
        }


        void node_start_task_req::__set_body(const node_start_task_req_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_start_task_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_start_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t node_start_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_start_task_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_start_task_req &a, node_start_task_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        node_start_task_req::node_start_task_req(const node_start_task_req& other58) {
            body = other58.body;
            __isset = other58.__isset;
        }
        node_start_task_req& node_start_task_req::operator=(const node_start_task_req& other59) {
            body = other59.body;
            __isset = other59.__isset;
            return *this;
        }
        void node_start_task_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_start_task_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        node_restart_task_req_body::~node_restart_task_req_body() throw() {
        }


        void node_restart_task_req_body::__set_task_id(const std::string& val) {
            this->task_id = val;
        }

        void node_restart_task_req_body::__set_peer_nodes_list(const std::vector<std::string> & val) {
            this->peer_nodes_list = val;
        }

        void node_restart_task_req_body::__set_additional(const std::string& val) {
            this->additional = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_restart_task_req_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_restart_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_task_id = false;
            bool isset_peer_nodes_list = false;
            bool isset_additional = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->task_id);
                            isset_task_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size60;
                                ::apache::thrift::protocol::TType _etype63;
                                xfer += iprot->readListBegin(_etype63, _size60);
                                this->peer_nodes_list.resize(_size60);
                                uint32_t _i64;
                                for (_i64 = 0; _i64 < _size60; ++_i64)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i64]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->additional);
                            isset_additional = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_task_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_peer_nodes_list)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_additional)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t node_restart_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_restart_task_req_body");

            xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->task_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
                std::vector<std::string> ::const_iterator _iter65;
                for (_iter65 = this->peer_nodes_list.begin(); _iter65 != this->peer_nodes_list.end(); ++_iter65)
                {
                    xfer += oprot->writeString((*_iter65));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
            xfer += oprot->writeString(this->additional);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_restart_task_req_body &a, node_restart_task_req_body &b) {
            using ::std::swap;
            swap(a.task_id, b.task_id);
            swap(a.peer_nodes_list, b.peer_nodes_list);
            swap(a.additional, b.additional);
        }

        node_restart_task_req_body::node_restart_task_req_body(const node_restart_task_req_body& other66) {
            task_id = other66.task_id;
            peer_nodes_list = other66.peer_nodes_list;
            additional = other66.additional;
        }
        node_restart_task_req_body& node_restart_task_req_body::operator=(const node_restart_task_req_body& other67) {
            task_id = other67.task_id;
            peer_nodes_list = other67.peer_nodes_list;
            additional = other67.additional;
            return *this;
        }
        void node_restart_task_req_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_restart_task_req_body(";
            out << "task_id=" << to_string(task_id);
            out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
            out << ", " << "additional=" << to_string(additional);
            out << ")";
        }


        node_restart_task_req::~node_restart_task_req() throw() {
        }


        void node_restart_task_req::__set_body(const node_restart_task_req_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_restart_task_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_restart_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t node_restart_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_restart_task_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_restart_task_req &a, node_restart_task_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        node_restart_task_req::node_restart_task_req(const node_restart_task_req& other68) {
            body = other68.body;
            __isset = other68.__isset;
        }
        node_restart_task_req& node_restart_task_req::operator=(const node_restart_task_req& other69) {
            body = other69.body;
            __isset = other69.__isset;
            return *this;
        }
        void node_restart_task_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_restart_task_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        node_stop_task_req_body::~node_stop_task_req_body() throw() {
        }


        void node_stop_task_req_body::__set_task_id(const std::string& val) {
            this->task_id = val;
        }

        void node_stop_task_req_body::__set_peer_nodes_list(const std::vector<std::string> & val) {
            this->peer_nodes_list = val;
        }

        void node_stop_task_req_body::__set_additional(const std::string& val) {
            this->additional = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_stop_task_req_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_stop_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_task_id = false;
            bool isset_peer_nodes_list = false;
            bool isset_additional = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->task_id);
                            isset_task_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size70;
                                ::apache::thrift::protocol::TType _etype73;
                                xfer += iprot->readListBegin(_etype73, _size70);
                                this->peer_nodes_list.resize(_size70);
                                uint32_t _i74;
                                for (_i74 = 0; _i74 < _size70; ++_i74)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i74]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->additional);
                            isset_additional = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_task_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_peer_nodes_list)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_additional)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t node_stop_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_stop_task_req_body");

            xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->task_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
                std::vector<std::string> ::const_iterator _iter75;
                for (_iter75 = this->peer_nodes_list.begin(); _iter75 != this->peer_nodes_list.end(); ++_iter75)
                {
                    xfer += oprot->writeString((*_iter75));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
            xfer += oprot->writeString(this->additional);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_stop_task_req_body &a, node_stop_task_req_body &b) {
            using ::std::swap;
            swap(a.task_id, b.task_id);
            swap(a.peer_nodes_list, b.peer_nodes_list);
            swap(a.additional, b.additional);
        }

        node_stop_task_req_body::node_stop_task_req_body(const node_stop_task_req_body& other76) {
            task_id = other76.task_id;
            peer_nodes_list = other76.peer_nodes_list;
            additional = other76.additional;
        }
        node_stop_task_req_body& node_stop_task_req_body::operator=(const node_stop_task_req_body& other77) {
            task_id = other77.task_id;
            peer_nodes_list = other77.peer_nodes_list;
            additional = other77.additional;
            return *this;
        }
        void node_stop_task_req_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_stop_task_req_body(";
            out << "task_id=" << to_string(task_id);
            out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
            out << ", " << "additional=" << to_string(additional);
            out << ")";
        }


        node_stop_task_req::~node_stop_task_req() throw() {
        }


        void node_stop_task_req::__set_body(const node_stop_task_req_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_stop_task_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_stop_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t node_stop_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_stop_task_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_stop_task_req &a, node_stop_task_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        node_stop_task_req::node_stop_task_req(const node_stop_task_req& other78) {
            body = other78.body;
            __isset = other78.__isset;
        }
        node_stop_task_req& node_stop_task_req::operator=(const node_stop_task_req& other79) {
            body = other79.body;
            __isset = other79.__isset;
            return *this;
        }
        void node_stop_task_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_stop_task_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        node_task_logs_req_body::~node_task_logs_req_body() throw() {
        }


        void node_task_logs_req_body::__set_task_id(const std::string& val) {
            this->task_id = val;
        }

        void node_task_logs_req_body::__set_peer_nodes_list(const std::vector<std::string> & val) {
            this->peer_nodes_list = val;
        }

        void node_task_logs_req_body::__set_head_or_tail(const int8_t val) {
            this->head_or_tail = val;
        }

        void node_task_logs_req_body::__set_number_of_lines(const int16_t val) {
            this->number_of_lines = val;
        }

        void node_task_logs_req_body::__set_additional(const std::string& val) {
            this->additional = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_task_logs_req_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_task_logs_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_task_id = false;
            bool isset_peer_nodes_list = false;
            bool isset_head_or_tail = false;
            bool isset_number_of_lines = false;
            bool isset_additional = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->task_id);
                            isset_task_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size80;
                                ::apache::thrift::protocol::TType _etype83;
                                xfer += iprot->readListBegin(_etype83, _size80);
                                this->peer_nodes_list.resize(_size80);
                                uint32_t _i84;
                                for (_i84 = 0; _i84 < _size80; ++_i84)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i84]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_BYTE) {
                            xfer += iprot->readByte(this->head_or_tail);
                            isset_head_or_tail = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_I16) {
                            xfer += iprot->readI16(this->number_of_lines);
                            isset_number_of_lines = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 5:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->additional);
                            isset_additional = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_task_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_peer_nodes_list)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_head_or_tail)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_number_of_lines)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_additional)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t node_task_logs_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_task_logs_req_body");

            xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->task_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
                std::vector<std::string> ::const_iterator _iter85;
                for (_iter85 = this->peer_nodes_list.begin(); _iter85 != this->peer_nodes_list.end(); ++_iter85)
                {
                    xfer += oprot->writeString((*_iter85));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("head_or_tail", ::apache::thrift::protocol::T_BYTE, 3);
            xfer += oprot->writeByte(this->head_or_tail);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("number_of_lines", ::apache::thrift::protocol::T_I16, 4);
            xfer += oprot->writeI16(this->number_of_lines);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 5);
            xfer += oprot->writeString(this->additional);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_task_logs_req_body &a, node_task_logs_req_body &b) {
            using ::std::swap;
            swap(a.task_id, b.task_id);
            swap(a.peer_nodes_list, b.peer_nodes_list);
            swap(a.head_or_tail, b.head_or_tail);
            swap(a.number_of_lines, b.number_of_lines);
            swap(a.additional, b.additional);
        }

        node_task_logs_req_body::node_task_logs_req_body(const node_task_logs_req_body& other86) {
            task_id = other86.task_id;
            peer_nodes_list = other86.peer_nodes_list;
            head_or_tail = other86.head_or_tail;
            number_of_lines = other86.number_of_lines;
            additional = other86.additional;
        }
        node_task_logs_req_body& node_task_logs_req_body::operator=(const node_task_logs_req_body& other87) {
            task_id = other87.task_id;
            peer_nodes_list = other87.peer_nodes_list;
            head_or_tail = other87.head_or_tail;
            number_of_lines = other87.number_of_lines;
            additional = other87.additional;
            return *this;
        }
        void node_task_logs_req_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_task_logs_req_body(";
            out << "task_id=" << to_string(task_id);
            out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
            out << ", " << "head_or_tail=" << to_string(head_or_tail);
            out << ", " << "number_of_lines=" << to_string(number_of_lines);
            out << ", " << "additional=" << to_string(additional);
            out << ")";
        }


        node_task_logs_req::~node_task_logs_req() throw() {
        }


        void node_task_logs_req::__set_body(const node_task_logs_req_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_task_logs_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_task_logs_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t node_task_logs_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_task_logs_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_task_logs_req &a, node_task_logs_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        node_task_logs_req::node_task_logs_req(const node_task_logs_req& other88) {
            body = other88.body;
            __isset = other88.__isset;
        }
        node_task_logs_req& node_task_logs_req::operator=(const node_task_logs_req& other89) {
            body = other89.body;
            __isset = other89.__isset;
            return *this;
        }
        void node_task_logs_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_task_logs_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        peer_node_log::~peer_node_log() throw() {
        }


        void peer_node_log::__set_peer_node_id(const std::string& val) {
            this->peer_node_id = val;
        }

        void peer_node_log::__set_log_content(const std::string& val) {
            this->log_content = val;
        }
        std::ostream& operator<<(std::ostream& out, const peer_node_log& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t peer_node_log::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_peer_node_id = false;
            bool isset_log_content = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->peer_node_id);
                            isset_peer_node_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->log_content);
                            isset_log_content = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_peer_node_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_log_content)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t peer_node_log::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("peer_node_log");

            xfer += oprot->writeFieldBegin("peer_node_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->peer_node_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("log_content", ::apache::thrift::protocol::T_STRING, 2);
            xfer += oprot->writeString(this->log_content);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(peer_node_log &a, peer_node_log &b) {
            using ::std::swap;
            swap(a.peer_node_id, b.peer_node_id);
            swap(a.log_content, b.log_content);
        }

        peer_node_log::peer_node_log(const peer_node_log& other90) {
            peer_node_id = other90.peer_node_id;
            log_content = other90.log_content;
        }
        peer_node_log& peer_node_log::operator=(const peer_node_log& other91) {
            peer_node_id = other91.peer_node_id;
            log_content = other91.log_content;
            return *this;
        }
        void peer_node_log::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "peer_node_log(";
            out << "peer_node_id=" << to_string(peer_node_id);
            out << ", " << "log_content=" << to_string(log_content);
            out << ")";
        }


        node_task_logs_rsp_body::~node_task_logs_rsp_body() throw() {
        }


        void node_task_logs_rsp_body::__set_log(const peer_node_log& val) {
            this->log = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_task_logs_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_log = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->log.read(iprot);
                            isset_log = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_log)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t node_task_logs_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_task_logs_rsp_body");

            xfer += oprot->writeFieldBegin("log", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->log.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_task_logs_rsp_body &a, node_task_logs_rsp_body &b) {
            using ::std::swap;
            swap(a.log, b.log);
        }

        node_task_logs_rsp_body::node_task_logs_rsp_body(const node_task_logs_rsp_body& other92) {
            log = other92.log;
        }
        node_task_logs_rsp_body& node_task_logs_rsp_body::operator=(const node_task_logs_rsp_body& other93) {
            log = other93.log;
            return *this;
        }
        void node_task_logs_rsp_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_task_logs_rsp_body(";
            out << "log=" << to_string(log);
            out << ")";
        }


        node_task_logs_rsp::~node_task_logs_rsp() throw() {
        }


        void node_task_logs_rsp::__set_body(const node_task_logs_rsp_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_task_logs_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t node_task_logs_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_task_logs_rsp");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_task_logs_rsp &a, node_task_logs_rsp &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        node_task_logs_rsp::node_task_logs_rsp(const node_task_logs_rsp& other94) {
            body = other94.body;
            __isset = other94.__isset;
        }
        node_task_logs_rsp& node_task_logs_rsp::operator=(const node_task_logs_rsp& other95) {
            body = other95.body;
            __isset = other95.__isset;
            return *this;
        }
        void node_task_logs_rsp::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_task_logs_rsp(";
            out << "body=" << to_string(body);
            out << ")";
        }


        node_list_task_req_body::~node_list_task_req_body() throw() {
        }


        void node_list_task_req_body::__set_task_id(const std::string& val) {
            this->task_id = val;
        }

        void node_list_task_req_body::__set_peer_nodes_list(const std::vector<std::string> & val) {
            this->peer_nodes_list = val;
        }

        void node_list_task_req_body::__set_additional(const std::string& val) {
            this->additional = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_list_task_req_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_list_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_task_id = false;
            bool isset_peer_nodes_list = false;
            bool isset_additional = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->task_id);
                            isset_task_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->peer_nodes_list.clear();
                                uint32_t _size96;
                                ::apache::thrift::protocol::TType _etype99;
                                xfer += iprot->readListBegin(_etype99, _size96);
                                this->peer_nodes_list.resize(_size96);
                                uint32_t _i100;
                                for (_i100 = 0; _i100 < _size96; ++_i100)
                                {
                                    xfer += iprot->readString(this->peer_nodes_list[_i100]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_peer_nodes_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->additional);
                            isset_additional = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_task_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_peer_nodes_list)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_additional)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t node_list_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_list_task_req_body");

            xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->task_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
                std::vector<std::string> ::const_iterator _iter101;
                for (_iter101 = this->peer_nodes_list.begin(); _iter101 != this->peer_nodes_list.end(); ++_iter101)
                {
                    xfer += oprot->writeString((*_iter101));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
            xfer += oprot->writeString(this->additional);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_list_task_req_body &a, node_list_task_req_body &b) {
            using ::std::swap;
            swap(a.task_id, b.task_id);
            swap(a.peer_nodes_list, b.peer_nodes_list);
            swap(a.additional, b.additional);
        }

        node_list_task_req_body::node_list_task_req_body(const node_list_task_req_body& other102) {
            task_id = other102.task_id;
            peer_nodes_list = other102.peer_nodes_list;
            additional = other102.additional;
        }
        node_list_task_req_body& node_list_task_req_body::operator=(const node_list_task_req_body& other103) {
            task_id = other103.task_id;
            peer_nodes_list = other103.peer_nodes_list;
            additional = other103.additional;
            return *this;
        }
        void node_list_task_req_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_list_task_req_body(";
            out << "task_id=" << to_string(task_id);
            out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
            out << ", " << "additional=" << to_string(additional);
            out << ")";
        }


        node_list_task_req::~node_list_task_req() throw() {
        }


        void node_list_task_req::__set_body(const node_list_task_req_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_list_task_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_list_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t node_list_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_list_task_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_list_task_req &a, node_list_task_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        node_list_task_req::node_list_task_req(const node_list_task_req& other104) {
            body = other104.body;
            __isset = other104.__isset;
        }
        node_list_task_req& node_list_task_req::operator=(const node_list_task_req& other105) {
            body = other105.body;
            __isset = other105.__isset;
            return *this;
        }
        void node_list_task_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_list_task_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        node_list_task_rsp_body::~node_list_task_rsp_body() throw() {
        }


        void node_list_task_rsp_body::__set_task_status_list(const std::vector<task_status> & val) {
            this->task_status_list = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_list_task_rsp_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_list_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_task_status_list = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->task_status_list.clear();
                                uint32_t _size106;
                                ::apache::thrift::protocol::TType _etype109;
                                xfer += iprot->readListBegin(_etype109, _size106);
                                this->task_status_list.resize(_size106);
                                uint32_t _i110;
                                for (_i110 = 0; _i110 < _size106; ++_i110)
                                {
                                    xfer += this->task_status_list[_i110].read(iprot);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_task_status_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_task_status_list)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t node_list_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_list_task_rsp_body");

            xfer += oprot->writeFieldBegin("task_status_list", ::apache::thrift::protocol::T_LIST, 1);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->task_status_list.size()));
                std::vector<task_status> ::const_iterator _iter111;
                for (_iter111 = this->task_status_list.begin(); _iter111 != this->task_status_list.end(); ++_iter111)
                {
                    xfer += (*_iter111).write(oprot);
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_list_task_rsp_body &a, node_list_task_rsp_body &b) {
            using ::std::swap;
            swap(a.task_status_list, b.task_status_list);
        }

        node_list_task_rsp_body::node_list_task_rsp_body(const node_list_task_rsp_body& other112) {
            task_status_list = other112.task_status_list;
        }
        node_list_task_rsp_body& node_list_task_rsp_body::operator=(const node_list_task_rsp_body& other113) {
            task_status_list = other113.task_status_list;
            return *this;
        }
        void node_list_task_rsp_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_list_task_rsp_body(";
            out << "task_status_list=" << to_string(task_status_list);
            out << ")";
        }


        node_list_task_rsp::~node_list_task_rsp() throw() {
        }


        void node_list_task_rsp::__set_body(const node_list_task_rsp_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const node_list_task_rsp& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_list_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t node_list_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_list_task_rsp");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_list_task_rsp &a, node_list_task_rsp &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        node_list_task_rsp::node_list_task_rsp(const node_list_task_rsp& other114) {
            body = other114.body;
            __isset = other114.__isset;
        }
        node_list_task_rsp& node_list_task_rsp::operator=(const node_list_task_rsp& other115) {
            body = other115.body;
            __isset = other115.__isset;
            return *this;
        }
        void node_list_task_rsp::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_list_task_rsp(";
            out << "body=" << to_string(body);
            out << ")";
        }


        ver_req_body::~ver_req_body() throw() {
        }


        void ver_req_body::__set_node_id(const std::string& val) {
            this->node_id = val;
        }

        void ver_req_body::__set_core_version(const int32_t val) {
            this->core_version = val;
        }

        void ver_req_body::__set_protocol_version(const int32_t val) {
            this->protocol_version = val;
        }

        void ver_req_body::__set_time_stamp(const int64_t val) {
            this->time_stamp = val;
        }

        void ver_req_body::__set_addr_me(const network_address& val) {
            this->addr_me = val;
        }

        void ver_req_body::__set_addr_you(const network_address& val) {
            this->addr_you = val;
        }

        void ver_req_body::__set_start_height(const int64_t val) {
            this->start_height = val;
        }
        std::ostream& operator<<(std::ostream& out, const ver_req_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t ver_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_node_id = false;
            bool isset_core_version = false;
            bool isset_protocol_version = false;
            bool isset_time_stamp = false;
            bool isset_addr_me = false;
            bool isset_addr_you = false;
            bool isset_start_height = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->node_id);
                            isset_node_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->core_version);
                            isset_core_version = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->protocol_version);
                            isset_protocol_version = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_I64) {
                            xfer += iprot->readI64(this->time_stamp);
                            isset_time_stamp = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 5:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->addr_me.read(iprot);
                            isset_addr_me = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 6:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->addr_you.read(iprot);
                            isset_addr_you = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 7:
                        if (ftype == ::apache::thrift::protocol::T_I64) {
                            xfer += iprot->readI64(this->start_height);
                            isset_start_height = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_node_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_core_version)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_protocol_version)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_time_stamp)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_addr_me)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_addr_you)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_start_height)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t ver_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("ver_req_body");

            xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->node_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32(this->core_version);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
            xfer += oprot->writeI32(this->protocol_version);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 4);
            xfer += oprot->writeI64(this->time_stamp);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("addr_me", ::apache::thrift::protocol::T_STRUCT, 5);
            xfer += this->addr_me.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("addr_you", ::apache::thrift::protocol::T_STRUCT, 6);
            xfer += this->addr_you.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("start_height", ::apache::thrift::protocol::T_I64, 7);
            xfer += oprot->writeI64(this->start_height);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(ver_req_body &a, ver_req_body &b) {
            using ::std::swap;
            swap(a.node_id, b.node_id);
            swap(a.core_version, b.core_version);
            swap(a.protocol_version, b.protocol_version);
            swap(a.time_stamp, b.time_stamp);
            swap(a.addr_me, b.addr_me);
            swap(a.addr_you, b.addr_you);
            swap(a.start_height, b.start_height);
        }

        ver_req_body::ver_req_body(const ver_req_body& other116) {
            node_id = other116.node_id;
            core_version = other116.core_version;
            protocol_version = other116.protocol_version;
            time_stamp = other116.time_stamp;
            addr_me = other116.addr_me;
            addr_you = other116.addr_you;
            start_height = other116.start_height;
        }
        ver_req_body& ver_req_body::operator=(const ver_req_body& other117) {
            node_id = other117.node_id;
            core_version = other117.core_version;
            protocol_version = other117.protocol_version;
            time_stamp = other117.time_stamp;
            addr_me = other117.addr_me;
            addr_you = other117.addr_you;
            start_height = other117.start_height;
            return *this;
        }
        void ver_req_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "ver_req_body(";
            out << "node_id=" << to_string(node_id);
            out << ", " << "core_version=" << to_string(core_version);
            out << ", " << "protocol_version=" << to_string(protocol_version);
            out << ", " << "time_stamp=" << to_string(time_stamp);
            out << ", " << "addr_me=" << to_string(addr_me);
            out << ", " << "addr_you=" << to_string(addr_you);
            out << ", " << "start_height=" << to_string(start_height);
            out << ")";
        }


        ver_req::~ver_req() throw() {
        }


        void ver_req::__set_body(const ver_req_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const ver_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t ver_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t ver_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("ver_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(ver_req &a, ver_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        ver_req::ver_req(const ver_req& other118) {
            body = other118.body;
            __isset = other118.__isset;
        }
        ver_req& ver_req::operator=(const ver_req& other119) {
            body = other119.body;
            __isset = other119.__isset;
            return *this;
        }
        void ver_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "ver_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        ver_resp_body::~ver_resp_body() throw() {
        }


        void ver_resp_body::__set_node_id(const std::string& val) {
            this->node_id = val;
        }

        void ver_resp_body::__set_core_version(const int32_t val) {
            this->core_version = val;
        }

        void ver_resp_body::__set_protocol_version(const int32_t val) {
            this->protocol_version = val;
        }
        std::ostream& operator<<(std::ostream& out, const ver_resp_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t ver_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_node_id = false;
            bool isset_core_version = false;
            bool isset_protocol_version = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->node_id);
                            isset_node_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->core_version);
                            isset_core_version = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_I32) {
                            xfer += iprot->readI32(this->protocol_version);
                            isset_protocol_version = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_node_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_core_version)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_protocol_version)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t ver_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("ver_resp_body");

            xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->node_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
            xfer += oprot->writeI32(this->core_version);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
            xfer += oprot->writeI32(this->protocol_version);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(ver_resp_body &a, ver_resp_body &b) {
            using ::std::swap;
            swap(a.node_id, b.node_id);
            swap(a.core_version, b.core_version);
            swap(a.protocol_version, b.protocol_version);
        }

        ver_resp_body::ver_resp_body(const ver_resp_body& other120) {
            node_id = other120.node_id;
            core_version = other120.core_version;
            protocol_version = other120.protocol_version;
        }
        ver_resp_body& ver_resp_body::operator=(const ver_resp_body& other121) {
            node_id = other121.node_id;
            core_version = other121.core_version;
            protocol_version = other121.protocol_version;
            return *this;
        }
        void ver_resp_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "ver_resp_body(";
            out << "node_id=" << to_string(node_id);
            out << ", " << "core_version=" << to_string(core_version);
            out << ", " << "protocol_version=" << to_string(protocol_version);
            out << ")";
        }


        ver_resp::~ver_resp() throw() {
        }


        void ver_resp::__set_body(const ver_resp_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const ver_resp& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t ver_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t ver_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("ver_resp");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(ver_resp &a, ver_resp &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        ver_resp::ver_resp(const ver_resp& other122) {
            body = other122.body;
            __isset = other122.__isset;
        }
        ver_resp& ver_resp::operator=(const ver_resp& other123) {
            body = other123.body;
            __isset = other123.__isset;
            return *this;
        }
        void ver_resp::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "ver_resp(";
            out << "body=" << to_string(body);
            out << ")";
        }


        show_req_body::~show_req_body() throw() {
        }


        void show_req_body::__set_o_node_id(const std::string& val) {
            this->o_node_id = val;
        }

        void show_req_body::__set_d_node_id(const std::string& val) {
            this->d_node_id = val;
        }

        void show_req_body::__set_keys(const std::vector<std::string> & val) {
            this->keys = val;
        }
        std::ostream& operator<<(std::ostream& out, const show_req_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t show_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_o_node_id = false;
            bool isset_d_node_id = false;
            bool isset_keys = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->o_node_id);
                            isset_o_node_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->d_node_id);
                            isset_d_node_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->keys.clear();
                                uint32_t _size124;
                                ::apache::thrift::protocol::TType _etype127;
                                xfer += iprot->readListBegin(_etype127, _size124);
                                this->keys.resize(_size124);
                                uint32_t _i128;
                                for (_i128 = 0; _i128 < _size124; ++_i128)
                                {
                                    xfer += iprot->readString(this->keys[_i128]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_keys = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_o_node_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_d_node_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_keys)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t show_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("show_req_body");

            xfer += oprot->writeFieldBegin("o_node_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->o_node_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("d_node_id", ::apache::thrift::protocol::T_STRING, 2);
            xfer += oprot->writeString(this->d_node_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 3);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->keys.size()));
                std::vector<std::string> ::const_iterator _iter129;
                for (_iter129 = this->keys.begin(); _iter129 != this->keys.end(); ++_iter129)
                {
                    xfer += oprot->writeString((*_iter129));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(show_req_body &a, show_req_body &b) {
            using ::std::swap;
            swap(a.o_node_id, b.o_node_id);
            swap(a.d_node_id, b.d_node_id);
            swap(a.keys, b.keys);
        }

        show_req_body::show_req_body(const show_req_body& other130) {
            o_node_id = other130.o_node_id;
            d_node_id = other130.d_node_id;
            keys = other130.keys;
        }
        show_req_body& show_req_body::operator=(const show_req_body& other131) {
            o_node_id = other131.o_node_id;
            d_node_id = other131.d_node_id;
            keys = other131.keys;
            return *this;
        }
        void show_req_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "show_req_body(";
            out << "o_node_id=" << to_string(o_node_id);
            out << ", " << "d_node_id=" << to_string(d_node_id);
            out << ", " << "keys=" << to_string(keys);
            out << ")";
        }


        show_req::~show_req() throw() {
        }


        void show_req::__set_body(const show_req_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const show_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t show_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t show_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("show_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(show_req &a, show_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        show_req::show_req(const show_req& other132) {
            body = other132.body;
            __isset = other132.__isset;
        }
        show_req& show_req::operator=(const show_req& other133) {
            body = other133.body;
            __isset = other133.__isset;
            return *this;
        }
        void show_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "show_req(";
            out << "body=" << to_string(body);
            out << ")";
        }


        show_resp_body::~show_resp_body() throw() {
        }


        void show_resp_body::__set_o_node_id(const std::string& val) {
            this->o_node_id = val;
        }

        void show_resp_body::__set_d_node_id(const std::string& val) {
            this->d_node_id = val;
        }

        void show_resp_body::__set_kvs(const std::map<std::string, std::string> & val) {
            this->kvs = val;
        }
        std::ostream& operator<<(std::ostream& out, const show_resp_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t show_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_o_node_id = false;
            bool isset_d_node_id = false;
            bool isset_kvs = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->o_node_id);
                            isset_o_node_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->d_node_id);
                            isset_d_node_id = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_MAP) {
                            {
                                this->kvs.clear();
                                uint32_t _size134;
                                ::apache::thrift::protocol::TType _ktype135;
                                ::apache::thrift::protocol::TType _vtype136;
                                xfer += iprot->readMapBegin(_ktype135, _vtype136, _size134);
                                uint32_t _i138;
                                for (_i138 = 0; _i138 < _size134; ++_i138)
                                {
                                    std::string _key139;
                                    xfer += iprot->readString(_key139);
                                    std::string& _val140 = this->kvs[_key139];
                                    xfer += iprot->readString(_val140);
                                }
                                xfer += iprot->readMapEnd();
                            }
                            isset_kvs = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_o_node_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_d_node_id)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            if (!isset_kvs)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t show_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("show_resp_body");

            xfer += oprot->writeFieldBegin("o_node_id", ::apache::thrift::protocol::T_STRING, 1);
            xfer += oprot->writeString(this->o_node_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("d_node_id", ::apache::thrift::protocol::T_STRING, 2);
            xfer += oprot->writeString(this->d_node_id);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldBegin("kvs", ::apache::thrift::protocol::T_MAP, 3);
            {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kvs.size()));
                std::map<std::string, std::string> ::const_iterator _iter141;
                for (_iter141 = this->kvs.begin(); _iter141 != this->kvs.end(); ++_iter141)
                {
                    xfer += oprot->writeString(_iter141->first);
                    xfer += oprot->writeString(_iter141->second);
                }
                xfer += oprot->writeMapEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(show_resp_body &a, show_resp_body &b) {
            using ::std::swap;
            swap(a.o_node_id, b.o_node_id);
            swap(a.d_node_id, b.d_node_id);
            swap(a.kvs, b.kvs);
        }

        show_resp_body::show_resp_body(const show_resp_body& other142) {
            o_node_id = other142.o_node_id;
            d_node_id = other142.d_node_id;
            kvs = other142.kvs;
        }
        show_resp_body& show_resp_body::operator=(const show_resp_body& other143) {
            o_node_id = other143.o_node_id;
            d_node_id = other143.d_node_id;
            kvs = other143.kvs;
            return *this;
        }
        void show_resp_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "show_resp_body(";
            out << "o_node_id=" << to_string(o_node_id);
            out << ", " << "d_node_id=" << to_string(d_node_id);
            out << ", " << "kvs=" << to_string(kvs);
            out << ")";
        }


        show_resp::~show_resp() throw() {
        }


        void show_resp::__set_body(const show_resp_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const show_resp& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t show_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t show_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("show_resp");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(show_resp &a, show_resp &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        show_resp::show_resp(const show_resp& other144) {
            body = other144.body;
            __isset = other144.__isset;
        }
        show_resp& show_resp::operator=(const show_resp& other145) {
            body = other145.body;
            __isset = other145.__isset;
            return *this;
        }
        void show_resp::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "show_resp(";
            out << "body=" << to_string(body);
            out << ")";
        }


        node_service_info::~node_service_info() throw() {
        }


        void node_service_info::__set_service_list(const std::vector<std::string> & val) {
            this->service_list = val;
        }

        void node_service_info::__set_name(const std::string& val) {
            this->name = val;
            __isset.name = true;
        }

        void node_service_info::__set_time_stamp(const int64_t val) {
            this->time_stamp = val;
            __isset.time_stamp = true;
        }

        void node_service_info::__set_kvs(const std::map<std::string, std::string> & val) {
            this->kvs = val;
            __isset.kvs = true;
        }
        std::ostream& operator<<(std::ostream& out, const node_service_info& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t node_service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_service_list = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_LIST) {
                            {
                                this->service_list.clear();
                                uint32_t _size146;
                                ::apache::thrift::protocol::TType _etype149;
                                xfer += iprot->readListBegin(_etype149, _size146);
                                this->service_list.resize(_size146);
                                uint32_t _i150;
                                for (_i150 = 0; _i150 < _size146; ++_i150)
                                {
                                    xfer += iprot->readString(this->service_list[_i150]);
                                }
                                xfer += iprot->readListEnd();
                            }
                            isset_service_list = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 2:
                        if (ftype == ::apache::thrift::protocol::T_STRING) {
                            xfer += iprot->readString(this->name);
                            this->__isset.name = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 3:
                        if (ftype == ::apache::thrift::protocol::T_I64) {
                            xfer += iprot->readI64(this->time_stamp);
                            this->__isset.time_stamp = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    case 4:
                        if (ftype == ::apache::thrift::protocol::T_MAP) {
                            {
                                this->kvs.clear();
                                uint32_t _size151;
                                ::apache::thrift::protocol::TType _ktype152;
                                ::apache::thrift::protocol::TType _vtype153;
                                xfer += iprot->readMapBegin(_ktype152, _vtype153, _size151);
                                uint32_t _i155;
                                for (_i155 = 0; _i155 < _size151; ++_i155)
                                {
                                    std::string _key156;
                                    xfer += iprot->readString(_key156);
                                    std::string& _val157 = this->kvs[_key156];
                                    xfer += iprot->readString(_val157);
                                }
                                xfer += iprot->readMapEnd();
                            }
                            this->__isset.kvs = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_service_list)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t node_service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("node_service_info");

            xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 1);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
                std::vector<std::string> ::const_iterator _iter158;
                for (_iter158 = this->service_list.begin(); _iter158 != this->service_list.end(); ++_iter158)
                {
                    xfer += oprot->writeString((*_iter158));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();

            if (this->__isset.name) {
                xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
                xfer += oprot->writeString(this->name);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.time_stamp) {
                xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 3);
                xfer += oprot->writeI64(this->time_stamp);
                xfer += oprot->writeFieldEnd();
            }
            if (this->__isset.kvs) {
                xfer += oprot->writeFieldBegin("kvs", ::apache::thrift::protocol::T_MAP, 4);
                {
                    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kvs.size()));
                    std::map<std::string, std::string> ::const_iterator _iter159;
                    for (_iter159 = this->kvs.begin(); _iter159 != this->kvs.end(); ++_iter159)
                    {
                        xfer += oprot->writeString(_iter159->first);
                        xfer += oprot->writeString(_iter159->second);
                    }
                    xfer += oprot->writeMapEnd();
                }
                xfer += oprot->writeFieldEnd();
            }
            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(node_service_info &a, node_service_info &b) {
            using ::std::swap;
            swap(a.service_list, b.service_list);
            swap(a.name, b.name);
            swap(a.time_stamp, b.time_stamp);
            swap(a.kvs, b.kvs);
            swap(a.__isset, b.__isset);
        }

        node_service_info::node_service_info(const node_service_info& other160) {
            service_list = other160.service_list;
            name = other160.name;
            time_stamp = other160.time_stamp;
            kvs = other160.kvs;
            __isset = other160.__isset;
        }
        node_service_info& node_service_info::operator=(const node_service_info& other161) {
            service_list = other161.service_list;
            name = other161.name;
            time_stamp = other161.time_stamp;
            kvs = other161.kvs;
            __isset = other161.__isset;
            return *this;
        }
        void node_service_info::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "node_service_info(";
            out << "service_list=" << to_string(service_list);
            out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
            out << ", " << "time_stamp="; (__isset.time_stamp ? (out << to_string(time_stamp)) : (out << "<null>"));
            out << ", " << "kvs="; (__isset.kvs ? (out << to_string(kvs)) : (out << "<null>"));
            out << ")";
        }


        service_broadcast_req_body::~service_broadcast_req_body() throw() {
        }


        void service_broadcast_req_body::__set_node_service_info_map(const std::map<std::string, node_service_info> & val) {
            this->node_service_info_map = val;
        }
        std::ostream& operator<<(std::ostream& out, const service_broadcast_req_body& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t service_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;

            bool isset_node_service_info_map = false;

            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_MAP) {
                            {
                                this->node_service_info_map.clear();
                                uint32_t _size162;
                                ::apache::thrift::protocol::TType _ktype163;
                                ::apache::thrift::protocol::TType _vtype164;
                                xfer += iprot->readMapBegin(_ktype163, _vtype164, _size162);
                                uint32_t _i166;
                                for (_i166 = 0; _i166 < _size162; ++_i166)
                                {
                                    std::string _key167;
                                    xfer += iprot->readString(_key167);
                                    node_service_info& _val168 = this->node_service_info_map[_key167];
                                    xfer += _val168.read(iprot);
                                }
                                xfer += iprot->readMapEnd();
                            }
                            isset_node_service_info_map = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            if (!isset_node_service_info_map)
                throw TProtocolException(TProtocolException::INVALID_DATA);
            return xfer;
        }

        uint32_t service_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("service_broadcast_req_body");

            xfer += oprot->writeFieldBegin("node_service_info_map", ::apache::thrift::protocol::T_MAP, 1);
            {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_service_info_map.size()));
                std::map<std::string, node_service_info> ::const_iterator _iter169;
                for (_iter169 = this->node_service_info_map.begin(); _iter169 != this->node_service_info_map.end(); ++_iter169)
                {
                    xfer += oprot->writeString(_iter169->first);
                    xfer += _iter169->second.write(oprot);
                }
                xfer += oprot->writeMapEnd();
            }
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(service_broadcast_req_body &a, service_broadcast_req_body &b) {
            using ::std::swap;
            swap(a.node_service_info_map, b.node_service_info_map);
        }

        service_broadcast_req_body::service_broadcast_req_body(const service_broadcast_req_body& other170) {
            node_service_info_map = other170.node_service_info_map;
        }
        service_broadcast_req_body& service_broadcast_req_body::operator=(const service_broadcast_req_body& other171) {
            node_service_info_map = other171.node_service_info_map;
            return *this;
        }
        void service_broadcast_req_body::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "service_broadcast_req_body(";
            out << "node_service_info_map=" << to_string(node_service_info_map);
            out << ")";
        }


        service_broadcast_req::~service_broadcast_req() throw() {
        }


        void service_broadcast_req::__set_body(const service_broadcast_req_body& val) {
            this->body = val;
        }
        std::ostream& operator<<(std::ostream& out, const service_broadcast_req& obj)
        {
            obj.printTo(out);
            return out;
        }


        uint32_t service_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

            ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
            uint32_t xfer = 0;
            std::string fname;
            ::apache::thrift::protocol::TType ftype;
            int16_t fid;

            xfer += iprot->readStructBegin(fname);

            using ::apache::thrift::protocol::TProtocolException;


            while (true)
            {
                xfer += iprot->readFieldBegin(fname, ftype, fid);
                if (ftype == ::apache::thrift::protocol::T_STOP) {
                    break;
                }
                switch (fid)
                {
                    case 1:
                        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                            xfer += this->body.read(iprot);
                            this->__isset.body = true;
                        } else {
                            xfer += iprot->skip(ftype);
                        }
                        break;
                    default:
                        xfer += iprot->skip(ftype);
                        break;
                }
                xfer += iprot->readFieldEnd();
            }

            xfer += iprot->readStructEnd();

            return xfer;
        }

        uint32_t service_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
            uint32_t xfer = 0;
            ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
            xfer += oprot->writeStructBegin("service_broadcast_req");

            xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
            xfer += this->body.write(oprot);
            xfer += oprot->writeFieldEnd();

            xfer += oprot->writeFieldStop();
            xfer += oprot->writeStructEnd();
            return xfer;
        }

        void swap(service_broadcast_req &a, service_broadcast_req &b) {
            using ::std::swap;
            swap(a.body, b.body);
            swap(a.__isset, b.__isset);
        }

        service_broadcast_req::service_broadcast_req(const service_broadcast_req& other172) {
            body = other172.body;
            __isset = other172.__isset;
        }
        service_broadcast_req& service_broadcast_req::operator=(const service_broadcast_req& other173) {
            body = other173.body;
            __isset = other173.__isset;
            return *this;
        }
        void service_broadcast_req::printTo(std::ostream& out) const {
            using ::apache::thrift::to_string;
            out << "service_broadcast_req(";
            out << "body=" << to_string(body);
            out << ")";
        }

    }} // namespace
