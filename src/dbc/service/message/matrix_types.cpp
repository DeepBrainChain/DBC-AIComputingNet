/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "matrix_types.h"

#include <algorithm>
#include <ostream>

namespace dbc {


    empty::~empty() throw() {
    }

    std::ostream& operator<<(std::ostream& out, const empty& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t empty::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            xfer += iprot->skip(ftype);
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t empty::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("empty");

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(empty &a, empty &b) {
        using ::std::swap;
        (void) a;
        (void) b;
    }

    empty::empty(const empty& other0) {
        (void) other0;
    }
    empty& empty::operator=(const empty& other1) {
        (void) other1;
        return *this;
    }
    void empty::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "empty(";
        out << ")";
    }


    network_address::~network_address() throw() {
    }


    void network_address::__set_ip(const std::string& val) {
        this->ip = val;
    }

    void network_address::__set_port(const int16_t val) {
        this->port = val;
    }
    std::ostream& operator<<(std::ostream& out, const network_address& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t network_address::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_ip = false;
        bool isset_port = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->ip);
                        isset_ip = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_I16) {
                        xfer += iprot->readI16(this->port);
                        isset_port = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_ip)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_port)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t network_address::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("network_address");

        xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->ip);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 2);
        xfer += oprot->writeI16(this->port);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(network_address &a, network_address &b) {
        using ::std::swap;
        swap(a.ip, b.ip);
        swap(a.port, b.port);
    }

    network_address::network_address(const network_address& other2) {
        ip = other2.ip;
        port = other2.port;
    }
    network_address& network_address::operator=(const network_address& other3) {
        ip = other3.ip;
        port = other3.port;
        return *this;
    }
    void network_address::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "network_address(";
        out << "ip=" << to_string(ip);
        out << ", " << "port=" << to_string(port);
        out << ")";
    }


    shake_hand_req::~shake_hand_req() throw() {
    }


    void shake_hand_req::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const shake_hand_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t shake_hand_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t shake_hand_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("shake_hand_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(shake_hand_req &a, shake_hand_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    shake_hand_req::shake_hand_req(const shake_hand_req& other4) {
        body = other4.body;
        __isset = other4.__isset;
    }
    shake_hand_req& shake_hand_req::operator=(const shake_hand_req& other5) {
        body = other5.body;
        __isset = other5.__isset;
        return *this;
    }
    void shake_hand_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "shake_hand_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    shake_hand_resp::~shake_hand_resp() throw() {
    }


    void shake_hand_resp::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const shake_hand_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t shake_hand_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t shake_hand_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("shake_hand_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(shake_hand_resp &a, shake_hand_resp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    shake_hand_resp::shake_hand_resp(const shake_hand_resp& other6) {
        body = other6.body;
        __isset = other6.__isset;
    }
    shake_hand_resp& shake_hand_resp::operator=(const shake_hand_resp& other7) {
        body = other7.body;
        __isset = other7.__isset;
        return *this;
    }
    void shake_hand_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "shake_hand_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    multisig_sign_item::~multisig_sign_item() throw() {
    }


    void multisig_sign_item::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void multisig_sign_item::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void multisig_sign_item::__set_sign(const std::string& val) {
        this->sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const multisig_sign_item& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t multisig_sign_item::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t multisig_sign_item::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("multisig_sign_item");

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(multisig_sign_item &a, multisig_sign_item &b) {
        using ::std::swap;
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
    }

    multisig_sign_item::multisig_sign_item(const multisig_sign_item& other8) {
        wallet = other8.wallet;
        nonce = other8.nonce;
        sign = other8.sign;
    }
    multisig_sign_item& multisig_sign_item::operator=(const multisig_sign_item& other9) {
        wallet = other9.wallet;
        nonce = other9.nonce;
        sign = other9.sign;
        return *this;
    }
    void multisig_sign_item::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "multisig_sign_item(";
        out << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ")";
    }


    node_list_images_req_data::~node_list_images_req_data() throw() {
    }


    void node_list_images_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_list_images_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_list_images_req_data::__set_image(const std::string& val) {
        this->image = val;
    }

    void node_list_images_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_list_images_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_list_images_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_list_images_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_list_images_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_list_images_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_list_images_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_list_images_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_list_images_req_data::__set_image_server(const std::vector<std::string> & val) {
        this->image_server = val;
        __isset.image_server = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_image = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size10;
                            ::apache::thrift::protocol::TType _etype13;
                            xfer += iprot->readListBegin(_etype13, _size10);
                            this->peer_nodes_list.resize(_size10);
                            uint32_t _i14;
                            for (_i14 = 0; _i14 < _size10; ++_i14)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i14]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->image);
                        isset_image = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size15;
                            ::apache::thrift::protocol::TType _etype18;
                            xfer += iprot->readListBegin(_etype18, _size15);
                            this->multisig_wallets.resize(_size15);
                            uint32_t _i19;
                            for (_i19 = 0; _i19 < _size15; ++_i19)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i19]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size20;
                            ::apache::thrift::protocol::TType _etype23;
                            xfer += iprot->readListBegin(_etype23, _size20);
                            this->multisig_signs.resize(_size20);
                            uint32_t _i24;
                            for (_i24 = 0; _i24 < _size20; ++_i24)
                            {
                                xfer += this->multisig_signs[_i24].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->image_server.clear();
                            uint32_t _size25;
                            ::apache::thrift::protocol::TType _etype28;
                            xfer += iprot->readListBegin(_etype28, _size25);
                            this->image_server.resize(_size25);
                            uint32_t _i29;
                            for (_i29 = 0; _i29 < _size25; ++_i29)
                            {
                                xfer += iprot->readString(this->image_server[_i29]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        this->__isset.image_server = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_image)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_images_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter30;
            for (_iter30 = this->peer_nodes_list.begin(); _iter30 != this->peer_nodes_list.end(); ++_iter30)
            {
                xfer += oprot->writeString((*_iter30));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->image);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter31;
            for (_iter31 = this->multisig_wallets.begin(); _iter31 != this->multisig_wallets.end(); ++_iter31)
            {
                xfer += oprot->writeString((*_iter31));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter32;
            for (_iter32 = this->multisig_signs.begin(); _iter32 != this->multisig_signs.end(); ++_iter32)
            {
                xfer += (*_iter32).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.image_server) {
            xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_LIST, 12);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->image_server.size()));
                std::vector<std::string> ::const_iterator _iter33;
                for (_iter33 = this->image_server.begin(); _iter33 != this->image_server.end(); ++_iter33)
                {
                    xfer += oprot->writeString((*_iter33));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_req_data &a, node_list_images_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.image, b.image);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.image_server, b.image_server);
        swap(a.__isset, b.__isset);
    }

    node_list_images_req_data::node_list_images_req_data(const node_list_images_req_data& other34) {
        peer_nodes_list = other34.peer_nodes_list;
        additional = other34.additional;
        image = other34.image;
        wallet = other34.wallet;
        nonce = other34.nonce;
        sign = other34.sign;
        multisig_wallets = other34.multisig_wallets;
        multisig_threshold = other34.multisig_threshold;
        multisig_signs = other34.multisig_signs;
        session_id = other34.session_id;
        session_id_sign = other34.session_id_sign;
        image_server = other34.image_server;
        __isset = other34.__isset;
    }
    node_list_images_req_data& node_list_images_req_data::operator=(const node_list_images_req_data& other35) {
        peer_nodes_list = other35.peer_nodes_list;
        additional = other35.additional;
        image = other35.image;
        wallet = other35.wallet;
        nonce = other35.nonce;
        sign = other35.sign;
        multisig_wallets = other35.multisig_wallets;
        multisig_threshold = other35.multisig_threshold;
        multisig_signs = other35.multisig_signs;
        session_id = other35.session_id;
        session_id_sign = other35.session_id_sign;
        image_server = other35.image_server;
        __isset = other35.__isset;
        return *this;
    }
    void node_list_images_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "image=" << to_string(image);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
        out << ")";
    }


    node_list_images_req_body::~node_list_images_req_body() throw() {
    }


    void node_list_images_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_images_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_req_body &a, node_list_images_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_images_req_body::node_list_images_req_body(const node_list_images_req_body& other36) {
        data = other36.data;
    }
    node_list_images_req_body& node_list_images_req_body::operator=(const node_list_images_req_body& other37) {
        data = other37.data;
        return *this;
    }
    void node_list_images_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_images_req::~node_list_images_req() throw() {
    }


    void node_list_images_req::__set_body(const node_list_images_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_images_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_req &a, node_list_images_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_images_req::node_list_images_req(const node_list_images_req& other38) {
        body = other38.body;
        __isset = other38.__isset;
    }
    node_list_images_req& node_list_images_req::operator=(const node_list_images_req& other39) {
        body = other39.body;
        __isset = other39.__isset;
        return *this;
    }
    void node_list_images_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_images_rsp_body::~node_list_images_rsp_body() throw() {
    }


    void node_list_images_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_images_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_rsp_body &a, node_list_images_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_images_rsp_body::node_list_images_rsp_body(const node_list_images_rsp_body& other40) {
        data = other40.data;
    }
    node_list_images_rsp_body& node_list_images_rsp_body::operator=(const node_list_images_rsp_body& other41) {
        data = other41.data;
        return *this;
    }
    void node_list_images_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_images_rsp::~node_list_images_rsp() throw() {
    }


    void node_list_images_rsp::__set_body(const node_list_images_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_images_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_rsp &a, node_list_images_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_images_rsp::node_list_images_rsp(const node_list_images_rsp& other42) {
        body = other42.body;
        __isset = other42.__isset;
    }
    node_list_images_rsp& node_list_images_rsp::operator=(const node_list_images_rsp& other43) {
        body = other43.body;
        __isset = other43.__isset;
        return *this;
    }
    void node_list_images_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_download_image_req_data::~node_download_image_req_data() throw() {
    }


    void node_download_image_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_download_image_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_download_image_req_data::__set_image(const std::string& val) {
        this->image = val;
    }

    void node_download_image_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_download_image_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_download_image_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_download_image_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_download_image_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_download_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_download_image_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_download_image_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_download_image_req_data::__set_image_server(const std::vector<std::string> & val) {
        this->image_server = val;
        __isset.image_server = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_image = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size44;
                            ::apache::thrift::protocol::TType _etype47;
                            xfer += iprot->readListBegin(_etype47, _size44);
                            this->peer_nodes_list.resize(_size44);
                            uint32_t _i48;
                            for (_i48 = 0; _i48 < _size44; ++_i48)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i48]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->image);
                        isset_image = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size49;
                            ::apache::thrift::protocol::TType _etype52;
                            xfer += iprot->readListBegin(_etype52, _size49);
                            this->multisig_wallets.resize(_size49);
                            uint32_t _i53;
                            for (_i53 = 0; _i53 < _size49; ++_i53)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i53]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size54;
                            ::apache::thrift::protocol::TType _etype57;
                            xfer += iprot->readListBegin(_etype57, _size54);
                            this->multisig_signs.resize(_size54);
                            uint32_t _i58;
                            for (_i58 = 0; _i58 < _size54; ++_i58)
                            {
                                xfer += this->multisig_signs[_i58].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->image_server.clear();
                            uint32_t _size59;
                            ::apache::thrift::protocol::TType _etype62;
                            xfer += iprot->readListBegin(_etype62, _size59);
                            this->image_server.resize(_size59);
                            uint32_t _i63;
                            for (_i63 = 0; _i63 < _size59; ++_i63)
                            {
                                xfer += iprot->readString(this->image_server[_i63]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        this->__isset.image_server = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_image)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter64;
            for (_iter64 = this->peer_nodes_list.begin(); _iter64 != this->peer_nodes_list.end(); ++_iter64)
            {
                xfer += oprot->writeString((*_iter64));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->image);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter65;
            for (_iter65 = this->multisig_wallets.begin(); _iter65 != this->multisig_wallets.end(); ++_iter65)
            {
                xfer += oprot->writeString((*_iter65));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter66;
            for (_iter66 = this->multisig_signs.begin(); _iter66 != this->multisig_signs.end(); ++_iter66)
            {
                xfer += (*_iter66).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.image_server) {
            xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_LIST, 12);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->image_server.size()));
                std::vector<std::string> ::const_iterator _iter67;
                for (_iter67 = this->image_server.begin(); _iter67 != this->image_server.end(); ++_iter67)
                {
                    xfer += oprot->writeString((*_iter67));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_req_data &a, node_download_image_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.image, b.image);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.image_server, b.image_server);
        swap(a.__isset, b.__isset);
    }

    node_download_image_req_data::node_download_image_req_data(const node_download_image_req_data& other68) {
        peer_nodes_list = other68.peer_nodes_list;
        additional = other68.additional;
        image = other68.image;
        wallet = other68.wallet;
        nonce = other68.nonce;
        sign = other68.sign;
        multisig_wallets = other68.multisig_wallets;
        multisig_threshold = other68.multisig_threshold;
        multisig_signs = other68.multisig_signs;
        session_id = other68.session_id;
        session_id_sign = other68.session_id_sign;
        image_server = other68.image_server;
        __isset = other68.__isset;
    }
    node_download_image_req_data& node_download_image_req_data::operator=(const node_download_image_req_data& other69) {
        peer_nodes_list = other69.peer_nodes_list;
        additional = other69.additional;
        image = other69.image;
        wallet = other69.wallet;
        nonce = other69.nonce;
        sign = other69.sign;
        multisig_wallets = other69.multisig_wallets;
        multisig_threshold = other69.multisig_threshold;
        multisig_signs = other69.multisig_signs;
        session_id = other69.session_id;
        session_id_sign = other69.session_id_sign;
        image_server = other69.image_server;
        __isset = other69.__isset;
        return *this;
    }
    void node_download_image_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "image=" << to_string(image);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
        out << ")";
    }


    node_download_image_req_body::~node_download_image_req_body() throw() {
    }


    void node_download_image_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_req_body &a, node_download_image_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_download_image_req_body::node_download_image_req_body(const node_download_image_req_body& other70) {
        data = other70.data;
    }
    node_download_image_req_body& node_download_image_req_body::operator=(const node_download_image_req_body& other71) {
        data = other71.data;
        return *this;
    }
    void node_download_image_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_download_image_req::~node_download_image_req() throw() {
    }


    void node_download_image_req::__set_body(const node_download_image_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_download_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_req &a, node_download_image_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_download_image_req::node_download_image_req(const node_download_image_req& other72) {
        body = other72.body;
        __isset = other72.__isset;
    }
    node_download_image_req& node_download_image_req::operator=(const node_download_image_req& other73) {
        body = other73.body;
        __isset = other73.__isset;
        return *this;
    }
    void node_download_image_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_download_image_rsp_body::~node_download_image_rsp_body() throw() {
    }


    void node_download_image_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_rsp_body &a, node_download_image_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_download_image_rsp_body::node_download_image_rsp_body(const node_download_image_rsp_body& other74) {
        data = other74.data;
    }
    node_download_image_rsp_body& node_download_image_rsp_body::operator=(const node_download_image_rsp_body& other75) {
        data = other75.data;
        return *this;
    }
    void node_download_image_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_download_image_rsp::~node_download_image_rsp() throw() {
    }


    void node_download_image_rsp::__set_body(const node_download_image_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_download_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_rsp &a, node_download_image_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_download_image_rsp::node_download_image_rsp(const node_download_image_rsp& other76) {
        body = other76.body;
        __isset = other76.__isset;
    }
    node_download_image_rsp& node_download_image_rsp::operator=(const node_download_image_rsp& other77) {
        body = other77.body;
        __isset = other77.__isset;
        return *this;
    }
    void node_download_image_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_upload_image_req_data::~node_upload_image_req_data() throw() {
    }


    void node_upload_image_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_upload_image_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_upload_image_req_data::__set_image(const std::string& val) {
        this->image = val;
    }

    void node_upload_image_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_upload_image_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_upload_image_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_upload_image_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_upload_image_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_upload_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_upload_image_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_upload_image_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_upload_image_req_data::__set_image_server(const std::vector<std::string> & val) {
        this->image_server = val;
        __isset.image_server = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_image = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size78;
                            ::apache::thrift::protocol::TType _etype81;
                            xfer += iprot->readListBegin(_etype81, _size78);
                            this->peer_nodes_list.resize(_size78);
                            uint32_t _i82;
                            for (_i82 = 0; _i82 < _size78; ++_i82)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i82]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->image);
                        isset_image = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size83;
                            ::apache::thrift::protocol::TType _etype86;
                            xfer += iprot->readListBegin(_etype86, _size83);
                            this->multisig_wallets.resize(_size83);
                            uint32_t _i87;
                            for (_i87 = 0; _i87 < _size83; ++_i87)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i87]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size88;
                            ::apache::thrift::protocol::TType _etype91;
                            xfer += iprot->readListBegin(_etype91, _size88);
                            this->multisig_signs.resize(_size88);
                            uint32_t _i92;
                            for (_i92 = 0; _i92 < _size88; ++_i92)
                            {
                                xfer += this->multisig_signs[_i92].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->image_server.clear();
                            uint32_t _size93;
                            ::apache::thrift::protocol::TType _etype96;
                            xfer += iprot->readListBegin(_etype96, _size93);
                            this->image_server.resize(_size93);
                            uint32_t _i97;
                            for (_i97 = 0; _i97 < _size93; ++_i97)
                            {
                                xfer += iprot->readString(this->image_server[_i97]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        this->__isset.image_server = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_image)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter98;
            for (_iter98 = this->peer_nodes_list.begin(); _iter98 != this->peer_nodes_list.end(); ++_iter98)
            {
                xfer += oprot->writeString((*_iter98));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->image);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter99;
            for (_iter99 = this->multisig_wallets.begin(); _iter99 != this->multisig_wallets.end(); ++_iter99)
            {
                xfer += oprot->writeString((*_iter99));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter100;
            for (_iter100 = this->multisig_signs.begin(); _iter100 != this->multisig_signs.end(); ++_iter100)
            {
                xfer += (*_iter100).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.image_server) {
            xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_LIST, 12);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->image_server.size()));
                std::vector<std::string> ::const_iterator _iter101;
                for (_iter101 = this->image_server.begin(); _iter101 != this->image_server.end(); ++_iter101)
                {
                    xfer += oprot->writeString((*_iter101));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_req_data &a, node_upload_image_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.image, b.image);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.image_server, b.image_server);
        swap(a.__isset, b.__isset);
    }

    node_upload_image_req_data::node_upload_image_req_data(const node_upload_image_req_data& other102) {
        peer_nodes_list = other102.peer_nodes_list;
        additional = other102.additional;
        image = other102.image;
        wallet = other102.wallet;
        nonce = other102.nonce;
        sign = other102.sign;
        multisig_wallets = other102.multisig_wallets;
        multisig_threshold = other102.multisig_threshold;
        multisig_signs = other102.multisig_signs;
        session_id = other102.session_id;
        session_id_sign = other102.session_id_sign;
        image_server = other102.image_server;
        __isset = other102.__isset;
    }
    node_upload_image_req_data& node_upload_image_req_data::operator=(const node_upload_image_req_data& other103) {
        peer_nodes_list = other103.peer_nodes_list;
        additional = other103.additional;
        image = other103.image;
        wallet = other103.wallet;
        nonce = other103.nonce;
        sign = other103.sign;
        multisig_wallets = other103.multisig_wallets;
        multisig_threshold = other103.multisig_threshold;
        multisig_signs = other103.multisig_signs;
        session_id = other103.session_id;
        session_id_sign = other103.session_id_sign;
        image_server = other103.image_server;
        __isset = other103.__isset;
        return *this;
    }
    void node_upload_image_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "image=" << to_string(image);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
        out << ")";
    }


    node_upload_image_req_body::~node_upload_image_req_body() throw() {
    }


    void node_upload_image_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_req_body &a, node_upload_image_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_upload_image_req_body::node_upload_image_req_body(const node_upload_image_req_body& other104) {
        data = other104.data;
    }
    node_upload_image_req_body& node_upload_image_req_body::operator=(const node_upload_image_req_body& other105) {
        data = other105.data;
        return *this;
    }
    void node_upload_image_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_upload_image_req::~node_upload_image_req() throw() {
    }


    void node_upload_image_req::__set_body(const node_upload_image_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_upload_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_req &a, node_upload_image_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_upload_image_req::node_upload_image_req(const node_upload_image_req& other106) {
        body = other106.body;
        __isset = other106.__isset;
    }
    node_upload_image_req& node_upload_image_req::operator=(const node_upload_image_req& other107) {
        body = other107.body;
        __isset = other107.__isset;
        return *this;
    }
    void node_upload_image_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_upload_image_rsp_body::~node_upload_image_rsp_body() throw() {
    }


    void node_upload_image_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_rsp_body &a, node_upload_image_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_upload_image_rsp_body::node_upload_image_rsp_body(const node_upload_image_rsp_body& other108) {
        data = other108.data;
    }
    node_upload_image_rsp_body& node_upload_image_rsp_body::operator=(const node_upload_image_rsp_body& other109) {
        data = other109.data;
        return *this;
    }
    void node_upload_image_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_upload_image_rsp::~node_upload_image_rsp() throw() {
    }


    void node_upload_image_rsp::__set_body(const node_upload_image_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_upload_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_rsp &a, node_upload_image_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_upload_image_rsp::node_upload_image_rsp(const node_upload_image_rsp& other110) {
        body = other110.body;
        __isset = other110.__isset;
    }
    node_upload_image_rsp& node_upload_image_rsp::operator=(const node_upload_image_rsp& other111) {
        body = other111.body;
        __isset = other111.__isset;
        return *this;
    }
    void node_upload_image_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_task_req_data::~node_list_task_req_data() throw() {
    }


    void node_list_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_list_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_list_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_list_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_list_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_list_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_list_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_list_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_list_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_list_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_list_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size112;
                            ::apache::thrift::protocol::TType _etype115;
                            xfer += iprot->readListBegin(_etype115, _size112);
                            this->peer_nodes_list.resize(_size112);
                            uint32_t _i116;
                            for (_i116 = 0; _i116 < _size112; ++_i116)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i116]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size117;
                            ::apache::thrift::protocol::TType _etype120;
                            xfer += iprot->readListBegin(_etype120, _size117);
                            this->multisig_wallets.resize(_size117);
                            uint32_t _i121;
                            for (_i121 = 0; _i121 < _size117; ++_i121)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i121]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size122;
                            ::apache::thrift::protocol::TType _etype125;
                            xfer += iprot->readListBegin(_etype125, _size122);
                            this->multisig_signs.resize(_size122);
                            uint32_t _i126;
                            for (_i126 = 0; _i126 < _size122; ++_i126)
                            {
                                xfer += this->multisig_signs[_i126].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter127;
            for (_iter127 = this->peer_nodes_list.begin(); _iter127 != this->peer_nodes_list.end(); ++_iter127)
            {
                xfer += oprot->writeString((*_iter127));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter128;
            for (_iter128 = this->multisig_wallets.begin(); _iter128 != this->multisig_wallets.end(); ++_iter128)
            {
                xfer += oprot->writeString((*_iter128));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter129;
            for (_iter129 = this->multisig_signs.begin(); _iter129 != this->multisig_signs.end(); ++_iter129)
            {
                xfer += (*_iter129).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req_data &a, node_list_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_list_task_req_data::node_list_task_req_data(const node_list_task_req_data& other130) {
        task_id = other130.task_id;
        peer_nodes_list = other130.peer_nodes_list;
        additional = other130.additional;
        wallet = other130.wallet;
        nonce = other130.nonce;
        sign = other130.sign;
        multisig_wallets = other130.multisig_wallets;
        multisig_threshold = other130.multisig_threshold;
        multisig_signs = other130.multisig_signs;
        session_id = other130.session_id;
        session_id_sign = other130.session_id_sign;
    }
    node_list_task_req_data& node_list_task_req_data::operator=(const node_list_task_req_data& other131) {
        task_id = other131.task_id;
        peer_nodes_list = other131.peer_nodes_list;
        additional = other131.additional;
        wallet = other131.wallet;
        nonce = other131.nonce;
        sign = other131.sign;
        multisig_wallets = other131.multisig_wallets;
        multisig_threshold = other131.multisig_threshold;
        multisig_signs = other131.multisig_signs;
        session_id = other131.session_id;
        session_id_sign = other131.session_id_sign;
        return *this;
    }
    void node_list_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_list_task_req_body::~node_list_task_req_body() throw() {
    }


    void node_list_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req_body &a, node_list_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_task_req_body::node_list_task_req_body(const node_list_task_req_body& other132) {
        data = other132.data;
    }
    node_list_task_req_body& node_list_task_req_body::operator=(const node_list_task_req_body& other133) {
        data = other133.data;
        return *this;
    }
    void node_list_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_task_req::~node_list_task_req() throw() {
    }


    void node_list_task_req::__set_body(const node_list_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req &a, node_list_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_task_req::node_list_task_req(const node_list_task_req& other134) {
        body = other134.body;
        __isset = other134.__isset;
    }
    node_list_task_req& node_list_task_req::operator=(const node_list_task_req& other135) {
        body = other135.body;
        __isset = other135.__isset;
        return *this;
    }
    void node_list_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_task_rsp_body::~node_list_task_rsp_body() throw() {
    }


    void node_list_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_rsp_body &a, node_list_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_task_rsp_body::node_list_task_rsp_body(const node_list_task_rsp_body& other136) {
        data = other136.data;
    }
    node_list_task_rsp_body& node_list_task_rsp_body::operator=(const node_list_task_rsp_body& other137) {
        data = other137.data;
        return *this;
    }
    void node_list_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_task_rsp::~node_list_task_rsp() throw() {
    }


    void node_list_task_rsp::__set_body(const node_list_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_rsp &a, node_list_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_task_rsp::node_list_task_rsp(const node_list_task_rsp& other138) {
        body = other138.body;
        __isset = other138.__isset;
    }
    node_list_task_rsp& node_list_task_rsp::operator=(const node_list_task_rsp& other139) {
        body = other139.body;
        __isset = other139.__isset;
        return *this;
    }
    void node_list_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_task_req_data::~node_create_task_req_data() throw() {
    }


    void node_create_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_create_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_create_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_create_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_create_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_create_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_create_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_create_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_create_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_create_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_create_task_req_data::__set_image_server(const std::vector<std::string> & val) {
        this->image_server = val;
        __isset.image_server = true;
    }

    void node_create_task_req_data::__set_custom_image_name(const std::string& val) {
        this->custom_image_name = val;
        __isset.custom_image_name = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size140;
                            ::apache::thrift::protocol::TType _etype143;
                            xfer += iprot->readListBegin(_etype143, _size140);
                            this->peer_nodes_list.resize(_size140);
                            uint32_t _i144;
                            for (_i144 = 0; _i144 < _size140; ++_i144)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i144]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size145;
                            ::apache::thrift::protocol::TType _etype148;
                            xfer += iprot->readListBegin(_etype148, _size145);
                            this->multisig_wallets.resize(_size145);
                            uint32_t _i149;
                            for (_i149 = 0; _i149 < _size145; ++_i149)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i149]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size150;
                            ::apache::thrift::protocol::TType _etype153;
                            xfer += iprot->readListBegin(_etype153, _size150);
                            this->multisig_signs.resize(_size150);
                            uint32_t _i154;
                            for (_i154 = 0; _i154 < _size150; ++_i154)
                            {
                                xfer += this->multisig_signs[_i154].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->image_server.clear();
                            uint32_t _size155;
                            ::apache::thrift::protocol::TType _etype158;
                            xfer += iprot->readListBegin(_etype158, _size155);
                            this->image_server.resize(_size155);
                            uint32_t _i159;
                            for (_i159 = 0; _i159 < _size155; ++_i159)
                            {
                                xfer += iprot->readString(this->image_server[_i159]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        this->__isset.image_server = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->custom_image_name);
                        this->__isset.custom_image_name = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter160;
            for (_iter160 = this->peer_nodes_list.begin(); _iter160 != this->peer_nodes_list.end(); ++_iter160)
            {
                xfer += oprot->writeString((*_iter160));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter161;
            for (_iter161 = this->multisig_wallets.begin(); _iter161 != this->multisig_wallets.end(); ++_iter161)
            {
                xfer += oprot->writeString((*_iter161));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter162;
            for (_iter162 = this->multisig_signs.begin(); _iter162 != this->multisig_signs.end(); ++_iter162)
            {
                xfer += (*_iter162).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.image_server) {
            xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_LIST, 11);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->image_server.size()));
                std::vector<std::string> ::const_iterator _iter163;
                for (_iter163 = this->image_server.begin(); _iter163 != this->image_server.end(); ++_iter163)
                {
                    xfer += oprot->writeString((*_iter163));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        if (this->__isset.custom_image_name) {
            xfer += oprot->writeFieldBegin("custom_image_name", ::apache::thrift::protocol::T_STRING, 12);
            xfer += oprot->writeString(this->custom_image_name);
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req_data &a, node_create_task_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.image_server, b.image_server);
        swap(a.custom_image_name, b.custom_image_name);
        swap(a.__isset, b.__isset);
    }

    node_create_task_req_data::node_create_task_req_data(const node_create_task_req_data& other164) {
        peer_nodes_list = other164.peer_nodes_list;
        additional = other164.additional;
        wallet = other164.wallet;
        nonce = other164.nonce;
        sign = other164.sign;
        multisig_wallets = other164.multisig_wallets;
        multisig_threshold = other164.multisig_threshold;
        multisig_signs = other164.multisig_signs;
        session_id = other164.session_id;
        session_id_sign = other164.session_id_sign;
        image_server = other164.image_server;
        custom_image_name = other164.custom_image_name;
        __isset = other164.__isset;
    }
    node_create_task_req_data& node_create_task_req_data::operator=(const node_create_task_req_data& other165) {
        peer_nodes_list = other165.peer_nodes_list;
        additional = other165.additional;
        wallet = other165.wallet;
        nonce = other165.nonce;
        sign = other165.sign;
        multisig_wallets = other165.multisig_wallets;
        multisig_threshold = other165.multisig_threshold;
        multisig_signs = other165.multisig_signs;
        session_id = other165.session_id;
        session_id_sign = other165.session_id_sign;
        image_server = other165.image_server;
        custom_image_name = other165.custom_image_name;
        __isset = other165.__isset;
        return *this;
    }
    void node_create_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
        out << ", " << "custom_image_name="; (__isset.custom_image_name ? (out << to_string(custom_image_name)) : (out << "<null>"));
        out << ")";
    }


    node_create_task_req_body::~node_create_task_req_body() throw() {
    }


    void node_create_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req_body &a, node_create_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_task_req_body::node_create_task_req_body(const node_create_task_req_body& other166) {
        data = other166.data;
    }
    node_create_task_req_body& node_create_task_req_body::operator=(const node_create_task_req_body& other167) {
        data = other167.data;
        return *this;
    }
    void node_create_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_task_req::~node_create_task_req() throw() {
    }


    void node_create_task_req::__set_body(const node_create_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req &a, node_create_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_task_req::node_create_task_req(const node_create_task_req& other168) {
        body = other168.body;
        __isset = other168.__isset;
    }
    node_create_task_req& node_create_task_req::operator=(const node_create_task_req& other169) {
        body = other169.body;
        __isset = other169.__isset;
        return *this;
    }
    void node_create_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_task_rsp_body::~node_create_task_rsp_body() throw() {
    }


    void node_create_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_rsp_body &a, node_create_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_task_rsp_body::node_create_task_rsp_body(const node_create_task_rsp_body& other170) {
        data = other170.data;
    }
    node_create_task_rsp_body& node_create_task_rsp_body::operator=(const node_create_task_rsp_body& other171) {
        data = other171.data;
        return *this;
    }
    void node_create_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_task_rsp::~node_create_task_rsp() throw() {
    }


    void node_create_task_rsp::__set_body(const node_create_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_rsp &a, node_create_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_task_rsp::node_create_task_rsp(const node_create_task_rsp& other172) {
        body = other172.body;
        __isset = other172.__isset;
    }
    node_create_task_rsp& node_create_task_rsp::operator=(const node_create_task_rsp& other173) {
        body = other173.body;
        __isset = other173.__isset;
        return *this;
    }
    void node_create_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_start_task_req_data::~node_start_task_req_data() throw() {
    }


    void node_start_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_start_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_start_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_start_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_start_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_start_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_start_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_start_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_start_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_start_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_start_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size174;
                            ::apache::thrift::protocol::TType _etype177;
                            xfer += iprot->readListBegin(_etype177, _size174);
                            this->peer_nodes_list.resize(_size174);
                            uint32_t _i178;
                            for (_i178 = 0; _i178 < _size174; ++_i178)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i178]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size179;
                            ::apache::thrift::protocol::TType _etype182;
                            xfer += iprot->readListBegin(_etype182, _size179);
                            this->multisig_wallets.resize(_size179);
                            uint32_t _i183;
                            for (_i183 = 0; _i183 < _size179; ++_i183)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i183]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size184;
                            ::apache::thrift::protocol::TType _etype187;
                            xfer += iprot->readListBegin(_etype187, _size184);
                            this->multisig_signs.resize(_size184);
                            uint32_t _i188;
                            for (_i188 = 0; _i188 < _size184; ++_i188)
                            {
                                xfer += this->multisig_signs[_i188].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter189;
            for (_iter189 = this->peer_nodes_list.begin(); _iter189 != this->peer_nodes_list.end(); ++_iter189)
            {
                xfer += oprot->writeString((*_iter189));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter190;
            for (_iter190 = this->multisig_wallets.begin(); _iter190 != this->multisig_wallets.end(); ++_iter190)
            {
                xfer += oprot->writeString((*_iter190));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter191;
            for (_iter191 = this->multisig_signs.begin(); _iter191 != this->multisig_signs.end(); ++_iter191)
            {
                xfer += (*_iter191).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req_data &a, node_start_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_start_task_req_data::node_start_task_req_data(const node_start_task_req_data& other192) {
        task_id = other192.task_id;
        peer_nodes_list = other192.peer_nodes_list;
        additional = other192.additional;
        wallet = other192.wallet;
        nonce = other192.nonce;
        sign = other192.sign;
        multisig_wallets = other192.multisig_wallets;
        multisig_threshold = other192.multisig_threshold;
        multisig_signs = other192.multisig_signs;
        session_id = other192.session_id;
        session_id_sign = other192.session_id_sign;
    }
    node_start_task_req_data& node_start_task_req_data::operator=(const node_start_task_req_data& other193) {
        task_id = other193.task_id;
        peer_nodes_list = other193.peer_nodes_list;
        additional = other193.additional;
        wallet = other193.wallet;
        nonce = other193.nonce;
        sign = other193.sign;
        multisig_wallets = other193.multisig_wallets;
        multisig_threshold = other193.multisig_threshold;
        multisig_signs = other193.multisig_signs;
        session_id = other193.session_id;
        session_id_sign = other193.session_id_sign;
        return *this;
    }
    void node_start_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_start_task_req_body::~node_start_task_req_body() throw() {
    }


    void node_start_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req_body &a, node_start_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_start_task_req_body::node_start_task_req_body(const node_start_task_req_body& other194) {
        data = other194.data;
    }
    node_start_task_req_body& node_start_task_req_body::operator=(const node_start_task_req_body& other195) {
        data = other195.data;
        return *this;
    }
    void node_start_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_start_task_req::~node_start_task_req() throw() {
    }


    void node_start_task_req::__set_body(const node_start_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_start_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req &a, node_start_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_start_task_req::node_start_task_req(const node_start_task_req& other196) {
        body = other196.body;
        __isset = other196.__isset;
    }
    node_start_task_req& node_start_task_req::operator=(const node_start_task_req& other197) {
        body = other197.body;
        __isset = other197.__isset;
        return *this;
    }
    void node_start_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_start_task_rsp_body::~node_start_task_rsp_body() throw() {
    }


    void node_start_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_rsp_body &a, node_start_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_start_task_rsp_body::node_start_task_rsp_body(const node_start_task_rsp_body& other198) {
        data = other198.data;
    }
    node_start_task_rsp_body& node_start_task_rsp_body::operator=(const node_start_task_rsp_body& other199) {
        data = other199.data;
        return *this;
    }
    void node_start_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_start_task_rsp::~node_start_task_rsp() throw() {
    }


    void node_start_task_rsp::__set_body(const node_start_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_start_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_rsp &a, node_start_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_start_task_rsp::node_start_task_rsp(const node_start_task_rsp& other200) {
        body = other200.body;
        __isset = other200.__isset;
    }
    node_start_task_rsp& node_start_task_rsp::operator=(const node_start_task_rsp& other201) {
        body = other201.body;
        __isset = other201.__isset;
        return *this;
    }
    void node_start_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_task_req_data::~node_stop_task_req_data() throw() {
    }


    void node_stop_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_stop_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_stop_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_stop_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_stop_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_stop_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_stop_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_stop_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_stop_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_stop_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_stop_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size202;
                            ::apache::thrift::protocol::TType _etype205;
                            xfer += iprot->readListBegin(_etype205, _size202);
                            this->peer_nodes_list.resize(_size202);
                            uint32_t _i206;
                            for (_i206 = 0; _i206 < _size202; ++_i206)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i206]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size207;
                            ::apache::thrift::protocol::TType _etype210;
                            xfer += iprot->readListBegin(_etype210, _size207);
                            this->multisig_wallets.resize(_size207);
                            uint32_t _i211;
                            for (_i211 = 0; _i211 < _size207; ++_i211)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i211]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size212;
                            ::apache::thrift::protocol::TType _etype215;
                            xfer += iprot->readListBegin(_etype215, _size212);
                            this->multisig_signs.resize(_size212);
                            uint32_t _i216;
                            for (_i216 = 0; _i216 < _size212; ++_i216)
                            {
                                xfer += this->multisig_signs[_i216].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter217;
            for (_iter217 = this->peer_nodes_list.begin(); _iter217 != this->peer_nodes_list.end(); ++_iter217)
            {
                xfer += oprot->writeString((*_iter217));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter218;
            for (_iter218 = this->multisig_wallets.begin(); _iter218 != this->multisig_wallets.end(); ++_iter218)
            {
                xfer += oprot->writeString((*_iter218));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter219;
            for (_iter219 = this->multisig_signs.begin(); _iter219 != this->multisig_signs.end(); ++_iter219)
            {
                xfer += (*_iter219).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req_data &a, node_stop_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_stop_task_req_data::node_stop_task_req_data(const node_stop_task_req_data& other220) {
        task_id = other220.task_id;
        peer_nodes_list = other220.peer_nodes_list;
        additional = other220.additional;
        wallet = other220.wallet;
        nonce = other220.nonce;
        sign = other220.sign;
        multisig_wallets = other220.multisig_wallets;
        multisig_threshold = other220.multisig_threshold;
        multisig_signs = other220.multisig_signs;
        session_id = other220.session_id;
        session_id_sign = other220.session_id_sign;
    }
    node_stop_task_req_data& node_stop_task_req_data::operator=(const node_stop_task_req_data& other221) {
        task_id = other221.task_id;
        peer_nodes_list = other221.peer_nodes_list;
        additional = other221.additional;
        wallet = other221.wallet;
        nonce = other221.nonce;
        sign = other221.sign;
        multisig_wallets = other221.multisig_wallets;
        multisig_threshold = other221.multisig_threshold;
        multisig_signs = other221.multisig_signs;
        session_id = other221.session_id;
        session_id_sign = other221.session_id_sign;
        return *this;
    }
    void node_stop_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_stop_task_req_body::~node_stop_task_req_body() throw() {
    }


    void node_stop_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req_body &a, node_stop_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_task_req_body::node_stop_task_req_body(const node_stop_task_req_body& other222) {
        data = other222.data;
    }
    node_stop_task_req_body& node_stop_task_req_body::operator=(const node_stop_task_req_body& other223) {
        data = other223.data;
        return *this;
    }
    void node_stop_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_task_req::~node_stop_task_req() throw() {
    }


    void node_stop_task_req::__set_body(const node_stop_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req &a, node_stop_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_task_req::node_stop_task_req(const node_stop_task_req& other224) {
        body = other224.body;
        __isset = other224.__isset;
    }
    node_stop_task_req& node_stop_task_req::operator=(const node_stop_task_req& other225) {
        body = other225.body;
        __isset = other225.__isset;
        return *this;
    }
    void node_stop_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_task_rsp_body::~node_stop_task_rsp_body() throw() {
    }


    void node_stop_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_rsp_body &a, node_stop_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_task_rsp_body::node_stop_task_rsp_body(const node_stop_task_rsp_body& other226) {
        data = other226.data;
    }
    node_stop_task_rsp_body& node_stop_task_rsp_body::operator=(const node_stop_task_rsp_body& other227) {
        data = other227.data;
        return *this;
    }
    void node_stop_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_task_rsp::~node_stop_task_rsp() throw() {
    }


    void node_stop_task_rsp::__set_body(const node_stop_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_rsp &a, node_stop_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_task_rsp::node_stop_task_rsp(const node_stop_task_rsp& other228) {
        body = other228.body;
        __isset = other228.__isset;
    }
    node_stop_task_rsp& node_stop_task_rsp::operator=(const node_stop_task_rsp& other229) {
        body = other229.body;
        __isset = other229.__isset;
        return *this;
    }
    void node_stop_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_restart_task_req_data::~node_restart_task_req_data() throw() {
    }


    void node_restart_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_restart_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_restart_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_restart_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_restart_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_restart_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_restart_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_restart_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_restart_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_restart_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_restart_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_restart_task_req_data::__set_force_reboot(const int16_t val) {
        this->force_reboot = val;
        __isset.force_reboot = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size230;
                            ::apache::thrift::protocol::TType _etype233;
                            xfer += iprot->readListBegin(_etype233, _size230);
                            this->peer_nodes_list.resize(_size230);
                            uint32_t _i234;
                            for (_i234 = 0; _i234 < _size230; ++_i234)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i234]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size235;
                            ::apache::thrift::protocol::TType _etype238;
                            xfer += iprot->readListBegin(_etype238, _size235);
                            this->multisig_wallets.resize(_size235);
                            uint32_t _i239;
                            for (_i239 = 0; _i239 < _size235; ++_i239)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i239]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size240;
                            ::apache::thrift::protocol::TType _etype243;
                            xfer += iprot->readListBegin(_etype243, _size240);
                            this->multisig_signs.resize(_size240);
                            uint32_t _i244;
                            for (_i244 = 0; _i244 < _size240; ++_i244)
                            {
                                xfer += this->multisig_signs[_i244].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_I16) {
                        xfer += iprot->readI16(this->force_reboot);
                        this->__isset.force_reboot = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter245;
            for (_iter245 = this->peer_nodes_list.begin(); _iter245 != this->peer_nodes_list.end(); ++_iter245)
            {
                xfer += oprot->writeString((*_iter245));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter246;
            for (_iter246 = this->multisig_wallets.begin(); _iter246 != this->multisig_wallets.end(); ++_iter246)
            {
                xfer += oprot->writeString((*_iter246));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter247;
            for (_iter247 = this->multisig_signs.begin(); _iter247 != this->multisig_signs.end(); ++_iter247)
            {
                xfer += (*_iter247).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.force_reboot) {
            xfer += oprot->writeFieldBegin("force_reboot", ::apache::thrift::protocol::T_I16, 12);
            xfer += oprot->writeI16(this->force_reboot);
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req_data &a, node_restart_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.force_reboot, b.force_reboot);
        swap(a.__isset, b.__isset);
    }

    node_restart_task_req_data::node_restart_task_req_data(const node_restart_task_req_data& other248) {
        task_id = other248.task_id;
        peer_nodes_list = other248.peer_nodes_list;
        additional = other248.additional;
        wallet = other248.wallet;
        nonce = other248.nonce;
        sign = other248.sign;
        multisig_wallets = other248.multisig_wallets;
        multisig_threshold = other248.multisig_threshold;
        multisig_signs = other248.multisig_signs;
        session_id = other248.session_id;
        session_id_sign = other248.session_id_sign;
        force_reboot = other248.force_reboot;
        __isset = other248.__isset;
    }
    node_restart_task_req_data& node_restart_task_req_data::operator=(const node_restart_task_req_data& other249) {
        task_id = other249.task_id;
        peer_nodes_list = other249.peer_nodes_list;
        additional = other249.additional;
        wallet = other249.wallet;
        nonce = other249.nonce;
        sign = other249.sign;
        multisig_wallets = other249.multisig_wallets;
        multisig_threshold = other249.multisig_threshold;
        multisig_signs = other249.multisig_signs;
        session_id = other249.session_id;
        session_id_sign = other249.session_id_sign;
        force_reboot = other249.force_reboot;
        __isset = other249.__isset;
        return *this;
    }
    void node_restart_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "force_reboot="; (__isset.force_reboot ? (out << to_string(force_reboot)) : (out << "<null>"));
        out << ")";
    }


    node_restart_task_req_body::~node_restart_task_req_body() throw() {
    }


    void node_restart_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req_body &a, node_restart_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_restart_task_req_body::node_restart_task_req_body(const node_restart_task_req_body& other250) {
        data = other250.data;
    }
    node_restart_task_req_body& node_restart_task_req_body::operator=(const node_restart_task_req_body& other251) {
        data = other251.data;
        return *this;
    }
    void node_restart_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_restart_task_req::~node_restart_task_req() throw() {
    }


    void node_restart_task_req::__set_body(const node_restart_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_restart_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req &a, node_restart_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_restart_task_req::node_restart_task_req(const node_restart_task_req& other252) {
        body = other252.body;
        __isset = other252.__isset;
    }
    node_restart_task_req& node_restart_task_req::operator=(const node_restart_task_req& other253) {
        body = other253.body;
        __isset = other253.__isset;
        return *this;
    }
    void node_restart_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_restart_task_rsp_body::~node_restart_task_rsp_body() throw() {
    }


    void node_restart_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_rsp_body &a, node_restart_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_restart_task_rsp_body::node_restart_task_rsp_body(const node_restart_task_rsp_body& other254) {
        data = other254.data;
    }
    node_restart_task_rsp_body& node_restart_task_rsp_body::operator=(const node_restart_task_rsp_body& other255) {
        data = other255.data;
        return *this;
    }
    void node_restart_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_restart_task_rsp::~node_restart_task_rsp() throw() {
    }


    void node_restart_task_rsp::__set_body(const node_restart_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_restart_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_rsp &a, node_restart_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_restart_task_rsp::node_restart_task_rsp(const node_restart_task_rsp& other256) {
        body = other256.body;
        __isset = other256.__isset;
    }
    node_restart_task_rsp& node_restart_task_rsp::operator=(const node_restart_task_rsp& other257) {
        body = other257.body;
        __isset = other257.__isset;
        return *this;
    }
    void node_restart_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_reset_task_req_data::~node_reset_task_req_data() throw() {
    }


    void node_reset_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_reset_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_reset_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_reset_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_reset_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_reset_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_reset_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_reset_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_reset_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_reset_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_reset_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size258;
                            ::apache::thrift::protocol::TType _etype261;
                            xfer += iprot->readListBegin(_etype261, _size258);
                            this->peer_nodes_list.resize(_size258);
                            uint32_t _i262;
                            for (_i262 = 0; _i262 < _size258; ++_i262)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i262]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size263;
                            ::apache::thrift::protocol::TType _etype266;
                            xfer += iprot->readListBegin(_etype266, _size263);
                            this->multisig_wallets.resize(_size263);
                            uint32_t _i267;
                            for (_i267 = 0; _i267 < _size263; ++_i267)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i267]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size268;
                            ::apache::thrift::protocol::TType _etype271;
                            xfer += iprot->readListBegin(_etype271, _size268);
                            this->multisig_signs.resize(_size268);
                            uint32_t _i272;
                            for (_i272 = 0; _i272 < _size268; ++_i272)
                            {
                                xfer += this->multisig_signs[_i272].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter273;
            for (_iter273 = this->peer_nodes_list.begin(); _iter273 != this->peer_nodes_list.end(); ++_iter273)
            {
                xfer += oprot->writeString((*_iter273));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter274;
            for (_iter274 = this->multisig_wallets.begin(); _iter274 != this->multisig_wallets.end(); ++_iter274)
            {
                xfer += oprot->writeString((*_iter274));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter275;
            for (_iter275 = this->multisig_signs.begin(); _iter275 != this->multisig_signs.end(); ++_iter275)
            {
                xfer += (*_iter275).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req_data &a, node_reset_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_reset_task_req_data::node_reset_task_req_data(const node_reset_task_req_data& other276) {
        task_id = other276.task_id;
        peer_nodes_list = other276.peer_nodes_list;
        additional = other276.additional;
        wallet = other276.wallet;
        nonce = other276.nonce;
        sign = other276.sign;
        multisig_wallets = other276.multisig_wallets;
        multisig_threshold = other276.multisig_threshold;
        multisig_signs = other276.multisig_signs;
        session_id = other276.session_id;
        session_id_sign = other276.session_id_sign;
    }
    node_reset_task_req_data& node_reset_task_req_data::operator=(const node_reset_task_req_data& other277) {
        task_id = other277.task_id;
        peer_nodes_list = other277.peer_nodes_list;
        additional = other277.additional;
        wallet = other277.wallet;
        nonce = other277.nonce;
        sign = other277.sign;
        multisig_wallets = other277.multisig_wallets;
        multisig_threshold = other277.multisig_threshold;
        multisig_signs = other277.multisig_signs;
        session_id = other277.session_id;
        session_id_sign = other277.session_id_sign;
        return *this;
    }
    void node_reset_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_reset_task_req_body::~node_reset_task_req_body() throw() {
    }


    void node_reset_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req_body &a, node_reset_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_reset_task_req_body::node_reset_task_req_body(const node_reset_task_req_body& other278) {
        data = other278.data;
    }
    node_reset_task_req_body& node_reset_task_req_body::operator=(const node_reset_task_req_body& other279) {
        data = other279.data;
        return *this;
    }
    void node_reset_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_reset_task_req::~node_reset_task_req() throw() {
    }


    void node_reset_task_req::__set_body(const node_reset_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_reset_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req &a, node_reset_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_reset_task_req::node_reset_task_req(const node_reset_task_req& other280) {
        body = other280.body;
        __isset = other280.__isset;
    }
    node_reset_task_req& node_reset_task_req::operator=(const node_reset_task_req& other281) {
        body = other281.body;
        __isset = other281.__isset;
        return *this;
    }
    void node_reset_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_reset_task_rsp_body::~node_reset_task_rsp_body() throw() {
    }


    void node_reset_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_rsp_body &a, node_reset_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_reset_task_rsp_body::node_reset_task_rsp_body(const node_reset_task_rsp_body& other282) {
        data = other282.data;
    }
    node_reset_task_rsp_body& node_reset_task_rsp_body::operator=(const node_reset_task_rsp_body& other283) {
        data = other283.data;
        return *this;
    }
    void node_reset_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_reset_task_rsp::~node_reset_task_rsp() throw() {
    }


    void node_reset_task_rsp::__set_body(const node_reset_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_reset_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_rsp &a, node_reset_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_reset_task_rsp::node_reset_task_rsp(const node_reset_task_rsp& other284) {
        body = other284.body;
        __isset = other284.__isset;
    }
    node_reset_task_rsp& node_reset_task_rsp::operator=(const node_reset_task_rsp& other285) {
        body = other285.body;
        __isset = other285.__isset;
        return *this;
    }
    void node_reset_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_task_req_data::~node_delete_task_req_data() throw() {
    }


    void node_delete_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_delete_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_delete_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_delete_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_delete_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_delete_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_delete_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_delete_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_delete_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_delete_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_delete_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size286;
                            ::apache::thrift::protocol::TType _etype289;
                            xfer += iprot->readListBegin(_etype289, _size286);
                            this->peer_nodes_list.resize(_size286);
                            uint32_t _i290;
                            for (_i290 = 0; _i290 < _size286; ++_i290)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i290]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size291;
                            ::apache::thrift::protocol::TType _etype294;
                            xfer += iprot->readListBegin(_etype294, _size291);
                            this->multisig_wallets.resize(_size291);
                            uint32_t _i295;
                            for (_i295 = 0; _i295 < _size291; ++_i295)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i295]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size296;
                            ::apache::thrift::protocol::TType _etype299;
                            xfer += iprot->readListBegin(_etype299, _size296);
                            this->multisig_signs.resize(_size296);
                            uint32_t _i300;
                            for (_i300 = 0; _i300 < _size296; ++_i300)
                            {
                                xfer += this->multisig_signs[_i300].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter301;
            for (_iter301 = this->peer_nodes_list.begin(); _iter301 != this->peer_nodes_list.end(); ++_iter301)
            {
                xfer += oprot->writeString((*_iter301));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter302;
            for (_iter302 = this->multisig_wallets.begin(); _iter302 != this->multisig_wallets.end(); ++_iter302)
            {
                xfer += oprot->writeString((*_iter302));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter303;
            for (_iter303 = this->multisig_signs.begin(); _iter303 != this->multisig_signs.end(); ++_iter303)
            {
                xfer += (*_iter303).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req_data &a, node_delete_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_delete_task_req_data::node_delete_task_req_data(const node_delete_task_req_data& other304) {
        task_id = other304.task_id;
        peer_nodes_list = other304.peer_nodes_list;
        additional = other304.additional;
        wallet = other304.wallet;
        nonce = other304.nonce;
        sign = other304.sign;
        multisig_wallets = other304.multisig_wallets;
        multisig_threshold = other304.multisig_threshold;
        multisig_signs = other304.multisig_signs;
        session_id = other304.session_id;
        session_id_sign = other304.session_id_sign;
    }
    node_delete_task_req_data& node_delete_task_req_data::operator=(const node_delete_task_req_data& other305) {
        task_id = other305.task_id;
        peer_nodes_list = other305.peer_nodes_list;
        additional = other305.additional;
        wallet = other305.wallet;
        nonce = other305.nonce;
        sign = other305.sign;
        multisig_wallets = other305.multisig_wallets;
        multisig_threshold = other305.multisig_threshold;
        multisig_signs = other305.multisig_signs;
        session_id = other305.session_id;
        session_id_sign = other305.session_id_sign;
        return *this;
    }
    void node_delete_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_delete_task_req_body::~node_delete_task_req_body() throw() {
    }


    void node_delete_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req_body &a, node_delete_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_task_req_body::node_delete_task_req_body(const node_delete_task_req_body& other306) {
        data = other306.data;
    }
    node_delete_task_req_body& node_delete_task_req_body::operator=(const node_delete_task_req_body& other307) {
        data = other307.data;
        return *this;
    }
    void node_delete_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_task_req::~node_delete_task_req() throw() {
    }


    void node_delete_task_req::__set_body(const node_delete_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req &a, node_delete_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_task_req::node_delete_task_req(const node_delete_task_req& other308) {
        body = other308.body;
        __isset = other308.__isset;
    }
    node_delete_task_req& node_delete_task_req::operator=(const node_delete_task_req& other309) {
        body = other309.body;
        __isset = other309.__isset;
        return *this;
    }
    void node_delete_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_task_rsp_body::~node_delete_task_rsp_body() throw() {
    }


    void node_delete_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_rsp_body &a, node_delete_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_task_rsp_body::node_delete_task_rsp_body(const node_delete_task_rsp_body& other310) {
        data = other310.data;
    }
    node_delete_task_rsp_body& node_delete_task_rsp_body::operator=(const node_delete_task_rsp_body& other311) {
        data = other311.data;
        return *this;
    }
    void node_delete_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_task_rsp::~node_delete_task_rsp() throw() {
    }


    void node_delete_task_rsp::__set_body(const node_delete_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_rsp &a, node_delete_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_task_rsp::node_delete_task_rsp(const node_delete_task_rsp& other312) {
        body = other312.body;
        __isset = other312.__isset;
    }
    node_delete_task_rsp& node_delete_task_rsp::operator=(const node_delete_task_rsp& other313) {
        body = other313.body;
        __isset = other313.__isset;
        return *this;
    }
    void node_delete_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_task_logs_req_data::~node_task_logs_req_data() throw() {
    }


    void node_task_logs_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_task_logs_req_data::__set_head_or_tail(const int16_t val) {
        this->head_or_tail = val;
    }

    void node_task_logs_req_data::__set_number_of_lines(const int32_t val) {
        this->number_of_lines = val;
    }

    void node_task_logs_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_task_logs_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_task_logs_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_task_logs_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_task_logs_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_task_logs_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_task_logs_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_task_logs_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_task_logs_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_task_logs_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_head_or_tail = false;
        bool isset_number_of_lines = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_I16) {
                        xfer += iprot->readI16(this->head_or_tail);
                        isset_head_or_tail = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->number_of_lines);
                        isset_number_of_lines = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size314;
                            ::apache::thrift::protocol::TType _etype317;
                            xfer += iprot->readListBegin(_etype317, _size314);
                            this->peer_nodes_list.resize(_size314);
                            uint32_t _i318;
                            for (_i318 = 0; _i318 < _size314; ++_i318)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i318]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size319;
                            ::apache::thrift::protocol::TType _etype322;
                            xfer += iprot->readListBegin(_etype322, _size319);
                            this->multisig_wallets.resize(_size319);
                            uint32_t _i323;
                            for (_i323 = 0; _i323 < _size319; ++_i323)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i323]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size324;
                            ::apache::thrift::protocol::TType _etype327;
                            xfer += iprot->readListBegin(_etype327, _size324);
                            this->multisig_signs.resize(_size324);
                            uint32_t _i328;
                            for (_i328 = 0; _i328 < _size324; ++_i328)
                            {
                                xfer += this->multisig_signs[_i328].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 13:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_head_or_tail)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_number_of_lines)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("head_or_tail", ::apache::thrift::protocol::T_I16, 2);
        xfer += oprot->writeI16(this->head_or_tail);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("number_of_lines", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->number_of_lines);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 4);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter329;
            for (_iter329 = this->peer_nodes_list.begin(); _iter329 != this->peer_nodes_list.end(); ++_iter329)
            {
                xfer += oprot->writeString((*_iter329));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 8);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter330;
            for (_iter330 = this->multisig_wallets.begin(); _iter330 != this->multisig_wallets.end(); ++_iter330)
            {
                xfer += oprot->writeString((*_iter330));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 10);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 11);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter331;
            for (_iter331 = this->multisig_signs.begin(); _iter331 != this->multisig_signs.end(); ++_iter331)
            {
                xfer += (*_iter331).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 12);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 13);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req_data &a, node_task_logs_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.head_or_tail, b.head_or_tail);
        swap(a.number_of_lines, b.number_of_lines);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_task_logs_req_data::node_task_logs_req_data(const node_task_logs_req_data& other332) {
        task_id = other332.task_id;
        head_or_tail = other332.head_or_tail;
        number_of_lines = other332.number_of_lines;
        peer_nodes_list = other332.peer_nodes_list;
        additional = other332.additional;
        wallet = other332.wallet;
        nonce = other332.nonce;
        sign = other332.sign;
        multisig_wallets = other332.multisig_wallets;
        multisig_threshold = other332.multisig_threshold;
        multisig_signs = other332.multisig_signs;
        session_id = other332.session_id;
        session_id_sign = other332.session_id_sign;
    }
    node_task_logs_req_data& node_task_logs_req_data::operator=(const node_task_logs_req_data& other333) {
        task_id = other333.task_id;
        head_or_tail = other333.head_or_tail;
        number_of_lines = other333.number_of_lines;
        peer_nodes_list = other333.peer_nodes_list;
        additional = other333.additional;
        wallet = other333.wallet;
        nonce = other333.nonce;
        sign = other333.sign;
        multisig_wallets = other333.multisig_wallets;
        multisig_threshold = other333.multisig_threshold;
        multisig_signs = other333.multisig_signs;
        session_id = other333.session_id;
        session_id_sign = other333.session_id_sign;
        return *this;
    }
    void node_task_logs_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "head_or_tail=" << to_string(head_or_tail);
        out << ", " << "number_of_lines=" << to_string(number_of_lines);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_task_logs_req_body::~node_task_logs_req_body() throw() {
    }


    void node_task_logs_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req_body &a, node_task_logs_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_task_logs_req_body::node_task_logs_req_body(const node_task_logs_req_body& other334) {
        data = other334.data;
    }
    node_task_logs_req_body& node_task_logs_req_body::operator=(const node_task_logs_req_body& other335) {
        data = other335.data;
        return *this;
    }
    void node_task_logs_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_task_logs_req::~node_task_logs_req() throw() {
    }


    void node_task_logs_req::__set_body(const node_task_logs_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_task_logs_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req &a, node_task_logs_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_task_logs_req::node_task_logs_req(const node_task_logs_req& other336) {
        body = other336.body;
        __isset = other336.__isset;
    }
    node_task_logs_req& node_task_logs_req::operator=(const node_task_logs_req& other337) {
        body = other337.body;
        __isset = other337.__isset;
        return *this;
    }
    void node_task_logs_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_task_logs_rsp_body::~node_task_logs_rsp_body() throw() {
    }


    void node_task_logs_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_rsp_body &a, node_task_logs_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_task_logs_rsp_body::node_task_logs_rsp_body(const node_task_logs_rsp_body& other338) {
        data = other338.data;
    }
    node_task_logs_rsp_body& node_task_logs_rsp_body::operator=(const node_task_logs_rsp_body& other339) {
        data = other339.data;
        return *this;
    }
    void node_task_logs_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_task_logs_rsp::~node_task_logs_rsp() throw() {
    }


    void node_task_logs_rsp::__set_body(const node_task_logs_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_task_logs_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_rsp &a, node_task_logs_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_task_logs_rsp::node_task_logs_rsp(const node_task_logs_rsp& other340) {
        body = other340.body;
        __isset = other340.__isset;
    }
    node_task_logs_rsp& node_task_logs_rsp::operator=(const node_task_logs_rsp& other341) {
        body = other341.body;
        __isset = other341.__isset;
        return *this;
    }
    void node_task_logs_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_modify_task_req_data::~node_modify_task_req_data() throw() {
    }


    void node_modify_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_modify_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_modify_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_modify_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_modify_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_modify_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_modify_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_modify_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_modify_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_modify_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_modify_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size342;
                            ::apache::thrift::protocol::TType _etype345;
                            xfer += iprot->readListBegin(_etype345, _size342);
                            this->peer_nodes_list.resize(_size342);
                            uint32_t _i346;
                            for (_i346 = 0; _i346 < _size342; ++_i346)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i346]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size347;
                            ::apache::thrift::protocol::TType _etype350;
                            xfer += iprot->readListBegin(_etype350, _size347);
                            this->multisig_wallets.resize(_size347);
                            uint32_t _i351;
                            for (_i351 = 0; _i351 < _size347; ++_i351)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i351]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size352;
                            ::apache::thrift::protocol::TType _etype355;
                            xfer += iprot->readListBegin(_etype355, _size352);
                            this->multisig_signs.resize(_size352);
                            uint32_t _i356;
                            for (_i356 = 0; _i356 < _size352; ++_i356)
                            {
                                xfer += this->multisig_signs[_i356].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter357;
            for (_iter357 = this->peer_nodes_list.begin(); _iter357 != this->peer_nodes_list.end(); ++_iter357)
            {
                xfer += oprot->writeString((*_iter357));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter358;
            for (_iter358 = this->multisig_wallets.begin(); _iter358 != this->multisig_wallets.end(); ++_iter358)
            {
                xfer += oprot->writeString((*_iter358));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter359;
            for (_iter359 = this->multisig_signs.begin(); _iter359 != this->multisig_signs.end(); ++_iter359)
            {
                xfer += (*_iter359).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req_data &a, node_modify_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_modify_task_req_data::node_modify_task_req_data(const node_modify_task_req_data& other360) {
        task_id = other360.task_id;
        peer_nodes_list = other360.peer_nodes_list;
        additional = other360.additional;
        wallet = other360.wallet;
        nonce = other360.nonce;
        sign = other360.sign;
        multisig_wallets = other360.multisig_wallets;
        multisig_threshold = other360.multisig_threshold;
        multisig_signs = other360.multisig_signs;
        session_id = other360.session_id;
        session_id_sign = other360.session_id_sign;
    }
    node_modify_task_req_data& node_modify_task_req_data::operator=(const node_modify_task_req_data& other361) {
        task_id = other361.task_id;
        peer_nodes_list = other361.peer_nodes_list;
        additional = other361.additional;
        wallet = other361.wallet;
        nonce = other361.nonce;
        sign = other361.sign;
        multisig_wallets = other361.multisig_wallets;
        multisig_threshold = other361.multisig_threshold;
        multisig_signs = other361.multisig_signs;
        session_id = other361.session_id;
        session_id_sign = other361.session_id_sign;
        return *this;
    }
    void node_modify_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_modify_task_req_body::~node_modify_task_req_body() throw() {
    }


    void node_modify_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req_body &a, node_modify_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_modify_task_req_body::node_modify_task_req_body(const node_modify_task_req_body& other362) {
        data = other362.data;
    }
    node_modify_task_req_body& node_modify_task_req_body::operator=(const node_modify_task_req_body& other363) {
        data = other363.data;
        return *this;
    }
    void node_modify_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_modify_task_req::~node_modify_task_req() throw() {
    }


    void node_modify_task_req::__set_body(const node_modify_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_modify_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req &a, node_modify_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_modify_task_req::node_modify_task_req(const node_modify_task_req& other364) {
        body = other364.body;
        __isset = other364.__isset;
    }
    node_modify_task_req& node_modify_task_req::operator=(const node_modify_task_req& other365) {
        body = other365.body;
        __isset = other365.__isset;
        return *this;
    }
    void node_modify_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_modify_task_rsp_body::~node_modify_task_rsp_body() throw() {
    }


    void node_modify_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_rsp_body &a, node_modify_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_modify_task_rsp_body::node_modify_task_rsp_body(const node_modify_task_rsp_body& other366) {
        data = other366.data;
    }
    node_modify_task_rsp_body& node_modify_task_rsp_body::operator=(const node_modify_task_rsp_body& other367) {
        data = other367.data;
        return *this;
    }
    void node_modify_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_modify_task_rsp::~node_modify_task_rsp() throw() {
    }


    void node_modify_task_rsp::__set_body(const node_modify_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_modify_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_rsp &a, node_modify_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_modify_task_rsp::node_modify_task_rsp(const node_modify_task_rsp& other368) {
        body = other368.body;
        __isset = other368.__isset;
    }
    node_modify_task_rsp& node_modify_task_rsp::operator=(const node_modify_task_rsp& other369) {
        body = other369.body;
        __isset = other369.__isset;
        return *this;
    }
    void node_modify_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_session_id_req_data::~node_session_id_req_data() throw() {
    }


    void node_session_id_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_session_id_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_session_id_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_session_id_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_session_id_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_session_id_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_session_id_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_session_id_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size370;
                            ::apache::thrift::protocol::TType _etype373;
                            xfer += iprot->readListBegin(_etype373, _size370);
                            this->peer_nodes_list.resize(_size370);
                            uint32_t _i374;
                            for (_i374 = 0; _i374 < _size370; ++_i374)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i374]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size375;
                            ::apache::thrift::protocol::TType _etype378;
                            xfer += iprot->readListBegin(_etype378, _size375);
                            this->multisig_wallets.resize(_size375);
                            uint32_t _i379;
                            for (_i379 = 0; _i379 < _size375; ++_i379)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i379]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size380;
                            ::apache::thrift::protocol::TType _etype383;
                            xfer += iprot->readListBegin(_etype383, _size380);
                            this->multisig_signs.resize(_size380);
                            uint32_t _i384;
                            for (_i384 = 0; _i384 < _size380; ++_i384)
                            {
                                xfer += this->multisig_signs[_i384].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter385;
            for (_iter385 = this->peer_nodes_list.begin(); _iter385 != this->peer_nodes_list.end(); ++_iter385)
            {
                xfer += oprot->writeString((*_iter385));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter386;
            for (_iter386 = this->multisig_wallets.begin(); _iter386 != this->multisig_wallets.end(); ++_iter386)
            {
                xfer += oprot->writeString((*_iter386));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter387;
            for (_iter387 = this->multisig_signs.begin(); _iter387 != this->multisig_signs.end(); ++_iter387)
            {
                xfer += (*_iter387).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req_data &a, node_session_id_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
    }

    node_session_id_req_data::node_session_id_req_data(const node_session_id_req_data& other388) {
        peer_nodes_list = other388.peer_nodes_list;
        additional = other388.additional;
        wallet = other388.wallet;
        nonce = other388.nonce;
        sign = other388.sign;
        multisig_wallets = other388.multisig_wallets;
        multisig_threshold = other388.multisig_threshold;
        multisig_signs = other388.multisig_signs;
    }
    node_session_id_req_data& node_session_id_req_data::operator=(const node_session_id_req_data& other389) {
        peer_nodes_list = other389.peer_nodes_list;
        additional = other389.additional;
        wallet = other389.wallet;
        nonce = other389.nonce;
        sign = other389.sign;
        multisig_wallets = other389.multisig_wallets;
        multisig_threshold = other389.multisig_threshold;
        multisig_signs = other389.multisig_signs;
        return *this;
    }
    void node_session_id_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ")";
    }


    node_session_id_req_body::~node_session_id_req_body() throw() {
    }


    void node_session_id_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req_body &a, node_session_id_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_session_id_req_body::node_session_id_req_body(const node_session_id_req_body& other390) {
        data = other390.data;
    }
    node_session_id_req_body& node_session_id_req_body::operator=(const node_session_id_req_body& other391) {
        data = other391.data;
        return *this;
    }
    void node_session_id_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_session_id_req::~node_session_id_req() throw() {
    }


    void node_session_id_req::__set_body(const node_session_id_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_session_id_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req &a, node_session_id_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_session_id_req::node_session_id_req(const node_session_id_req& other392) {
        body = other392.body;
        __isset = other392.__isset;
    }
    node_session_id_req& node_session_id_req::operator=(const node_session_id_req& other393) {
        body = other393.body;
        __isset = other393.__isset;
        return *this;
    }
    void node_session_id_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_session_id_rsp_body::~node_session_id_rsp_body() throw() {
    }


    void node_session_id_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_rsp_body &a, node_session_id_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_session_id_rsp_body::node_session_id_rsp_body(const node_session_id_rsp_body& other394) {
        data = other394.data;
    }
    node_session_id_rsp_body& node_session_id_rsp_body::operator=(const node_session_id_rsp_body& other395) {
        data = other395.data;
        return *this;
    }
    void node_session_id_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_session_id_rsp::~node_session_id_rsp() throw() {
    }


    void node_session_id_rsp::__set_body(const node_session_id_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_session_id_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_rsp &a, node_session_id_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_session_id_rsp::node_session_id_rsp(const node_session_id_rsp& other396) {
        body = other396.body;
        __isset = other396.__isset;
    }
    node_session_id_rsp& node_session_id_rsp::operator=(const node_session_id_rsp& other397) {
        body = other397.body;
        __isset = other397.__isset;
        return *this;
    }
    void node_session_id_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_query_node_info_req_data::~node_query_node_info_req_data() throw() {
    }


    void node_query_node_info_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_query_node_info_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_query_node_info_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_query_node_info_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_query_node_info_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_query_node_info_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_query_node_info_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_query_node_info_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_query_node_info_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_query_node_info_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_query_node_info_req_data::__set_image_server(const std::vector<std::string> & val) {
        this->image_server = val;
        __isset.image_server = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size398;
                            ::apache::thrift::protocol::TType _etype401;
                            xfer += iprot->readListBegin(_etype401, _size398);
                            this->peer_nodes_list.resize(_size398);
                            uint32_t _i402;
                            for (_i402 = 0; _i402 < _size398; ++_i402)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i402]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size403;
                            ::apache::thrift::protocol::TType _etype406;
                            xfer += iprot->readListBegin(_etype406, _size403);
                            this->multisig_wallets.resize(_size403);
                            uint32_t _i407;
                            for (_i407 = 0; _i407 < _size403; ++_i407)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i407]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size408;
                            ::apache::thrift::protocol::TType _etype411;
                            xfer += iprot->readListBegin(_etype411, _size408);
                            this->multisig_signs.resize(_size408);
                            uint32_t _i412;
                            for (_i412 = 0; _i412 < _size408; ++_i412)
                            {
                                xfer += this->multisig_signs[_i412].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->image_server.clear();
                            uint32_t _size413;
                            ::apache::thrift::protocol::TType _etype416;
                            xfer += iprot->readListBegin(_etype416, _size413);
                            this->image_server.resize(_size413);
                            uint32_t _i417;
                            for (_i417 = 0; _i417 < _size413; ++_i417)
                            {
                                xfer += iprot->readString(this->image_server[_i417]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        this->__isset.image_server = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter418;
            for (_iter418 = this->peer_nodes_list.begin(); _iter418 != this->peer_nodes_list.end(); ++_iter418)
            {
                xfer += oprot->writeString((*_iter418));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter419;
            for (_iter419 = this->multisig_wallets.begin(); _iter419 != this->multisig_wallets.end(); ++_iter419)
            {
                xfer += oprot->writeString((*_iter419));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter420;
            for (_iter420 = this->multisig_signs.begin(); _iter420 != this->multisig_signs.end(); ++_iter420)
            {
                xfer += (*_iter420).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.image_server) {
            xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_LIST, 11);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->image_server.size()));
                std::vector<std::string> ::const_iterator _iter421;
                for (_iter421 = this->image_server.begin(); _iter421 != this->image_server.end(); ++_iter421)
                {
                    xfer += oprot->writeString((*_iter421));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req_data &a, node_query_node_info_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.image_server, b.image_server);
        swap(a.__isset, b.__isset);
    }

    node_query_node_info_req_data::node_query_node_info_req_data(const node_query_node_info_req_data& other422) {
        peer_nodes_list = other422.peer_nodes_list;
        additional = other422.additional;
        wallet = other422.wallet;
        nonce = other422.nonce;
        sign = other422.sign;
        multisig_wallets = other422.multisig_wallets;
        multisig_threshold = other422.multisig_threshold;
        multisig_signs = other422.multisig_signs;
        session_id = other422.session_id;
        session_id_sign = other422.session_id_sign;
        image_server = other422.image_server;
        __isset = other422.__isset;
    }
    node_query_node_info_req_data& node_query_node_info_req_data::operator=(const node_query_node_info_req_data& other423) {
        peer_nodes_list = other423.peer_nodes_list;
        additional = other423.additional;
        wallet = other423.wallet;
        nonce = other423.nonce;
        sign = other423.sign;
        multisig_wallets = other423.multisig_wallets;
        multisig_threshold = other423.multisig_threshold;
        multisig_signs = other423.multisig_signs;
        session_id = other423.session_id;
        session_id_sign = other423.session_id_sign;
        image_server = other423.image_server;
        __isset = other423.__isset;
        return *this;
    }
    void node_query_node_info_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
        out << ")";
    }


    node_query_node_info_req_body::~node_query_node_info_req_body() throw() {
    }


    void node_query_node_info_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req_body &a, node_query_node_info_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_query_node_info_req_body::node_query_node_info_req_body(const node_query_node_info_req_body& other424) {
        data = other424.data;
    }
    node_query_node_info_req_body& node_query_node_info_req_body::operator=(const node_query_node_info_req_body& other425) {
        data = other425.data;
        return *this;
    }
    void node_query_node_info_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_query_node_info_req::~node_query_node_info_req() throw() {
    }


    void node_query_node_info_req::__set_body(const node_query_node_info_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_query_node_info_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req &a, node_query_node_info_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_query_node_info_req::node_query_node_info_req(const node_query_node_info_req& other426) {
        body = other426.body;
        __isset = other426.__isset;
    }
    node_query_node_info_req& node_query_node_info_req::operator=(const node_query_node_info_req& other427) {
        body = other427.body;
        __isset = other427.__isset;
        return *this;
    }
    void node_query_node_info_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_query_node_info_rsp_body::~node_query_node_info_rsp_body() throw() {
    }


    void node_query_node_info_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_rsp_body &a, node_query_node_info_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_query_node_info_rsp_body::node_query_node_info_rsp_body(const node_query_node_info_rsp_body& other428) {
        data = other428.data;
    }
    node_query_node_info_rsp_body& node_query_node_info_rsp_body::operator=(const node_query_node_info_rsp_body& other429) {
        data = other429.data;
        return *this;
    }
    void node_query_node_info_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_query_node_info_rsp::~node_query_node_info_rsp() throw() {
    }


    void node_query_node_info_rsp::__set_body(const node_query_node_info_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_query_node_info_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_rsp &a, node_query_node_info_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_query_node_info_rsp::node_query_node_info_rsp(const node_query_node_info_rsp& other430) {
        body = other430.body;
        __isset = other430.__isset;
    }
    node_query_node_info_rsp& node_query_node_info_rsp::operator=(const node_query_node_info_rsp& other431) {
        body = other431.body;
        __isset = other431.__isset;
        return *this;
    }
    void node_query_node_info_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_service_info::~node_service_info() throw() {
    }


    void node_service_info::__set_service_list(const std::vector<std::string> & val) {
        this->service_list = val;
    }

    void node_service_info::__set_name(const std::string& val) {
        this->name = val;
        __isset.name = true;
    }

    void node_service_info::__set_time_stamp(const int64_t val) {
        this->time_stamp = val;
        __isset.time_stamp = true;
    }

    void node_service_info::__set_kvs(const std::map<std::string, std::string> & val) {
        this->kvs = val;
        __isset.kvs = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_service_info& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_service_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->service_list.clear();
                            uint32_t _size432;
                            ::apache::thrift::protocol::TType _etype435;
                            xfer += iprot->readListBegin(_etype435, _size432);
                            this->service_list.resize(_size432);
                            uint32_t _i436;
                            for (_i436 = 0; _i436 < _size432; ++_i436)
                            {
                                xfer += iprot->readString(this->service_list[_i436]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_service_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->name);
                        this->__isset.name = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_I64) {
                        xfer += iprot->readI64(this->time_stamp);
                        this->__isset.time_stamp = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_MAP) {
                        {
                            this->kvs.clear();
                            uint32_t _size437;
                            ::apache::thrift::protocol::TType _ktype438;
                            ::apache::thrift::protocol::TType _vtype439;
                            xfer += iprot->readMapBegin(_ktype438, _vtype439, _size437);
                            uint32_t _i441;
                            for (_i441 = 0; _i441 < _size437; ++_i441)
                            {
                                std::string _key442;
                                xfer += iprot->readString(_key442);
                                std::string& _val443 = this->kvs[_key442];
                                xfer += iprot->readString(_val443);
                            }
                            xfer += iprot->readMapEnd();
                        }
                        this->__isset.kvs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_service_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_service_info");

        xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
            std::vector<std::string> ::const_iterator _iter444;
            for (_iter444 = this->service_list.begin(); _iter444 != this->service_list.end(); ++_iter444)
            {
                xfer += oprot->writeString((*_iter444));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        if (this->__isset.name) {
            xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
            xfer += oprot->writeString(this->name);
            xfer += oprot->writeFieldEnd();
        }
        if (this->__isset.time_stamp) {
            xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 3);
            xfer += oprot->writeI64(this->time_stamp);
            xfer += oprot->writeFieldEnd();
        }
        if (this->__isset.kvs) {
            xfer += oprot->writeFieldBegin("kvs", ::apache::thrift::protocol::T_MAP, 4);
            {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kvs.size()));
                std::map<std::string, std::string> ::const_iterator _iter445;
                for (_iter445 = this->kvs.begin(); _iter445 != this->kvs.end(); ++_iter445)
                {
                    xfer += oprot->writeString(_iter445->first);
                    xfer += oprot->writeString(_iter445->second);
                }
                xfer += oprot->writeMapEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_service_info &a, node_service_info &b) {
        using ::std::swap;
        swap(a.service_list, b.service_list);
        swap(a.name, b.name);
        swap(a.time_stamp, b.time_stamp);
        swap(a.kvs, b.kvs);
        swap(a.__isset, b.__isset);
    }

    node_service_info::node_service_info(const node_service_info& other446) {
        service_list = other446.service_list;
        name = other446.name;
        time_stamp = other446.time_stamp;
        kvs = other446.kvs;
        __isset = other446.__isset;
    }
    node_service_info& node_service_info::operator=(const node_service_info& other447) {
        service_list = other447.service_list;
        name = other447.name;
        time_stamp = other447.time_stamp;
        kvs = other447.kvs;
        __isset = other447.__isset;
        return *this;
    }
    void node_service_info::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_service_info(";
        out << "service_list=" << to_string(service_list);
        out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
        out << ", " << "time_stamp="; (__isset.time_stamp ? (out << to_string(time_stamp)) : (out << "<null>"));
        out << ", " << "kvs="; (__isset.kvs ? (out << to_string(kvs)) : (out << "<null>"));
        out << ")";
    }


    service_broadcast_req_body::~service_broadcast_req_body() throw() {
    }


    void service_broadcast_req_body::__set_node_service_info_map(const std::map<std::string, node_service_info> & val) {
        this->node_service_info_map = val;
    }
    std::ostream& operator<<(std::ostream& out, const service_broadcast_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t service_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_service_info_map = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_MAP) {
                        {
                            this->node_service_info_map.clear();
                            uint32_t _size448;
                            ::apache::thrift::protocol::TType _ktype449;
                            ::apache::thrift::protocol::TType _vtype450;
                            xfer += iprot->readMapBegin(_ktype449, _vtype450, _size448);
                            uint32_t _i452;
                            for (_i452 = 0; _i452 < _size448; ++_i452)
                            {
                                std::string _key453;
                                xfer += iprot->readString(_key453);
                                node_service_info& _val454 = this->node_service_info_map[_key453];
                                xfer += _val454.read(iprot);
                            }
                            xfer += iprot->readMapEnd();
                        }
                        isset_node_service_info_map = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_service_info_map)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t service_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("service_broadcast_req_body");

        xfer += oprot->writeFieldBegin("node_service_info_map", ::apache::thrift::protocol::T_MAP, 1);
        {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_service_info_map.size()));
            std::map<std::string, node_service_info> ::const_iterator _iter455;
            for (_iter455 = this->node_service_info_map.begin(); _iter455 != this->node_service_info_map.end(); ++_iter455)
            {
                xfer += oprot->writeString(_iter455->first);
                xfer += _iter455->second.write(oprot);
            }
            xfer += oprot->writeMapEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(service_broadcast_req_body &a, service_broadcast_req_body &b) {
        using ::std::swap;
        swap(a.node_service_info_map, b.node_service_info_map);
    }

    service_broadcast_req_body::service_broadcast_req_body(const service_broadcast_req_body& other456) {
        node_service_info_map = other456.node_service_info_map;
    }
    service_broadcast_req_body& service_broadcast_req_body::operator=(const service_broadcast_req_body& other457) {
        node_service_info_map = other457.node_service_info_map;
        return *this;
    }
    void service_broadcast_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "service_broadcast_req_body(";
        out << "node_service_info_map=" << to_string(node_service_info_map);
        out << ")";
    }


    service_broadcast_req::~service_broadcast_req() throw() {
    }


    void service_broadcast_req::__set_body(const service_broadcast_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const service_broadcast_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t service_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t service_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("service_broadcast_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(service_broadcast_req &a, service_broadcast_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    service_broadcast_req::service_broadcast_req(const service_broadcast_req& other458) {
        body = other458.body;
        __isset = other458.__isset;
    }
    service_broadcast_req& service_broadcast_req::operator=(const service_broadcast_req& other459) {
        body = other459.body;
        __isset = other459.__isset;
        return *this;
    }
    void service_broadcast_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "service_broadcast_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    ver_req_body::~ver_req_body() throw() {
    }


    void ver_req_body::__set_node_id(const std::string& val) {
        this->node_id = val;
    }

    void ver_req_body::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void ver_req_body::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }

    void ver_req_body::__set_time_stamp(const int64_t val) {
        this->time_stamp = val;
    }

    void ver_req_body::__set_addr_me(const network_address& val) {
        this->addr_me = val;
    }

    void ver_req_body::__set_addr_you(const network_address& val) {
        this->addr_you = val;
    }

    void ver_req_body::__set_start_height(const int64_t val) {
        this->start_height = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;
        bool isset_time_stamp = false;
        bool isset_addr_me = false;
        bool isset_addr_you = false;
        bool isset_start_height = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->node_id);
                        isset_node_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->core_version);
                        isset_core_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->protocol_version);
                        isset_protocol_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_I64) {
                        xfer += iprot->readI64(this->time_stamp);
                        isset_time_stamp = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->addr_me.read(iprot);
                        isset_addr_me = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->addr_you.read(iprot);
                        isset_addr_you = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_I64) {
                        xfer += iprot->readI64(this->start_height);
                        isset_start_height = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_time_stamp)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr_me)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr_you)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_start_height)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t ver_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_req_body");

        xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 4);
        xfer += oprot->writeI64(this->time_stamp);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr_me", ::apache::thrift::protocol::T_STRUCT, 5);
        xfer += this->addr_me.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr_you", ::apache::thrift::protocol::T_STRUCT, 6);
        xfer += this->addr_you.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("start_height", ::apache::thrift::protocol::T_I64, 7);
        xfer += oprot->writeI64(this->start_height);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_req_body &a, ver_req_body &b) {
        using ::std::swap;
        swap(a.node_id, b.node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
        swap(a.time_stamp, b.time_stamp);
        swap(a.addr_me, b.addr_me);
        swap(a.addr_you, b.addr_you);
        swap(a.start_height, b.start_height);
    }

    ver_req_body::ver_req_body(const ver_req_body& other460) {
        node_id = other460.node_id;
        core_version = other460.core_version;
        protocol_version = other460.protocol_version;
        time_stamp = other460.time_stamp;
        addr_me = other460.addr_me;
        addr_you = other460.addr_you;
        start_height = other460.start_height;
    }
    ver_req_body& ver_req_body::operator=(const ver_req_body& other461) {
        node_id = other461.node_id;
        core_version = other461.core_version;
        protocol_version = other461.protocol_version;
        time_stamp = other461.time_stamp;
        addr_me = other461.addr_me;
        addr_you = other461.addr_you;
        start_height = other461.start_height;
        return *this;
    }
    void ver_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_req_body(";
        out << "node_id=" << to_string(node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ", " << "time_stamp=" << to_string(time_stamp);
        out << ", " << "addr_me=" << to_string(addr_me);
        out << ", " << "addr_you=" << to_string(addr_you);
        out << ", " << "start_height=" << to_string(start_height);
        out << ")";
    }


    ver_req::~ver_req() throw() {
    }


    void ver_req::__set_body(const ver_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t ver_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_req &a, ver_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    ver_req::ver_req(const ver_req& other462) {
        body = other462.body;
        __isset = other462.__isset;
    }
    ver_req& ver_req::operator=(const ver_req& other463) {
        body = other463.body;
        __isset = other463.__isset;
        return *this;
    }
    void ver_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    ver_resp_body::~ver_resp_body() throw() {
    }


    void ver_resp_body::__set_node_id(const std::string& val) {
        this->node_id = val;
    }

    void ver_resp_body::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void ver_resp_body::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_resp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->node_id);
                        isset_node_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->core_version);
                        isset_core_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->protocol_version);
                        isset_protocol_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t ver_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_resp_body");

        xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_resp_body &a, ver_resp_body &b) {
        using ::std::swap;
        swap(a.node_id, b.node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
    }

    ver_resp_body::ver_resp_body(const ver_resp_body& other464) {
        node_id = other464.node_id;
        core_version = other464.core_version;
        protocol_version = other464.protocol_version;
    }
    ver_resp_body& ver_resp_body::operator=(const ver_resp_body& other465) {
        node_id = other465.node_id;
        core_version = other465.core_version;
        protocol_version = other465.protocol_version;
        return *this;
    }
    void ver_resp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_resp_body(";
        out << "node_id=" << to_string(node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ")";
    }


    ver_resp::~ver_resp() throw() {
    }


    void ver_resp::__set_body(const ver_resp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t ver_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_resp &a, ver_resp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    ver_resp::ver_resp(const ver_resp& other466) {
        body = other466.body;
        __isset = other466.__isset;
    }
    ver_resp& ver_resp::operator=(const ver_resp& other467) {
        body = other467.body;
        __isset = other467.__isset;
        return *this;
    }
    void ver_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    peer_node_info::~peer_node_info() throw() {
    }


    void peer_node_info::__set_peer_node_id(const std::string& val) {
        this->peer_node_id = val;
    }

    void peer_node_info::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void peer_node_info::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }

    void peer_node_info::__set_live_time_stamp(const int32_t val) {
        this->live_time_stamp = val;
    }

    void peer_node_info::__set_addr(const network_address& val) {
        this->addr = val;
    }

    void peer_node_info::__set_service_list(const std::vector<std::string> & val) {
        this->service_list = val;
        __isset.service_list = true;
    }
    std::ostream& operator<<(std::ostream& out, const peer_node_info& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;
        bool isset_live_time_stamp = false;
        bool isset_addr = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->peer_node_id);
                        isset_peer_node_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->core_version);
                        isset_core_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->protocol_version);
                        isset_protocol_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->live_time_stamp);
                        isset_live_time_stamp = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->addr.read(iprot);
                        isset_addr = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->service_list.clear();
                            uint32_t _size468;
                            ::apache::thrift::protocol::TType _etype471;
                            xfer += iprot->readListBegin(_etype471, _size468);
                            this->service_list.resize(_size468);
                            uint32_t _i472;
                            for (_i472 = 0; _i472 < _size468; ++_i472)
                            {
                                xfer += iprot->readString(this->service_list[_i472]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        this->__isset.service_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_live_time_stamp)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t peer_node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_node_info");

        xfer += oprot->writeFieldBegin("peer_node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->peer_node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("live_time_stamp", ::apache::thrift::protocol::T_I32, 4);
        xfer += oprot->writeI32(this->live_time_stamp);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRUCT, 5);
        xfer += this->addr.write(oprot);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.service_list) {
            xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 6);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
                std::vector<std::string> ::const_iterator _iter473;
                for (_iter473 = this->service_list.begin(); _iter473 != this->service_list.end(); ++_iter473)
                {
                    xfer += oprot->writeString((*_iter473));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_node_info &a, peer_node_info &b) {
        using ::std::swap;
        swap(a.peer_node_id, b.peer_node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
        swap(a.live_time_stamp, b.live_time_stamp);
        swap(a.addr, b.addr);
        swap(a.service_list, b.service_list);
        swap(a.__isset, b.__isset);
    }

    peer_node_info::peer_node_info(const peer_node_info& other474) {
        peer_node_id = other474.peer_node_id;
        core_version = other474.core_version;
        protocol_version = other474.protocol_version;
        live_time_stamp = other474.live_time_stamp;
        addr = other474.addr;
        service_list = other474.service_list;
        __isset = other474.__isset;
    }
    peer_node_info& peer_node_info::operator=(const peer_node_info& other475) {
        peer_node_id = other475.peer_node_id;
        core_version = other475.core_version;
        protocol_version = other475.protocol_version;
        live_time_stamp = other475.live_time_stamp;
        addr = other475.addr;
        service_list = other475.service_list;
        __isset = other475.__isset;
        return *this;
    }
    void peer_node_info::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_node_info(";
        out << "peer_node_id=" << to_string(peer_node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ", " << "live_time_stamp=" << to_string(live_time_stamp);
        out << ", " << "addr=" << to_string(addr);
        out << ", " << "service_list="; (__isset.service_list ? (out << to_string(service_list)) : (out << "<null>"));
        out << ")";
    }


    get_peer_nodes_req::~get_peer_nodes_req() throw() {
    }


    void get_peer_nodes_req::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t get_peer_nodes_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_req &a, get_peer_nodes_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    get_peer_nodes_req::get_peer_nodes_req(const get_peer_nodes_req& other476) {
        body = other476.body;
        __isset = other476.__isset;
    }
    get_peer_nodes_req& get_peer_nodes_req::operator=(const get_peer_nodes_req& other477) {
        body = other477.body;
        __isset = other477.__isset;
        return *this;
    }
    void get_peer_nodes_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    get_peer_nodes_resp_body::~get_peer_nodes_resp_body() throw() {
    }


    void get_peer_nodes_resp_body::__set_peer_nodes_list(const std::vector<peer_node_info> & val) {
        this->peer_nodes_list = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size478;
                            ::apache::thrift::protocol::TType _etype481;
                            xfer += iprot->readListBegin(_etype481, _size478);
                            this->peer_nodes_list.resize(_size478);
                            uint32_t _i482;
                            for (_i482 = 0; _i482 < _size478; ++_i482)
                            {
                                xfer += this->peer_nodes_list[_i482].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t get_peer_nodes_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_resp_body");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<peer_node_info> ::const_iterator _iter483;
            for (_iter483 = this->peer_nodes_list.begin(); _iter483 != this->peer_nodes_list.end(); ++_iter483)
            {
                xfer += (*_iter483).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_resp_body &a, get_peer_nodes_resp_body &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
    }

    get_peer_nodes_resp_body::get_peer_nodes_resp_body(const get_peer_nodes_resp_body& other484) {
        peer_nodes_list = other484.peer_nodes_list;
    }
    get_peer_nodes_resp_body& get_peer_nodes_resp_body::operator=(const get_peer_nodes_resp_body& other485) {
        peer_nodes_list = other485.peer_nodes_list;
        return *this;
    }
    void get_peer_nodes_resp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_resp_body(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ")";
    }


    get_peer_nodes_resp::~get_peer_nodes_resp() throw() {
    }


    void get_peer_nodes_resp::__set_body(const get_peer_nodes_resp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t get_peer_nodes_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_resp &a, get_peer_nodes_resp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    get_peer_nodes_resp::get_peer_nodes_resp(const get_peer_nodes_resp& other486) {
        body = other486.body;
        __isset = other486.__isset;
    }
    get_peer_nodes_resp& get_peer_nodes_resp::operator=(const get_peer_nodes_resp& other487) {
        body = other487.body;
        __isset = other487.__isset;
        return *this;
    }
    void get_peer_nodes_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    peer_nodes_broadcast_req_body::~peer_nodes_broadcast_req_body() throw() {
    }


    void peer_nodes_broadcast_req_body::__set_peer_nodes_list(const std::vector<peer_node_info> & val) {
        this->peer_nodes_list = val;
    }
    std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_nodes_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size488;
                            ::apache::thrift::protocol::TType _etype491;
                            xfer += iprot->readListBegin(_etype491, _size488);
                            this->peer_nodes_list.resize(_size488);
                            uint32_t _i492;
                            for (_i492 = 0; _i492 < _size488; ++_i492)
                            {
                                xfer += this->peer_nodes_list[_i492].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t peer_nodes_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_nodes_broadcast_req_body");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<peer_node_info> ::const_iterator _iter493;
            for (_iter493 = this->peer_nodes_list.begin(); _iter493 != this->peer_nodes_list.end(); ++_iter493)
            {
                xfer += (*_iter493).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_nodes_broadcast_req_body &a, peer_nodes_broadcast_req_body &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
    }

    peer_nodes_broadcast_req_body::peer_nodes_broadcast_req_body(const peer_nodes_broadcast_req_body& other494) {
        peer_nodes_list = other494.peer_nodes_list;
    }
    peer_nodes_broadcast_req_body& peer_nodes_broadcast_req_body::operator=(const peer_nodes_broadcast_req_body& other495) {
        peer_nodes_list = other495.peer_nodes_list;
        return *this;
    }
    void peer_nodes_broadcast_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_nodes_broadcast_req_body(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ")";
    }


    peer_nodes_broadcast_req::~peer_nodes_broadcast_req() throw() {
    }


    void peer_nodes_broadcast_req::__set_body(const peer_nodes_broadcast_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_nodes_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t peer_nodes_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_nodes_broadcast_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_nodes_broadcast_req &a, peer_nodes_broadcast_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    peer_nodes_broadcast_req::peer_nodes_broadcast_req(const peer_nodes_broadcast_req& other496) {
        body = other496.body;
        __isset = other496.__isset;
    }
    peer_nodes_broadcast_req& peer_nodes_broadcast_req::operator=(const peer_nodes_broadcast_req& other497) {
        body = other497.body;
        __isset = other497.__isset;
        return *this;
    }
    void peer_nodes_broadcast_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_nodes_broadcast_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_snapshot_req_data::~node_list_snapshot_req_data() throw() {
    }


    void node_list_snapshot_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_list_snapshot_req_data::__set_snapshot_name(const std::string& val) {
        this->snapshot_name = val;
    }

    void node_list_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_list_snapshot_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_list_snapshot_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_list_snapshot_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_list_snapshot_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_list_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_list_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_list_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_list_snapshot_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_list_snapshot_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_snapshot_name = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->snapshot_name);
                        isset_snapshot_name = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size498;
                            ::apache::thrift::protocol::TType _etype501;
                            xfer += iprot->readListBegin(_etype501, _size498);
                            this->peer_nodes_list.resize(_size498);
                            uint32_t _i502;
                            for (_i502 = 0; _i502 < _size498; ++_i502)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i502]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size503;
                            ::apache::thrift::protocol::TType _etype506;
                            xfer += iprot->readListBegin(_etype506, _size503);
                            this->multisig_wallets.resize(_size503);
                            uint32_t _i507;
                            for (_i507 = 0; _i507 < _size503; ++_i507)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i507]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size508;
                            ::apache::thrift::protocol::TType _etype511;
                            xfer += iprot->readListBegin(_etype511, _size508);
                            this->multisig_signs.resize(_size508);
                            uint32_t _i512;
                            for (_i512 = 0; _i512 < _size508; ++_i512)
                            {
                                xfer += this->multisig_signs[_i512].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_snapshot_name)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->snapshot_name);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 3);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter513;
            for (_iter513 = this->peer_nodes_list.begin(); _iter513 != this->peer_nodes_list.end(); ++_iter513)
            {
                xfer += oprot->writeString((*_iter513));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter514;
            for (_iter514 = this->multisig_wallets.begin(); _iter514 != this->multisig_wallets.end(); ++_iter514)
            {
                xfer += oprot->writeString((*_iter514));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 9);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 10);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter515;
            for (_iter515 = this->multisig_signs.begin(); _iter515 != this->multisig_signs.end(); ++_iter515)
            {
                xfer += (*_iter515).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 12);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_req_data &a, node_list_snapshot_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.snapshot_name, b.snapshot_name);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_list_snapshot_req_data::node_list_snapshot_req_data(const node_list_snapshot_req_data& other516) {
        task_id = other516.task_id;
        snapshot_name = other516.snapshot_name;
        peer_nodes_list = other516.peer_nodes_list;
        additional = other516.additional;
        wallet = other516.wallet;
        nonce = other516.nonce;
        sign = other516.sign;
        multisig_wallets = other516.multisig_wallets;
        multisig_threshold = other516.multisig_threshold;
        multisig_signs = other516.multisig_signs;
        session_id = other516.session_id;
        session_id_sign = other516.session_id_sign;
    }
    node_list_snapshot_req_data& node_list_snapshot_req_data::operator=(const node_list_snapshot_req_data& other517) {
        task_id = other517.task_id;
        snapshot_name = other517.snapshot_name;
        peer_nodes_list = other517.peer_nodes_list;
        additional = other517.additional;
        wallet = other517.wallet;
        nonce = other517.nonce;
        sign = other517.sign;
        multisig_wallets = other517.multisig_wallets;
        multisig_threshold = other517.multisig_threshold;
        multisig_signs = other517.multisig_signs;
        session_id = other517.session_id;
        session_id_sign = other517.session_id_sign;
        return *this;
    }
    void node_list_snapshot_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "snapshot_name=" << to_string(snapshot_name);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_list_snapshot_req_body::~node_list_snapshot_req_body() throw() {
    }


    void node_list_snapshot_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_req_body &a, node_list_snapshot_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_snapshot_req_body::node_list_snapshot_req_body(const node_list_snapshot_req_body& other518) {
        data = other518.data;
    }
    node_list_snapshot_req_body& node_list_snapshot_req_body::operator=(const node_list_snapshot_req_body& other519) {
        data = other519.data;
        return *this;
    }
    void node_list_snapshot_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_snapshot_req::~node_list_snapshot_req() throw() {
    }


    void node_list_snapshot_req::__set_body(const node_list_snapshot_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_req &a, node_list_snapshot_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_snapshot_req::node_list_snapshot_req(const node_list_snapshot_req& other520) {
        body = other520.body;
        __isset = other520.__isset;
    }
    node_list_snapshot_req& node_list_snapshot_req::operator=(const node_list_snapshot_req& other521) {
        body = other521.body;
        __isset = other521.__isset;
        return *this;
    }
    void node_list_snapshot_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_snapshot_rsp_body::~node_list_snapshot_rsp_body() throw() {
    }


    void node_list_snapshot_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_rsp_body &a, node_list_snapshot_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_snapshot_rsp_body::node_list_snapshot_rsp_body(const node_list_snapshot_rsp_body& other522) {
        data = other522.data;
    }
    node_list_snapshot_rsp_body& node_list_snapshot_rsp_body::operator=(const node_list_snapshot_rsp_body& other523) {
        data = other523.data;
        return *this;
    }
    void node_list_snapshot_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_snapshot_rsp::~node_list_snapshot_rsp() throw() {
    }


    void node_list_snapshot_rsp::__set_body(const node_list_snapshot_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_rsp &a, node_list_snapshot_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_snapshot_rsp::node_list_snapshot_rsp(const node_list_snapshot_rsp& other524) {
        body = other524.body;
        __isset = other524.__isset;
    }
    node_list_snapshot_rsp& node_list_snapshot_rsp::operator=(const node_list_snapshot_rsp& other525) {
        body = other525.body;
        __isset = other525.__isset;
        return *this;
    }
    void node_list_snapshot_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_snapshot_req_data::~node_create_snapshot_req_data() throw() {
    }


    void node_create_snapshot_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_create_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_create_snapshot_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_create_snapshot_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_create_snapshot_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_create_snapshot_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_create_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_create_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_create_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_create_snapshot_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_create_snapshot_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size526;
                            ::apache::thrift::protocol::TType _etype529;
                            xfer += iprot->readListBegin(_etype529, _size526);
                            this->peer_nodes_list.resize(_size526);
                            uint32_t _i530;
                            for (_i530 = 0; _i530 < _size526; ++_i530)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i530]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size531;
                            ::apache::thrift::protocol::TType _etype534;
                            xfer += iprot->readListBegin(_etype534, _size531);
                            this->multisig_wallets.resize(_size531);
                            uint32_t _i535;
                            for (_i535 = 0; _i535 < _size531; ++_i535)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i535]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size536;
                            ::apache::thrift::protocol::TType _etype539;
                            xfer += iprot->readListBegin(_etype539, _size536);
                            this->multisig_signs.resize(_size536);
                            uint32_t _i540;
                            for (_i540 = 0; _i540 < _size536; ++_i540)
                            {
                                xfer += this->multisig_signs[_i540].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter541;
            for (_iter541 = this->peer_nodes_list.begin(); _iter541 != this->peer_nodes_list.end(); ++_iter541)
            {
                xfer += oprot->writeString((*_iter541));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter542;
            for (_iter542 = this->multisig_wallets.begin(); _iter542 != this->multisig_wallets.end(); ++_iter542)
            {
                xfer += oprot->writeString((*_iter542));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter543;
            for (_iter543 = this->multisig_signs.begin(); _iter543 != this->multisig_signs.end(); ++_iter543)
            {
                xfer += (*_iter543).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_req_data &a, node_create_snapshot_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_create_snapshot_req_data::node_create_snapshot_req_data(const node_create_snapshot_req_data& other544) {
        task_id = other544.task_id;
        peer_nodes_list = other544.peer_nodes_list;
        additional = other544.additional;
        wallet = other544.wallet;
        nonce = other544.nonce;
        sign = other544.sign;
        multisig_wallets = other544.multisig_wallets;
        multisig_threshold = other544.multisig_threshold;
        multisig_signs = other544.multisig_signs;
        session_id = other544.session_id;
        session_id_sign = other544.session_id_sign;
    }
    node_create_snapshot_req_data& node_create_snapshot_req_data::operator=(const node_create_snapshot_req_data& other545) {
        task_id = other545.task_id;
        peer_nodes_list = other545.peer_nodes_list;
        additional = other545.additional;
        wallet = other545.wallet;
        nonce = other545.nonce;
        sign = other545.sign;
        multisig_wallets = other545.multisig_wallets;
        multisig_threshold = other545.multisig_threshold;
        multisig_signs = other545.multisig_signs;
        session_id = other545.session_id;
        session_id_sign = other545.session_id_sign;
        return *this;
    }
    void node_create_snapshot_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_create_snapshot_req_body::~node_create_snapshot_req_body() throw() {
    }


    void node_create_snapshot_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_req_body &a, node_create_snapshot_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_snapshot_req_body::node_create_snapshot_req_body(const node_create_snapshot_req_body& other546) {
        data = other546.data;
    }
    node_create_snapshot_req_body& node_create_snapshot_req_body::operator=(const node_create_snapshot_req_body& other547) {
        data = other547.data;
        return *this;
    }
    void node_create_snapshot_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_snapshot_req::~node_create_snapshot_req() throw() {
    }


    void node_create_snapshot_req::__set_body(const node_create_snapshot_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_req &a, node_create_snapshot_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_snapshot_req::node_create_snapshot_req(const node_create_snapshot_req& other548) {
        body = other548.body;
        __isset = other548.__isset;
    }
    node_create_snapshot_req& node_create_snapshot_req::operator=(const node_create_snapshot_req& other549) {
        body = other549.body;
        __isset = other549.__isset;
        return *this;
    }
    void node_create_snapshot_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_snapshot_rsp_body::~node_create_snapshot_rsp_body() throw() {
    }


    void node_create_snapshot_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_rsp_body &a, node_create_snapshot_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_snapshot_rsp_body::node_create_snapshot_rsp_body(const node_create_snapshot_rsp_body& other550) {
        data = other550.data;
    }
    node_create_snapshot_rsp_body& node_create_snapshot_rsp_body::operator=(const node_create_snapshot_rsp_body& other551) {
        data = other551.data;
        return *this;
    }
    void node_create_snapshot_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_snapshot_rsp::~node_create_snapshot_rsp() throw() {
    }


    void node_create_snapshot_rsp::__set_body(const node_create_snapshot_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_rsp &a, node_create_snapshot_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_snapshot_rsp::node_create_snapshot_rsp(const node_create_snapshot_rsp& other552) {
        body = other552.body;
        __isset = other552.__isset;
    }
    node_create_snapshot_rsp& node_create_snapshot_rsp::operator=(const node_create_snapshot_rsp& other553) {
        body = other553.body;
        __isset = other553.__isset;
        return *this;
    }
    void node_create_snapshot_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_snapshot_req_data::~node_delete_snapshot_req_data() throw() {
    }


    void node_delete_snapshot_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_delete_snapshot_req_data::__set_snapshot_name(const std::string& val) {
        this->snapshot_name = val;
    }

    void node_delete_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_delete_snapshot_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_delete_snapshot_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_delete_snapshot_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_delete_snapshot_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_delete_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_delete_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_delete_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_delete_snapshot_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_delete_snapshot_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_snapshot_name = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->snapshot_name);
                        isset_snapshot_name = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size554;
                            ::apache::thrift::protocol::TType _etype557;
                            xfer += iprot->readListBegin(_etype557, _size554);
                            this->peer_nodes_list.resize(_size554);
                            uint32_t _i558;
                            for (_i558 = 0; _i558 < _size554; ++_i558)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i558]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size559;
                            ::apache::thrift::protocol::TType _etype562;
                            xfer += iprot->readListBegin(_etype562, _size559);
                            this->multisig_wallets.resize(_size559);
                            uint32_t _i563;
                            for (_i563 = 0; _i563 < _size559; ++_i563)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i563]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size564;
                            ::apache::thrift::protocol::TType _etype567;
                            xfer += iprot->readListBegin(_etype567, _size564);
                            this->multisig_signs.resize(_size564);
                            uint32_t _i568;
                            for (_i568 = 0; _i568 < _size564; ++_i568)
                            {
                                xfer += this->multisig_signs[_i568].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_snapshot_name)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->snapshot_name);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 3);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter569;
            for (_iter569 = this->peer_nodes_list.begin(); _iter569 != this->peer_nodes_list.end(); ++_iter569)
            {
                xfer += oprot->writeString((*_iter569));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter570;
            for (_iter570 = this->multisig_wallets.begin(); _iter570 != this->multisig_wallets.end(); ++_iter570)
            {
                xfer += oprot->writeString((*_iter570));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 9);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 10);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter571;
            for (_iter571 = this->multisig_signs.begin(); _iter571 != this->multisig_signs.end(); ++_iter571)
            {
                xfer += (*_iter571).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 12);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_req_data &a, node_delete_snapshot_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.snapshot_name, b.snapshot_name);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_delete_snapshot_req_data::node_delete_snapshot_req_data(const node_delete_snapshot_req_data& other572) {
        task_id = other572.task_id;
        snapshot_name = other572.snapshot_name;
        peer_nodes_list = other572.peer_nodes_list;
        additional = other572.additional;
        wallet = other572.wallet;
        nonce = other572.nonce;
        sign = other572.sign;
        multisig_wallets = other572.multisig_wallets;
        multisig_threshold = other572.multisig_threshold;
        multisig_signs = other572.multisig_signs;
        session_id = other572.session_id;
        session_id_sign = other572.session_id_sign;
    }
    node_delete_snapshot_req_data& node_delete_snapshot_req_data::operator=(const node_delete_snapshot_req_data& other573) {
        task_id = other573.task_id;
        snapshot_name = other573.snapshot_name;
        peer_nodes_list = other573.peer_nodes_list;
        additional = other573.additional;
        wallet = other573.wallet;
        nonce = other573.nonce;
        sign = other573.sign;
        multisig_wallets = other573.multisig_wallets;
        multisig_threshold = other573.multisig_threshold;
        multisig_signs = other573.multisig_signs;
        session_id = other573.session_id;
        session_id_sign = other573.session_id_sign;
        return *this;
    }
    void node_delete_snapshot_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "snapshot_name=" << to_string(snapshot_name);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_delete_snapshot_req_body::~node_delete_snapshot_req_body() throw() {
    }


    void node_delete_snapshot_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_req_body &a, node_delete_snapshot_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_snapshot_req_body::node_delete_snapshot_req_body(const node_delete_snapshot_req_body& other574) {
        data = other574.data;
    }
    node_delete_snapshot_req_body& node_delete_snapshot_req_body::operator=(const node_delete_snapshot_req_body& other575) {
        data = other575.data;
        return *this;
    }
    void node_delete_snapshot_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_snapshot_req::~node_delete_snapshot_req() throw() {
    }


    void node_delete_snapshot_req::__set_body(const node_delete_snapshot_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_req &a, node_delete_snapshot_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_snapshot_req::node_delete_snapshot_req(const node_delete_snapshot_req& other576) {
        body = other576.body;
        __isset = other576.__isset;
    }
    node_delete_snapshot_req& node_delete_snapshot_req::operator=(const node_delete_snapshot_req& other577) {
        body = other577.body;
        __isset = other577.__isset;
        return *this;
    }
    void node_delete_snapshot_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_snapshot_rsp_body::~node_delete_snapshot_rsp_body() throw() {
    }


    void node_delete_snapshot_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_rsp_body &a, node_delete_snapshot_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_snapshot_rsp_body::node_delete_snapshot_rsp_body(const node_delete_snapshot_rsp_body& other578) {
        data = other578.data;
    }
    node_delete_snapshot_rsp_body& node_delete_snapshot_rsp_body::operator=(const node_delete_snapshot_rsp_body& other579) {
        data = other579.data;
        return *this;
    }
    void node_delete_snapshot_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_snapshot_rsp::~node_delete_snapshot_rsp() throw() {
    }


    void node_delete_snapshot_rsp::__set_body(const node_delete_snapshot_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_rsp &a, node_delete_snapshot_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_snapshot_rsp::node_delete_snapshot_rsp(const node_delete_snapshot_rsp& other580) {
        body = other580.body;
        __isset = other580.__isset;
    }
    node_delete_snapshot_rsp& node_delete_snapshot_rsp::operator=(const node_delete_snapshot_rsp& other581) {
        body = other581.body;
        __isset = other581.__isset;
        return *this;
    }
    void node_delete_snapshot_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }

} // namespace
