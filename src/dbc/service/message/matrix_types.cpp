/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "matrix_types.h"

#include <algorithm>
#include <ostream>

namespace dbc {


    empty::~empty() throw() {
    }

    std::ostream& operator<<(std::ostream& out, const empty& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t empty::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            xfer += iprot->skip(ftype);
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t empty::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("empty");

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(empty &a, empty &b) {
        using ::std::swap;
        (void) a;
        (void) b;
    }

    empty::empty(const empty& other0) {
        (void) other0;
    }
    empty& empty::operator=(const empty& other1) {
        (void) other1;
        return *this;
    }
    void empty::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "empty(";
        out << ")";
    }


    network_address::~network_address() throw() {
    }


    void network_address::__set_ip(const std::string& val) {
        this->ip = val;
    }

    void network_address::__set_port(const int16_t val) {
        this->port = val;
    }
    std::ostream& operator<<(std::ostream& out, const network_address& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t network_address::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_ip = false;
        bool isset_port = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->ip);
                        isset_ip = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_I16) {
                        xfer += iprot->readI16(this->port);
                        isset_port = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_ip)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_port)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t network_address::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("network_address");

        xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->ip);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 2);
        xfer += oprot->writeI16(this->port);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(network_address &a, network_address &b) {
        using ::std::swap;
        swap(a.ip, b.ip);
        swap(a.port, b.port);
    }

    network_address::network_address(const network_address& other2) {
        ip = other2.ip;
        port = other2.port;
    }
    network_address& network_address::operator=(const network_address& other3) {
        ip = other3.ip;
        port = other3.port;
        return *this;
    }
    void network_address::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "network_address(";
        out << "ip=" << to_string(ip);
        out << ", " << "port=" << to_string(port);
        out << ")";
    }


    shake_hand_req::~shake_hand_req() throw() {
    }


    void shake_hand_req::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const shake_hand_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t shake_hand_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t shake_hand_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("shake_hand_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(shake_hand_req &a, shake_hand_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    shake_hand_req::shake_hand_req(const shake_hand_req& other4) {
        body = other4.body;
        __isset = other4.__isset;
    }
    shake_hand_req& shake_hand_req::operator=(const shake_hand_req& other5) {
        body = other5.body;
        __isset = other5.__isset;
        return *this;
    }
    void shake_hand_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "shake_hand_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    shake_hand_resp::~shake_hand_resp() throw() {
    }


    void shake_hand_resp::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const shake_hand_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t shake_hand_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t shake_hand_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("shake_hand_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(shake_hand_resp &a, shake_hand_resp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    shake_hand_resp::shake_hand_resp(const shake_hand_resp& other6) {
        body = other6.body;
        __isset = other6.__isset;
    }
    shake_hand_resp& shake_hand_resp::operator=(const shake_hand_resp& other7) {
        body = other7.body;
        __isset = other7.__isset;
        return *this;
    }
    void shake_hand_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "shake_hand_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    multisig_sign_item::~multisig_sign_item() throw() {
    }


    void multisig_sign_item::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void multisig_sign_item::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void multisig_sign_item::__set_sign(const std::string& val) {
        this->sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const multisig_sign_item& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t multisig_sign_item::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t multisig_sign_item::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("multisig_sign_item");

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(multisig_sign_item &a, multisig_sign_item &b) {
        using ::std::swap;
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
    }

    multisig_sign_item::multisig_sign_item(const multisig_sign_item& other8) {
        wallet = other8.wallet;
        nonce = other8.nonce;
        sign = other8.sign;
    }
    multisig_sign_item& multisig_sign_item::operator=(const multisig_sign_item& other9) {
        wallet = other9.wallet;
        nonce = other9.nonce;
        sign = other9.sign;
        return *this;
    }
    void multisig_sign_item::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "multisig_sign_item(";
        out << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ")";
    }


    node_list_images_req_data::~node_list_images_req_data() throw() {
    }


    void node_list_images_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_list_images_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size10;
                            ::apache::thrift::protocol::TType _etype13;
                            xfer += iprot->readListBegin(_etype13, _size10);
                            this->peer_nodes_list.resize(_size10);
                            uint32_t _i14;
                            for (_i14 = 0; _i14 < _size10; ++_i14)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i14]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_images_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter15;
            for (_iter15 = this->peer_nodes_list.begin(); _iter15 != this->peer_nodes_list.end(); ++_iter15)
            {
                xfer += oprot->writeString((*_iter15));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_req_data &a, node_list_images_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
    }

    node_list_images_req_data::node_list_images_req_data(const node_list_images_req_data& other16) {
        peer_nodes_list = other16.peer_nodes_list;
        additional = other16.additional;
    }
    node_list_images_req_data& node_list_images_req_data::operator=(const node_list_images_req_data& other17) {
        peer_nodes_list = other17.peer_nodes_list;
        additional = other17.additional;
        return *this;
    }
    void node_list_images_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ")";
    }


    node_list_images_req_body::~node_list_images_req_body() throw() {
    }


    void node_list_images_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_images_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_req_body &a, node_list_images_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_images_req_body::node_list_images_req_body(const node_list_images_req_body& other18) {
        data = other18.data;
    }
    node_list_images_req_body& node_list_images_req_body::operator=(const node_list_images_req_body& other19) {
        data = other19.data;
        return *this;
    }
    void node_list_images_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_images_req::~node_list_images_req() throw() {
    }


    void node_list_images_req::__set_body(const node_list_images_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_images_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_req &a, node_list_images_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_images_req::node_list_images_req(const node_list_images_req& other20) {
        body = other20.body;
        __isset = other20.__isset;
    }
    node_list_images_req& node_list_images_req::operator=(const node_list_images_req& other21) {
        body = other21.body;
        __isset = other21.__isset;
        return *this;
    }
    void node_list_images_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_images_rsp_body::~node_list_images_rsp_body() throw() {
    }


    void node_list_images_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_images_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_rsp_body &a, node_list_images_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_images_rsp_body::node_list_images_rsp_body(const node_list_images_rsp_body& other22) {
        data = other22.data;
    }
    node_list_images_rsp_body& node_list_images_rsp_body::operator=(const node_list_images_rsp_body& other23) {
        data = other23.data;
        return *this;
    }
    void node_list_images_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_images_rsp::~node_list_images_rsp() throw() {
    }


    void node_list_images_rsp::__set_body(const node_list_images_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_images_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_rsp &a, node_list_images_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_images_rsp::node_list_images_rsp(const node_list_images_rsp& other24) {
        body = other24.body;
        __isset = other24.__isset;
    }
    node_list_images_rsp& node_list_images_rsp::operator=(const node_list_images_rsp& other25) {
        body = other25.body;
        __isset = other25.__isset;
        return *this;
    }
    void node_list_images_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_download_image_req_data::~node_download_image_req_data() throw() {
    }


    void node_download_image_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_download_image_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_download_image_req_data::__set_image(const std::string& val) {
        this->image = val;
    }

    void node_download_image_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_download_image_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_download_image_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_download_image_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_download_image_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_download_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_download_image_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_download_image_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_image = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size26;
                            ::apache::thrift::protocol::TType _etype29;
                            xfer += iprot->readListBegin(_etype29, _size26);
                            this->peer_nodes_list.resize(_size26);
                            uint32_t _i30;
                            for (_i30 = 0; _i30 < _size26; ++_i30)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i30]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->image);
                        isset_image = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size31;
                            ::apache::thrift::protocol::TType _etype34;
                            xfer += iprot->readListBegin(_etype34, _size31);
                            this->multisig_wallets.resize(_size31);
                            uint32_t _i35;
                            for (_i35 = 0; _i35 < _size31; ++_i35)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i35]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size36;
                            ::apache::thrift::protocol::TType _etype39;
                            xfer += iprot->readListBegin(_etype39, _size36);
                            this->multisig_signs.resize(_size36);
                            uint32_t _i40;
                            for (_i40 = 0; _i40 < _size36; ++_i40)
                            {
                                xfer += this->multisig_signs[_i40].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_image)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter41;
            for (_iter41 = this->peer_nodes_list.begin(); _iter41 != this->peer_nodes_list.end(); ++_iter41)
            {
                xfer += oprot->writeString((*_iter41));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->image);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter42;
            for (_iter42 = this->multisig_wallets.begin(); _iter42 != this->multisig_wallets.end(); ++_iter42)
            {
                xfer += oprot->writeString((*_iter42));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter43;
            for (_iter43 = this->multisig_signs.begin(); _iter43 != this->multisig_signs.end(); ++_iter43)
            {
                xfer += (*_iter43).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_req_data &a, node_download_image_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.image, b.image);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_download_image_req_data::node_download_image_req_data(const node_download_image_req_data& other44) {
        peer_nodes_list = other44.peer_nodes_list;
        additional = other44.additional;
        image = other44.image;
        wallet = other44.wallet;
        nonce = other44.nonce;
        sign = other44.sign;
        multisig_wallets = other44.multisig_wallets;
        multisig_threshold = other44.multisig_threshold;
        multisig_signs = other44.multisig_signs;
        session_id = other44.session_id;
        session_id_sign = other44.session_id_sign;
    }
    node_download_image_req_data& node_download_image_req_data::operator=(const node_download_image_req_data& other45) {
        peer_nodes_list = other45.peer_nodes_list;
        additional = other45.additional;
        image = other45.image;
        wallet = other45.wallet;
        nonce = other45.nonce;
        sign = other45.sign;
        multisig_wallets = other45.multisig_wallets;
        multisig_threshold = other45.multisig_threshold;
        multisig_signs = other45.multisig_signs;
        session_id = other45.session_id;
        session_id_sign = other45.session_id_sign;
        return *this;
    }
    void node_download_image_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "image=" << to_string(image);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_download_image_req_body::~node_download_image_req_body() throw() {
    }


    void node_download_image_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_req_body &a, node_download_image_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_download_image_req_body::node_download_image_req_body(const node_download_image_req_body& other46) {
        data = other46.data;
    }
    node_download_image_req_body& node_download_image_req_body::operator=(const node_download_image_req_body& other47) {
        data = other47.data;
        return *this;
    }
    void node_download_image_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_download_image_req::~node_download_image_req() throw() {
    }


    void node_download_image_req::__set_body(const node_download_image_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_download_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_req &a, node_download_image_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_download_image_req::node_download_image_req(const node_download_image_req& other48) {
        body = other48.body;
        __isset = other48.__isset;
    }
    node_download_image_req& node_download_image_req::operator=(const node_download_image_req& other49) {
        body = other49.body;
        __isset = other49.__isset;
        return *this;
    }
    void node_download_image_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_download_image_rsp_body::~node_download_image_rsp_body() throw() {
    }


    void node_download_image_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_rsp_body &a, node_download_image_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_download_image_rsp_body::node_download_image_rsp_body(const node_download_image_rsp_body& other50) {
        data = other50.data;
    }
    node_download_image_rsp_body& node_download_image_rsp_body::operator=(const node_download_image_rsp_body& other51) {
        data = other51.data;
        return *this;
    }
    void node_download_image_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_download_image_rsp::~node_download_image_rsp() throw() {
    }


    void node_download_image_rsp::__set_body(const node_download_image_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_download_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_rsp &a, node_download_image_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_download_image_rsp::node_download_image_rsp(const node_download_image_rsp& other52) {
        body = other52.body;
        __isset = other52.__isset;
    }
    node_download_image_rsp& node_download_image_rsp::operator=(const node_download_image_rsp& other53) {
        body = other53.body;
        __isset = other53.__isset;
        return *this;
    }
    void node_download_image_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_upload_image_req_data::~node_upload_image_req_data() throw() {
    }


    void node_upload_image_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_upload_image_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_upload_image_req_data::__set_image(const std::string& val) {
        this->image = val;
    }

    void node_upload_image_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_upload_image_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_upload_image_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_upload_image_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_upload_image_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_upload_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_upload_image_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_upload_image_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_image = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size54;
                            ::apache::thrift::protocol::TType _etype57;
                            xfer += iprot->readListBegin(_etype57, _size54);
                            this->peer_nodes_list.resize(_size54);
                            uint32_t _i58;
                            for (_i58 = 0; _i58 < _size54; ++_i58)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i58]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->image);
                        isset_image = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size59;
                            ::apache::thrift::protocol::TType _etype62;
                            xfer += iprot->readListBegin(_etype62, _size59);
                            this->multisig_wallets.resize(_size59);
                            uint32_t _i63;
                            for (_i63 = 0; _i63 < _size59; ++_i63)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i63]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size64;
                            ::apache::thrift::protocol::TType _etype67;
                            xfer += iprot->readListBegin(_etype67, _size64);
                            this->multisig_signs.resize(_size64);
                            uint32_t _i68;
                            for (_i68 = 0; _i68 < _size64; ++_i68)
                            {
                                xfer += this->multisig_signs[_i68].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_image)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter69;
            for (_iter69 = this->peer_nodes_list.begin(); _iter69 != this->peer_nodes_list.end(); ++_iter69)
            {
                xfer += oprot->writeString((*_iter69));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->image);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter70;
            for (_iter70 = this->multisig_wallets.begin(); _iter70 != this->multisig_wallets.end(); ++_iter70)
            {
                xfer += oprot->writeString((*_iter70));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter71;
            for (_iter71 = this->multisig_signs.begin(); _iter71 != this->multisig_signs.end(); ++_iter71)
            {
                xfer += (*_iter71).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_req_data &a, node_upload_image_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.image, b.image);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_upload_image_req_data::node_upload_image_req_data(const node_upload_image_req_data& other72) {
        peer_nodes_list = other72.peer_nodes_list;
        additional = other72.additional;
        image = other72.image;
        wallet = other72.wallet;
        nonce = other72.nonce;
        sign = other72.sign;
        multisig_wallets = other72.multisig_wallets;
        multisig_threshold = other72.multisig_threshold;
        multisig_signs = other72.multisig_signs;
        session_id = other72.session_id;
        session_id_sign = other72.session_id_sign;
    }
    node_upload_image_req_data& node_upload_image_req_data::operator=(const node_upload_image_req_data& other73) {
        peer_nodes_list = other73.peer_nodes_list;
        additional = other73.additional;
        image = other73.image;
        wallet = other73.wallet;
        nonce = other73.nonce;
        sign = other73.sign;
        multisig_wallets = other73.multisig_wallets;
        multisig_threshold = other73.multisig_threshold;
        multisig_signs = other73.multisig_signs;
        session_id = other73.session_id;
        session_id_sign = other73.session_id_sign;
        return *this;
    }
    void node_upload_image_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "image=" << to_string(image);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_upload_image_req_body::~node_upload_image_req_body() throw() {
    }


    void node_upload_image_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_req_body &a, node_upload_image_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_upload_image_req_body::node_upload_image_req_body(const node_upload_image_req_body& other74) {
        data = other74.data;
    }
    node_upload_image_req_body& node_upload_image_req_body::operator=(const node_upload_image_req_body& other75) {
        data = other75.data;
        return *this;
    }
    void node_upload_image_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_upload_image_req::~node_upload_image_req() throw() {
    }


    void node_upload_image_req::__set_body(const node_upload_image_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_upload_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_req &a, node_upload_image_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_upload_image_req::node_upload_image_req(const node_upload_image_req& other76) {
        body = other76.body;
        __isset = other76.__isset;
    }
    node_upload_image_req& node_upload_image_req::operator=(const node_upload_image_req& other77) {
        body = other77.body;
        __isset = other77.__isset;
        return *this;
    }
    void node_upload_image_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_upload_image_rsp_body::~node_upload_image_rsp_body() throw() {
    }


    void node_upload_image_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_rsp_body &a, node_upload_image_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_upload_image_rsp_body::node_upload_image_rsp_body(const node_upload_image_rsp_body& other78) {
        data = other78.data;
    }
    node_upload_image_rsp_body& node_upload_image_rsp_body::operator=(const node_upload_image_rsp_body& other79) {
        data = other79.data;
        return *this;
    }
    void node_upload_image_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_upload_image_rsp::~node_upload_image_rsp() throw() {
    }


    void node_upload_image_rsp::__set_body(const node_upload_image_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_upload_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_rsp &a, node_upload_image_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_upload_image_rsp::node_upload_image_rsp(const node_upload_image_rsp& other80) {
        body = other80.body;
        __isset = other80.__isset;
    }
    node_upload_image_rsp& node_upload_image_rsp::operator=(const node_upload_image_rsp& other81) {
        body = other81.body;
        __isset = other81.__isset;
        return *this;
    }
    void node_upload_image_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_task_req_data::~node_list_task_req_data() throw() {
    }


    void node_list_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_list_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_list_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_list_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_list_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_list_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_list_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_list_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_list_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_list_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_list_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size82;
                            ::apache::thrift::protocol::TType _etype85;
                            xfer += iprot->readListBegin(_etype85, _size82);
                            this->peer_nodes_list.resize(_size82);
                            uint32_t _i86;
                            for (_i86 = 0; _i86 < _size82; ++_i86)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i86]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size87;
                            ::apache::thrift::protocol::TType _etype90;
                            xfer += iprot->readListBegin(_etype90, _size87);
                            this->multisig_wallets.resize(_size87);
                            uint32_t _i91;
                            for (_i91 = 0; _i91 < _size87; ++_i91)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i91]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size92;
                            ::apache::thrift::protocol::TType _etype95;
                            xfer += iprot->readListBegin(_etype95, _size92);
                            this->multisig_signs.resize(_size92);
                            uint32_t _i96;
                            for (_i96 = 0; _i96 < _size92; ++_i96)
                            {
                                xfer += this->multisig_signs[_i96].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter97;
            for (_iter97 = this->peer_nodes_list.begin(); _iter97 != this->peer_nodes_list.end(); ++_iter97)
            {
                xfer += oprot->writeString((*_iter97));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter98;
            for (_iter98 = this->multisig_wallets.begin(); _iter98 != this->multisig_wallets.end(); ++_iter98)
            {
                xfer += oprot->writeString((*_iter98));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter99;
            for (_iter99 = this->multisig_signs.begin(); _iter99 != this->multisig_signs.end(); ++_iter99)
            {
                xfer += (*_iter99).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req_data &a, node_list_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_list_task_req_data::node_list_task_req_data(const node_list_task_req_data& other100) {
        task_id = other100.task_id;
        peer_nodes_list = other100.peer_nodes_list;
        additional = other100.additional;
        wallet = other100.wallet;
        nonce = other100.nonce;
        sign = other100.sign;
        multisig_wallets = other100.multisig_wallets;
        multisig_threshold = other100.multisig_threshold;
        multisig_signs = other100.multisig_signs;
        session_id = other100.session_id;
        session_id_sign = other100.session_id_sign;
    }
    node_list_task_req_data& node_list_task_req_data::operator=(const node_list_task_req_data& other101) {
        task_id = other101.task_id;
        peer_nodes_list = other101.peer_nodes_list;
        additional = other101.additional;
        wallet = other101.wallet;
        nonce = other101.nonce;
        sign = other101.sign;
        multisig_wallets = other101.multisig_wallets;
        multisig_threshold = other101.multisig_threshold;
        multisig_signs = other101.multisig_signs;
        session_id = other101.session_id;
        session_id_sign = other101.session_id_sign;
        return *this;
    }
    void node_list_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_list_task_req_body::~node_list_task_req_body() throw() {
    }


    void node_list_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req_body &a, node_list_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_task_req_body::node_list_task_req_body(const node_list_task_req_body& other102) {
        data = other102.data;
    }
    node_list_task_req_body& node_list_task_req_body::operator=(const node_list_task_req_body& other103) {
        data = other103.data;
        return *this;
    }
    void node_list_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_task_req::~node_list_task_req() throw() {
    }


    void node_list_task_req::__set_body(const node_list_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req &a, node_list_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_task_req::node_list_task_req(const node_list_task_req& other104) {
        body = other104.body;
        __isset = other104.__isset;
    }
    node_list_task_req& node_list_task_req::operator=(const node_list_task_req& other105) {
        body = other105.body;
        __isset = other105.__isset;
        return *this;
    }
    void node_list_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_task_rsp_body::~node_list_task_rsp_body() throw() {
    }


    void node_list_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_rsp_body &a, node_list_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_task_rsp_body::node_list_task_rsp_body(const node_list_task_rsp_body& other106) {
        data = other106.data;
    }
    node_list_task_rsp_body& node_list_task_rsp_body::operator=(const node_list_task_rsp_body& other107) {
        data = other107.data;
        return *this;
    }
    void node_list_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_task_rsp::~node_list_task_rsp() throw() {
    }


    void node_list_task_rsp::__set_body(const node_list_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_rsp &a, node_list_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_task_rsp::node_list_task_rsp(const node_list_task_rsp& other108) {
        body = other108.body;
        __isset = other108.__isset;
    }
    node_list_task_rsp& node_list_task_rsp::operator=(const node_list_task_rsp& other109) {
        body = other109.body;
        __isset = other109.__isset;
        return *this;
    }
    void node_list_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_task_req_data::~node_create_task_req_data() throw() {
    }


    void node_create_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_create_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_create_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_create_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_create_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_create_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_create_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_create_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_create_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_create_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size110;
                            ::apache::thrift::protocol::TType _etype113;
                            xfer += iprot->readListBegin(_etype113, _size110);
                            this->peer_nodes_list.resize(_size110);
                            uint32_t _i114;
                            for (_i114 = 0; _i114 < _size110; ++_i114)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i114]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size115;
                            ::apache::thrift::protocol::TType _etype118;
                            xfer += iprot->readListBegin(_etype118, _size115);
                            this->multisig_wallets.resize(_size115);
                            uint32_t _i119;
                            for (_i119 = 0; _i119 < _size115; ++_i119)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i119]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size120;
                            ::apache::thrift::protocol::TType _etype123;
                            xfer += iprot->readListBegin(_etype123, _size120);
                            this->multisig_signs.resize(_size120);
                            uint32_t _i124;
                            for (_i124 = 0; _i124 < _size120; ++_i124)
                            {
                                xfer += this->multisig_signs[_i124].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter125;
            for (_iter125 = this->peer_nodes_list.begin(); _iter125 != this->peer_nodes_list.end(); ++_iter125)
            {
                xfer += oprot->writeString((*_iter125));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter126;
            for (_iter126 = this->multisig_wallets.begin(); _iter126 != this->multisig_wallets.end(); ++_iter126)
            {
                xfer += oprot->writeString((*_iter126));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter127;
            for (_iter127 = this->multisig_signs.begin(); _iter127 != this->multisig_signs.end(); ++_iter127)
            {
                xfer += (*_iter127).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req_data &a, node_create_task_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_create_task_req_data::node_create_task_req_data(const node_create_task_req_data& other128) {
        peer_nodes_list = other128.peer_nodes_list;
        additional = other128.additional;
        wallet = other128.wallet;
        nonce = other128.nonce;
        sign = other128.sign;
        multisig_wallets = other128.multisig_wallets;
        multisig_threshold = other128.multisig_threshold;
        multisig_signs = other128.multisig_signs;
        session_id = other128.session_id;
        session_id_sign = other128.session_id_sign;
    }
    node_create_task_req_data& node_create_task_req_data::operator=(const node_create_task_req_data& other129) {
        peer_nodes_list = other129.peer_nodes_list;
        additional = other129.additional;
        wallet = other129.wallet;
        nonce = other129.nonce;
        sign = other129.sign;
        multisig_wallets = other129.multisig_wallets;
        multisig_threshold = other129.multisig_threshold;
        multisig_signs = other129.multisig_signs;
        session_id = other129.session_id;
        session_id_sign = other129.session_id_sign;
        return *this;
    }
    void node_create_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_create_task_req_body::~node_create_task_req_body() throw() {
    }


    void node_create_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req_body &a, node_create_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_task_req_body::node_create_task_req_body(const node_create_task_req_body& other130) {
        data = other130.data;
    }
    node_create_task_req_body& node_create_task_req_body::operator=(const node_create_task_req_body& other131) {
        data = other131.data;
        return *this;
    }
    void node_create_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_task_req::~node_create_task_req() throw() {
    }


    void node_create_task_req::__set_body(const node_create_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req &a, node_create_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_task_req::node_create_task_req(const node_create_task_req& other132) {
        body = other132.body;
        __isset = other132.__isset;
    }
    node_create_task_req& node_create_task_req::operator=(const node_create_task_req& other133) {
        body = other133.body;
        __isset = other133.__isset;
        return *this;
    }
    void node_create_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_task_rsp_body::~node_create_task_rsp_body() throw() {
    }


    void node_create_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_rsp_body &a, node_create_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_task_rsp_body::node_create_task_rsp_body(const node_create_task_rsp_body& other134) {
        data = other134.data;
    }
    node_create_task_rsp_body& node_create_task_rsp_body::operator=(const node_create_task_rsp_body& other135) {
        data = other135.data;
        return *this;
    }
    void node_create_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_task_rsp::~node_create_task_rsp() throw() {
    }


    void node_create_task_rsp::__set_body(const node_create_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_rsp &a, node_create_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_task_rsp::node_create_task_rsp(const node_create_task_rsp& other136) {
        body = other136.body;
        __isset = other136.__isset;
    }
    node_create_task_rsp& node_create_task_rsp::operator=(const node_create_task_rsp& other137) {
        body = other137.body;
        __isset = other137.__isset;
        return *this;
    }
    void node_create_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_start_task_req_data::~node_start_task_req_data() throw() {
    }


    void node_start_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_start_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_start_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_start_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_start_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_start_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_start_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_start_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_start_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_start_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_start_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size138;
                            ::apache::thrift::protocol::TType _etype141;
                            xfer += iprot->readListBegin(_etype141, _size138);
                            this->peer_nodes_list.resize(_size138);
                            uint32_t _i142;
                            for (_i142 = 0; _i142 < _size138; ++_i142)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i142]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size143;
                            ::apache::thrift::protocol::TType _etype146;
                            xfer += iprot->readListBegin(_etype146, _size143);
                            this->multisig_wallets.resize(_size143);
                            uint32_t _i147;
                            for (_i147 = 0; _i147 < _size143; ++_i147)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i147]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size148;
                            ::apache::thrift::protocol::TType _etype151;
                            xfer += iprot->readListBegin(_etype151, _size148);
                            this->multisig_signs.resize(_size148);
                            uint32_t _i152;
                            for (_i152 = 0; _i152 < _size148; ++_i152)
                            {
                                xfer += this->multisig_signs[_i152].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter153;
            for (_iter153 = this->peer_nodes_list.begin(); _iter153 != this->peer_nodes_list.end(); ++_iter153)
            {
                xfer += oprot->writeString((*_iter153));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter154;
            for (_iter154 = this->multisig_wallets.begin(); _iter154 != this->multisig_wallets.end(); ++_iter154)
            {
                xfer += oprot->writeString((*_iter154));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter155;
            for (_iter155 = this->multisig_signs.begin(); _iter155 != this->multisig_signs.end(); ++_iter155)
            {
                xfer += (*_iter155).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req_data &a, node_start_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_start_task_req_data::node_start_task_req_data(const node_start_task_req_data& other156) {
        task_id = other156.task_id;
        peer_nodes_list = other156.peer_nodes_list;
        additional = other156.additional;
        wallet = other156.wallet;
        nonce = other156.nonce;
        sign = other156.sign;
        multisig_wallets = other156.multisig_wallets;
        multisig_threshold = other156.multisig_threshold;
        multisig_signs = other156.multisig_signs;
        session_id = other156.session_id;
        session_id_sign = other156.session_id_sign;
    }
    node_start_task_req_data& node_start_task_req_data::operator=(const node_start_task_req_data& other157) {
        task_id = other157.task_id;
        peer_nodes_list = other157.peer_nodes_list;
        additional = other157.additional;
        wallet = other157.wallet;
        nonce = other157.nonce;
        sign = other157.sign;
        multisig_wallets = other157.multisig_wallets;
        multisig_threshold = other157.multisig_threshold;
        multisig_signs = other157.multisig_signs;
        session_id = other157.session_id;
        session_id_sign = other157.session_id_sign;
        return *this;
    }
    void node_start_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_start_task_req_body::~node_start_task_req_body() throw() {
    }


    void node_start_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req_body &a, node_start_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_start_task_req_body::node_start_task_req_body(const node_start_task_req_body& other158) {
        data = other158.data;
    }
    node_start_task_req_body& node_start_task_req_body::operator=(const node_start_task_req_body& other159) {
        data = other159.data;
        return *this;
    }
    void node_start_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_start_task_req::~node_start_task_req() throw() {
    }


    void node_start_task_req::__set_body(const node_start_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_start_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req &a, node_start_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_start_task_req::node_start_task_req(const node_start_task_req& other160) {
        body = other160.body;
        __isset = other160.__isset;
    }
    node_start_task_req& node_start_task_req::operator=(const node_start_task_req& other161) {
        body = other161.body;
        __isset = other161.__isset;
        return *this;
    }
    void node_start_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_start_task_rsp_body::~node_start_task_rsp_body() throw() {
    }


    void node_start_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_rsp_body &a, node_start_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_start_task_rsp_body::node_start_task_rsp_body(const node_start_task_rsp_body& other162) {
        data = other162.data;
    }
    node_start_task_rsp_body& node_start_task_rsp_body::operator=(const node_start_task_rsp_body& other163) {
        data = other163.data;
        return *this;
    }
    void node_start_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_start_task_rsp::~node_start_task_rsp() throw() {
    }


    void node_start_task_rsp::__set_body(const node_start_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_start_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_rsp &a, node_start_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_start_task_rsp::node_start_task_rsp(const node_start_task_rsp& other164) {
        body = other164.body;
        __isset = other164.__isset;
    }
    node_start_task_rsp& node_start_task_rsp::operator=(const node_start_task_rsp& other165) {
        body = other165.body;
        __isset = other165.__isset;
        return *this;
    }
    void node_start_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_task_req_data::~node_stop_task_req_data() throw() {
    }


    void node_stop_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_stop_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_stop_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_stop_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_stop_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_stop_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_stop_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_stop_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_stop_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_stop_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_stop_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size166;
                            ::apache::thrift::protocol::TType _etype169;
                            xfer += iprot->readListBegin(_etype169, _size166);
                            this->peer_nodes_list.resize(_size166);
                            uint32_t _i170;
                            for (_i170 = 0; _i170 < _size166; ++_i170)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i170]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size171;
                            ::apache::thrift::protocol::TType _etype174;
                            xfer += iprot->readListBegin(_etype174, _size171);
                            this->multisig_wallets.resize(_size171);
                            uint32_t _i175;
                            for (_i175 = 0; _i175 < _size171; ++_i175)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i175]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size176;
                            ::apache::thrift::protocol::TType _etype179;
                            xfer += iprot->readListBegin(_etype179, _size176);
                            this->multisig_signs.resize(_size176);
                            uint32_t _i180;
                            for (_i180 = 0; _i180 < _size176; ++_i180)
                            {
                                xfer += this->multisig_signs[_i180].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter181;
            for (_iter181 = this->peer_nodes_list.begin(); _iter181 != this->peer_nodes_list.end(); ++_iter181)
            {
                xfer += oprot->writeString((*_iter181));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter182;
            for (_iter182 = this->multisig_wallets.begin(); _iter182 != this->multisig_wallets.end(); ++_iter182)
            {
                xfer += oprot->writeString((*_iter182));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter183;
            for (_iter183 = this->multisig_signs.begin(); _iter183 != this->multisig_signs.end(); ++_iter183)
            {
                xfer += (*_iter183).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req_data &a, node_stop_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_stop_task_req_data::node_stop_task_req_data(const node_stop_task_req_data& other184) {
        task_id = other184.task_id;
        peer_nodes_list = other184.peer_nodes_list;
        additional = other184.additional;
        wallet = other184.wallet;
        nonce = other184.nonce;
        sign = other184.sign;
        multisig_wallets = other184.multisig_wallets;
        multisig_threshold = other184.multisig_threshold;
        multisig_signs = other184.multisig_signs;
        session_id = other184.session_id;
        session_id_sign = other184.session_id_sign;
    }
    node_stop_task_req_data& node_stop_task_req_data::operator=(const node_stop_task_req_data& other185) {
        task_id = other185.task_id;
        peer_nodes_list = other185.peer_nodes_list;
        additional = other185.additional;
        wallet = other185.wallet;
        nonce = other185.nonce;
        sign = other185.sign;
        multisig_wallets = other185.multisig_wallets;
        multisig_threshold = other185.multisig_threshold;
        multisig_signs = other185.multisig_signs;
        session_id = other185.session_id;
        session_id_sign = other185.session_id_sign;
        return *this;
    }
    void node_stop_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_stop_task_req_body::~node_stop_task_req_body() throw() {
    }


    void node_stop_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req_body &a, node_stop_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_task_req_body::node_stop_task_req_body(const node_stop_task_req_body& other186) {
        data = other186.data;
    }
    node_stop_task_req_body& node_stop_task_req_body::operator=(const node_stop_task_req_body& other187) {
        data = other187.data;
        return *this;
    }
    void node_stop_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_task_req::~node_stop_task_req() throw() {
    }


    void node_stop_task_req::__set_body(const node_stop_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req &a, node_stop_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_task_req::node_stop_task_req(const node_stop_task_req& other188) {
        body = other188.body;
        __isset = other188.__isset;
    }
    node_stop_task_req& node_stop_task_req::operator=(const node_stop_task_req& other189) {
        body = other189.body;
        __isset = other189.__isset;
        return *this;
    }
    void node_stop_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_task_rsp_body::~node_stop_task_rsp_body() throw() {
    }


    void node_stop_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_rsp_body &a, node_stop_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_task_rsp_body::node_stop_task_rsp_body(const node_stop_task_rsp_body& other190) {
        data = other190.data;
    }
    node_stop_task_rsp_body& node_stop_task_rsp_body::operator=(const node_stop_task_rsp_body& other191) {
        data = other191.data;
        return *this;
    }
    void node_stop_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_task_rsp::~node_stop_task_rsp() throw() {
    }


    void node_stop_task_rsp::__set_body(const node_stop_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_rsp &a, node_stop_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_task_rsp::node_stop_task_rsp(const node_stop_task_rsp& other192) {
        body = other192.body;
        __isset = other192.__isset;
    }
    node_stop_task_rsp& node_stop_task_rsp::operator=(const node_stop_task_rsp& other193) {
        body = other193.body;
        __isset = other193.__isset;
        return *this;
    }
    void node_stop_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_restart_task_req_data::~node_restart_task_req_data() throw() {
    }


    void node_restart_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_restart_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_restart_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_restart_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_restart_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_restart_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_restart_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_restart_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_restart_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_restart_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_restart_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size194;
                            ::apache::thrift::protocol::TType _etype197;
                            xfer += iprot->readListBegin(_etype197, _size194);
                            this->peer_nodes_list.resize(_size194);
                            uint32_t _i198;
                            for (_i198 = 0; _i198 < _size194; ++_i198)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i198]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size199;
                            ::apache::thrift::protocol::TType _etype202;
                            xfer += iprot->readListBegin(_etype202, _size199);
                            this->multisig_wallets.resize(_size199);
                            uint32_t _i203;
                            for (_i203 = 0; _i203 < _size199; ++_i203)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i203]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size204;
                            ::apache::thrift::protocol::TType _etype207;
                            xfer += iprot->readListBegin(_etype207, _size204);
                            this->multisig_signs.resize(_size204);
                            uint32_t _i208;
                            for (_i208 = 0; _i208 < _size204; ++_i208)
                            {
                                xfer += this->multisig_signs[_i208].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter209;
            for (_iter209 = this->peer_nodes_list.begin(); _iter209 != this->peer_nodes_list.end(); ++_iter209)
            {
                xfer += oprot->writeString((*_iter209));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter210;
            for (_iter210 = this->multisig_wallets.begin(); _iter210 != this->multisig_wallets.end(); ++_iter210)
            {
                xfer += oprot->writeString((*_iter210));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter211;
            for (_iter211 = this->multisig_signs.begin(); _iter211 != this->multisig_signs.end(); ++_iter211)
            {
                xfer += (*_iter211).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req_data &a, node_restart_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_restart_task_req_data::node_restart_task_req_data(const node_restart_task_req_data& other212) {
        task_id = other212.task_id;
        peer_nodes_list = other212.peer_nodes_list;
        additional = other212.additional;
        wallet = other212.wallet;
        nonce = other212.nonce;
        sign = other212.sign;
        multisig_wallets = other212.multisig_wallets;
        multisig_threshold = other212.multisig_threshold;
        multisig_signs = other212.multisig_signs;
        session_id = other212.session_id;
        session_id_sign = other212.session_id_sign;
    }
    node_restart_task_req_data& node_restart_task_req_data::operator=(const node_restart_task_req_data& other213) {
        task_id = other213.task_id;
        peer_nodes_list = other213.peer_nodes_list;
        additional = other213.additional;
        wallet = other213.wallet;
        nonce = other213.nonce;
        sign = other213.sign;
        multisig_wallets = other213.multisig_wallets;
        multisig_threshold = other213.multisig_threshold;
        multisig_signs = other213.multisig_signs;
        session_id = other213.session_id;
        session_id_sign = other213.session_id_sign;
        return *this;
    }
    void node_restart_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_restart_task_req_body::~node_restart_task_req_body() throw() {
    }


    void node_restart_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req_body &a, node_restart_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_restart_task_req_body::node_restart_task_req_body(const node_restart_task_req_body& other214) {
        data = other214.data;
    }
    node_restart_task_req_body& node_restart_task_req_body::operator=(const node_restart_task_req_body& other215) {
        data = other215.data;
        return *this;
    }
    void node_restart_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_restart_task_req::~node_restart_task_req() throw() {
    }


    void node_restart_task_req::__set_body(const node_restart_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_restart_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req &a, node_restart_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_restart_task_req::node_restart_task_req(const node_restart_task_req& other216) {
        body = other216.body;
        __isset = other216.__isset;
    }
    node_restart_task_req& node_restart_task_req::operator=(const node_restart_task_req& other217) {
        body = other217.body;
        __isset = other217.__isset;
        return *this;
    }
    void node_restart_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_restart_task_rsp_body::~node_restart_task_rsp_body() throw() {
    }


    void node_restart_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_rsp_body &a, node_restart_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_restart_task_rsp_body::node_restart_task_rsp_body(const node_restart_task_rsp_body& other218) {
        data = other218.data;
    }
    node_restart_task_rsp_body& node_restart_task_rsp_body::operator=(const node_restart_task_rsp_body& other219) {
        data = other219.data;
        return *this;
    }
    void node_restart_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_restart_task_rsp::~node_restart_task_rsp() throw() {
    }


    void node_restart_task_rsp::__set_body(const node_restart_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_restart_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_rsp &a, node_restart_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_restart_task_rsp::node_restart_task_rsp(const node_restart_task_rsp& other220) {
        body = other220.body;
        __isset = other220.__isset;
    }
    node_restart_task_rsp& node_restart_task_rsp::operator=(const node_restart_task_rsp& other221) {
        body = other221.body;
        __isset = other221.__isset;
        return *this;
    }
    void node_restart_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_reset_task_req_data::~node_reset_task_req_data() throw() {
    }


    void node_reset_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_reset_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_reset_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_reset_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_reset_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_reset_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_reset_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_reset_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_reset_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_reset_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_reset_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size222;
                            ::apache::thrift::protocol::TType _etype225;
                            xfer += iprot->readListBegin(_etype225, _size222);
                            this->peer_nodes_list.resize(_size222);
                            uint32_t _i226;
                            for (_i226 = 0; _i226 < _size222; ++_i226)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i226]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size227;
                            ::apache::thrift::protocol::TType _etype230;
                            xfer += iprot->readListBegin(_etype230, _size227);
                            this->multisig_wallets.resize(_size227);
                            uint32_t _i231;
                            for (_i231 = 0; _i231 < _size227; ++_i231)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i231]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size232;
                            ::apache::thrift::protocol::TType _etype235;
                            xfer += iprot->readListBegin(_etype235, _size232);
                            this->multisig_signs.resize(_size232);
                            uint32_t _i236;
                            for (_i236 = 0; _i236 < _size232; ++_i236)
                            {
                                xfer += this->multisig_signs[_i236].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter237;
            for (_iter237 = this->peer_nodes_list.begin(); _iter237 != this->peer_nodes_list.end(); ++_iter237)
            {
                xfer += oprot->writeString((*_iter237));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter238;
            for (_iter238 = this->multisig_wallets.begin(); _iter238 != this->multisig_wallets.end(); ++_iter238)
            {
                xfer += oprot->writeString((*_iter238));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter239;
            for (_iter239 = this->multisig_signs.begin(); _iter239 != this->multisig_signs.end(); ++_iter239)
            {
                xfer += (*_iter239).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req_data &a, node_reset_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_reset_task_req_data::node_reset_task_req_data(const node_reset_task_req_data& other240) {
        task_id = other240.task_id;
        peer_nodes_list = other240.peer_nodes_list;
        additional = other240.additional;
        wallet = other240.wallet;
        nonce = other240.nonce;
        sign = other240.sign;
        multisig_wallets = other240.multisig_wallets;
        multisig_threshold = other240.multisig_threshold;
        multisig_signs = other240.multisig_signs;
        session_id = other240.session_id;
        session_id_sign = other240.session_id_sign;
    }
    node_reset_task_req_data& node_reset_task_req_data::operator=(const node_reset_task_req_data& other241) {
        task_id = other241.task_id;
        peer_nodes_list = other241.peer_nodes_list;
        additional = other241.additional;
        wallet = other241.wallet;
        nonce = other241.nonce;
        sign = other241.sign;
        multisig_wallets = other241.multisig_wallets;
        multisig_threshold = other241.multisig_threshold;
        multisig_signs = other241.multisig_signs;
        session_id = other241.session_id;
        session_id_sign = other241.session_id_sign;
        return *this;
    }
    void node_reset_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_reset_task_req_body::~node_reset_task_req_body() throw() {
    }


    void node_reset_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req_body &a, node_reset_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_reset_task_req_body::node_reset_task_req_body(const node_reset_task_req_body& other242) {
        data = other242.data;
    }
    node_reset_task_req_body& node_reset_task_req_body::operator=(const node_reset_task_req_body& other243) {
        data = other243.data;
        return *this;
    }
    void node_reset_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_reset_task_req::~node_reset_task_req() throw() {
    }


    void node_reset_task_req::__set_body(const node_reset_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_reset_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req &a, node_reset_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_reset_task_req::node_reset_task_req(const node_reset_task_req& other244) {
        body = other244.body;
        __isset = other244.__isset;
    }
    node_reset_task_req& node_reset_task_req::operator=(const node_reset_task_req& other245) {
        body = other245.body;
        __isset = other245.__isset;
        return *this;
    }
    void node_reset_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_reset_task_rsp_body::~node_reset_task_rsp_body() throw() {
    }


    void node_reset_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_rsp_body &a, node_reset_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_reset_task_rsp_body::node_reset_task_rsp_body(const node_reset_task_rsp_body& other246) {
        data = other246.data;
    }
    node_reset_task_rsp_body& node_reset_task_rsp_body::operator=(const node_reset_task_rsp_body& other247) {
        data = other247.data;
        return *this;
    }
    void node_reset_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_reset_task_rsp::~node_reset_task_rsp() throw() {
    }


    void node_reset_task_rsp::__set_body(const node_reset_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_reset_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_rsp &a, node_reset_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_reset_task_rsp::node_reset_task_rsp(const node_reset_task_rsp& other248) {
        body = other248.body;
        __isset = other248.__isset;
    }
    node_reset_task_rsp& node_reset_task_rsp::operator=(const node_reset_task_rsp& other249) {
        body = other249.body;
        __isset = other249.__isset;
        return *this;
    }
    void node_reset_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_task_req_data::~node_delete_task_req_data() throw() {
    }


    void node_delete_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_delete_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_delete_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_delete_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_delete_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_delete_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_delete_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_delete_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_delete_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_delete_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_delete_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size250;
                            ::apache::thrift::protocol::TType _etype253;
                            xfer += iprot->readListBegin(_etype253, _size250);
                            this->peer_nodes_list.resize(_size250);
                            uint32_t _i254;
                            for (_i254 = 0; _i254 < _size250; ++_i254)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i254]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size255;
                            ::apache::thrift::protocol::TType _etype258;
                            xfer += iprot->readListBegin(_etype258, _size255);
                            this->multisig_wallets.resize(_size255);
                            uint32_t _i259;
                            for (_i259 = 0; _i259 < _size255; ++_i259)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i259]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size260;
                            ::apache::thrift::protocol::TType _etype263;
                            xfer += iprot->readListBegin(_etype263, _size260);
                            this->multisig_signs.resize(_size260);
                            uint32_t _i264;
                            for (_i264 = 0; _i264 < _size260; ++_i264)
                            {
                                xfer += this->multisig_signs[_i264].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter265;
            for (_iter265 = this->peer_nodes_list.begin(); _iter265 != this->peer_nodes_list.end(); ++_iter265)
            {
                xfer += oprot->writeString((*_iter265));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter266;
            for (_iter266 = this->multisig_wallets.begin(); _iter266 != this->multisig_wallets.end(); ++_iter266)
            {
                xfer += oprot->writeString((*_iter266));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter267;
            for (_iter267 = this->multisig_signs.begin(); _iter267 != this->multisig_signs.end(); ++_iter267)
            {
                xfer += (*_iter267).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req_data &a, node_delete_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_delete_task_req_data::node_delete_task_req_data(const node_delete_task_req_data& other268) {
        task_id = other268.task_id;
        peer_nodes_list = other268.peer_nodes_list;
        additional = other268.additional;
        wallet = other268.wallet;
        nonce = other268.nonce;
        sign = other268.sign;
        multisig_wallets = other268.multisig_wallets;
        multisig_threshold = other268.multisig_threshold;
        multisig_signs = other268.multisig_signs;
        session_id = other268.session_id;
        session_id_sign = other268.session_id_sign;
    }
    node_delete_task_req_data& node_delete_task_req_data::operator=(const node_delete_task_req_data& other269) {
        task_id = other269.task_id;
        peer_nodes_list = other269.peer_nodes_list;
        additional = other269.additional;
        wallet = other269.wallet;
        nonce = other269.nonce;
        sign = other269.sign;
        multisig_wallets = other269.multisig_wallets;
        multisig_threshold = other269.multisig_threshold;
        multisig_signs = other269.multisig_signs;
        session_id = other269.session_id;
        session_id_sign = other269.session_id_sign;
        return *this;
    }
    void node_delete_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_delete_task_req_body::~node_delete_task_req_body() throw() {
    }


    void node_delete_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req_body &a, node_delete_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_task_req_body::node_delete_task_req_body(const node_delete_task_req_body& other270) {
        data = other270.data;
    }
    node_delete_task_req_body& node_delete_task_req_body::operator=(const node_delete_task_req_body& other271) {
        data = other271.data;
        return *this;
    }
    void node_delete_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_task_req::~node_delete_task_req() throw() {
    }


    void node_delete_task_req::__set_body(const node_delete_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req &a, node_delete_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_task_req::node_delete_task_req(const node_delete_task_req& other272) {
        body = other272.body;
        __isset = other272.__isset;
    }
    node_delete_task_req& node_delete_task_req::operator=(const node_delete_task_req& other273) {
        body = other273.body;
        __isset = other273.__isset;
        return *this;
    }
    void node_delete_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_task_rsp_body::~node_delete_task_rsp_body() throw() {
    }


    void node_delete_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_rsp_body &a, node_delete_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_task_rsp_body::node_delete_task_rsp_body(const node_delete_task_rsp_body& other274) {
        data = other274.data;
    }
    node_delete_task_rsp_body& node_delete_task_rsp_body::operator=(const node_delete_task_rsp_body& other275) {
        data = other275.data;
        return *this;
    }
    void node_delete_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_task_rsp::~node_delete_task_rsp() throw() {
    }


    void node_delete_task_rsp::__set_body(const node_delete_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_rsp &a, node_delete_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_task_rsp::node_delete_task_rsp(const node_delete_task_rsp& other276) {
        body = other276.body;
        __isset = other276.__isset;
    }
    node_delete_task_rsp& node_delete_task_rsp::operator=(const node_delete_task_rsp& other277) {
        body = other277.body;
        __isset = other277.__isset;
        return *this;
    }
    void node_delete_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_task_logs_req_data::~node_task_logs_req_data() throw() {
    }


    void node_task_logs_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_task_logs_req_data::__set_head_or_tail(const int16_t val) {
        this->head_or_tail = val;
    }

    void node_task_logs_req_data::__set_number_of_lines(const int32_t val) {
        this->number_of_lines = val;
    }

    void node_task_logs_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_task_logs_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_task_logs_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_task_logs_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_task_logs_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_task_logs_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_task_logs_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_task_logs_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_task_logs_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_task_logs_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_head_or_tail = false;
        bool isset_number_of_lines = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_I16) {
                        xfer += iprot->readI16(this->head_or_tail);
                        isset_head_or_tail = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->number_of_lines);
                        isset_number_of_lines = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size278;
                            ::apache::thrift::protocol::TType _etype281;
                            xfer += iprot->readListBegin(_etype281, _size278);
                            this->peer_nodes_list.resize(_size278);
                            uint32_t _i282;
                            for (_i282 = 0; _i282 < _size278; ++_i282)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i282]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size283;
                            ::apache::thrift::protocol::TType _etype286;
                            xfer += iprot->readListBegin(_etype286, _size283);
                            this->multisig_wallets.resize(_size283);
                            uint32_t _i287;
                            for (_i287 = 0; _i287 < _size283; ++_i287)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i287]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size288;
                            ::apache::thrift::protocol::TType _etype291;
                            xfer += iprot->readListBegin(_etype291, _size288);
                            this->multisig_signs.resize(_size288);
                            uint32_t _i292;
                            for (_i292 = 0; _i292 < _size288; ++_i292)
                            {
                                xfer += this->multisig_signs[_i292].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 13:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_head_or_tail)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_number_of_lines)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("head_or_tail", ::apache::thrift::protocol::T_I16, 2);
        xfer += oprot->writeI16(this->head_or_tail);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("number_of_lines", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->number_of_lines);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 4);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter293;
            for (_iter293 = this->peer_nodes_list.begin(); _iter293 != this->peer_nodes_list.end(); ++_iter293)
            {
                xfer += oprot->writeString((*_iter293));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 8);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter294;
            for (_iter294 = this->multisig_wallets.begin(); _iter294 != this->multisig_wallets.end(); ++_iter294)
            {
                xfer += oprot->writeString((*_iter294));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 10);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 11);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter295;
            for (_iter295 = this->multisig_signs.begin(); _iter295 != this->multisig_signs.end(); ++_iter295)
            {
                xfer += (*_iter295).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 12);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 13);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req_data &a, node_task_logs_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.head_or_tail, b.head_or_tail);
        swap(a.number_of_lines, b.number_of_lines);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_task_logs_req_data::node_task_logs_req_data(const node_task_logs_req_data& other296) {
        task_id = other296.task_id;
        head_or_tail = other296.head_or_tail;
        number_of_lines = other296.number_of_lines;
        peer_nodes_list = other296.peer_nodes_list;
        additional = other296.additional;
        wallet = other296.wallet;
        nonce = other296.nonce;
        sign = other296.sign;
        multisig_wallets = other296.multisig_wallets;
        multisig_threshold = other296.multisig_threshold;
        multisig_signs = other296.multisig_signs;
        session_id = other296.session_id;
        session_id_sign = other296.session_id_sign;
    }
    node_task_logs_req_data& node_task_logs_req_data::operator=(const node_task_logs_req_data& other297) {
        task_id = other297.task_id;
        head_or_tail = other297.head_or_tail;
        number_of_lines = other297.number_of_lines;
        peer_nodes_list = other297.peer_nodes_list;
        additional = other297.additional;
        wallet = other297.wallet;
        nonce = other297.nonce;
        sign = other297.sign;
        multisig_wallets = other297.multisig_wallets;
        multisig_threshold = other297.multisig_threshold;
        multisig_signs = other297.multisig_signs;
        session_id = other297.session_id;
        session_id_sign = other297.session_id_sign;
        return *this;
    }
    void node_task_logs_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "head_or_tail=" << to_string(head_or_tail);
        out << ", " << "number_of_lines=" << to_string(number_of_lines);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_task_logs_req_body::~node_task_logs_req_body() throw() {
    }


    void node_task_logs_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req_body &a, node_task_logs_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_task_logs_req_body::node_task_logs_req_body(const node_task_logs_req_body& other298) {
        data = other298.data;
    }
    node_task_logs_req_body& node_task_logs_req_body::operator=(const node_task_logs_req_body& other299) {
        data = other299.data;
        return *this;
    }
    void node_task_logs_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_task_logs_req::~node_task_logs_req() throw() {
    }


    void node_task_logs_req::__set_body(const node_task_logs_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_task_logs_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req &a, node_task_logs_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_task_logs_req::node_task_logs_req(const node_task_logs_req& other300) {
        body = other300.body;
        __isset = other300.__isset;
    }
    node_task_logs_req& node_task_logs_req::operator=(const node_task_logs_req& other301) {
        body = other301.body;
        __isset = other301.__isset;
        return *this;
    }
    void node_task_logs_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_task_logs_rsp_body::~node_task_logs_rsp_body() throw() {
    }


    void node_task_logs_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_rsp_body &a, node_task_logs_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_task_logs_rsp_body::node_task_logs_rsp_body(const node_task_logs_rsp_body& other302) {
        data = other302.data;
    }
    node_task_logs_rsp_body& node_task_logs_rsp_body::operator=(const node_task_logs_rsp_body& other303) {
        data = other303.data;
        return *this;
    }
    void node_task_logs_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_task_logs_rsp::~node_task_logs_rsp() throw() {
    }


    void node_task_logs_rsp::__set_body(const node_task_logs_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_task_logs_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_rsp &a, node_task_logs_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_task_logs_rsp::node_task_logs_rsp(const node_task_logs_rsp& other304) {
        body = other304.body;
        __isset = other304.__isset;
    }
    node_task_logs_rsp& node_task_logs_rsp::operator=(const node_task_logs_rsp& other305) {
        body = other305.body;
        __isset = other305.__isset;
        return *this;
    }
    void node_task_logs_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_modify_task_req_data::~node_modify_task_req_data() throw() {
    }


    void node_modify_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_modify_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_modify_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_modify_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_modify_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_modify_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_modify_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_modify_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_modify_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_modify_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_modify_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size306;
                            ::apache::thrift::protocol::TType _etype309;
                            xfer += iprot->readListBegin(_etype309, _size306);
                            this->peer_nodes_list.resize(_size306);
                            uint32_t _i310;
                            for (_i310 = 0; _i310 < _size306; ++_i310)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i310]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size311;
                            ::apache::thrift::protocol::TType _etype314;
                            xfer += iprot->readListBegin(_etype314, _size311);
                            this->multisig_wallets.resize(_size311);
                            uint32_t _i315;
                            for (_i315 = 0; _i315 < _size311; ++_i315)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i315]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size316;
                            ::apache::thrift::protocol::TType _etype319;
                            xfer += iprot->readListBegin(_etype319, _size316);
                            this->multisig_signs.resize(_size316);
                            uint32_t _i320;
                            for (_i320 = 0; _i320 < _size316; ++_i320)
                            {
                                xfer += this->multisig_signs[_i320].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter321;
            for (_iter321 = this->peer_nodes_list.begin(); _iter321 != this->peer_nodes_list.end(); ++_iter321)
            {
                xfer += oprot->writeString((*_iter321));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter322;
            for (_iter322 = this->multisig_wallets.begin(); _iter322 != this->multisig_wallets.end(); ++_iter322)
            {
                xfer += oprot->writeString((*_iter322));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter323;
            for (_iter323 = this->multisig_signs.begin(); _iter323 != this->multisig_signs.end(); ++_iter323)
            {
                xfer += (*_iter323).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req_data &a, node_modify_task_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_modify_task_req_data::node_modify_task_req_data(const node_modify_task_req_data& other324) {
        task_id = other324.task_id;
        peer_nodes_list = other324.peer_nodes_list;
        additional = other324.additional;
        wallet = other324.wallet;
        nonce = other324.nonce;
        sign = other324.sign;
        multisig_wallets = other324.multisig_wallets;
        multisig_threshold = other324.multisig_threshold;
        multisig_signs = other324.multisig_signs;
        session_id = other324.session_id;
        session_id_sign = other324.session_id_sign;
    }
    node_modify_task_req_data& node_modify_task_req_data::operator=(const node_modify_task_req_data& other325) {
        task_id = other325.task_id;
        peer_nodes_list = other325.peer_nodes_list;
        additional = other325.additional;
        wallet = other325.wallet;
        nonce = other325.nonce;
        sign = other325.sign;
        multisig_wallets = other325.multisig_wallets;
        multisig_threshold = other325.multisig_threshold;
        multisig_signs = other325.multisig_signs;
        session_id = other325.session_id;
        session_id_sign = other325.session_id_sign;
        return *this;
    }
    void node_modify_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_modify_task_req_body::~node_modify_task_req_body() throw() {
    }


    void node_modify_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req_body &a, node_modify_task_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_modify_task_req_body::node_modify_task_req_body(const node_modify_task_req_body& other326) {
        data = other326.data;
    }
    node_modify_task_req_body& node_modify_task_req_body::operator=(const node_modify_task_req_body& other327) {
        data = other327.data;
        return *this;
    }
    void node_modify_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_modify_task_req::~node_modify_task_req() throw() {
    }


    void node_modify_task_req::__set_body(const node_modify_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_modify_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req &a, node_modify_task_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_modify_task_req::node_modify_task_req(const node_modify_task_req& other328) {
        body = other328.body;
        __isset = other328.__isset;
    }
    node_modify_task_req& node_modify_task_req::operator=(const node_modify_task_req& other329) {
        body = other329.body;
        __isset = other329.__isset;
        return *this;
    }
    void node_modify_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_modify_task_rsp_body::~node_modify_task_rsp_body() throw() {
    }


    void node_modify_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_rsp_body &a, node_modify_task_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_modify_task_rsp_body::node_modify_task_rsp_body(const node_modify_task_rsp_body& other330) {
        data = other330.data;
    }
    node_modify_task_rsp_body& node_modify_task_rsp_body::operator=(const node_modify_task_rsp_body& other331) {
        data = other331.data;
        return *this;
    }
    void node_modify_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_modify_task_rsp::~node_modify_task_rsp() throw() {
    }


    void node_modify_task_rsp::__set_body(const node_modify_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_modify_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_rsp &a, node_modify_task_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_modify_task_rsp::node_modify_task_rsp(const node_modify_task_rsp& other332) {
        body = other332.body;
        __isset = other332.__isset;
    }
    node_modify_task_rsp& node_modify_task_rsp::operator=(const node_modify_task_rsp& other333) {
        body = other333.body;
        __isset = other333.__isset;
        return *this;
    }
    void node_modify_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_session_id_req_data::~node_session_id_req_data() throw() {
    }


    void node_session_id_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_session_id_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_session_id_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_session_id_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_session_id_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_session_id_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_session_id_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_session_id_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size334;
                            ::apache::thrift::protocol::TType _etype337;
                            xfer += iprot->readListBegin(_etype337, _size334);
                            this->peer_nodes_list.resize(_size334);
                            uint32_t _i338;
                            for (_i338 = 0; _i338 < _size334; ++_i338)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i338]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size339;
                            ::apache::thrift::protocol::TType _etype342;
                            xfer += iprot->readListBegin(_etype342, _size339);
                            this->multisig_wallets.resize(_size339);
                            uint32_t _i343;
                            for (_i343 = 0; _i343 < _size339; ++_i343)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i343]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size344;
                            ::apache::thrift::protocol::TType _etype347;
                            xfer += iprot->readListBegin(_etype347, _size344);
                            this->multisig_signs.resize(_size344);
                            uint32_t _i348;
                            for (_i348 = 0; _i348 < _size344; ++_i348)
                            {
                                xfer += this->multisig_signs[_i348].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter349;
            for (_iter349 = this->peer_nodes_list.begin(); _iter349 != this->peer_nodes_list.end(); ++_iter349)
            {
                xfer += oprot->writeString((*_iter349));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter350;
            for (_iter350 = this->multisig_wallets.begin(); _iter350 != this->multisig_wallets.end(); ++_iter350)
            {
                xfer += oprot->writeString((*_iter350));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter351;
            for (_iter351 = this->multisig_signs.begin(); _iter351 != this->multisig_signs.end(); ++_iter351)
            {
                xfer += (*_iter351).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req_data &a, node_session_id_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
    }

    node_session_id_req_data::node_session_id_req_data(const node_session_id_req_data& other352) {
        peer_nodes_list = other352.peer_nodes_list;
        additional = other352.additional;
        wallet = other352.wallet;
        nonce = other352.nonce;
        sign = other352.sign;
        multisig_wallets = other352.multisig_wallets;
        multisig_threshold = other352.multisig_threshold;
        multisig_signs = other352.multisig_signs;
    }
    node_session_id_req_data& node_session_id_req_data::operator=(const node_session_id_req_data& other353) {
        peer_nodes_list = other353.peer_nodes_list;
        additional = other353.additional;
        wallet = other353.wallet;
        nonce = other353.nonce;
        sign = other353.sign;
        multisig_wallets = other353.multisig_wallets;
        multisig_threshold = other353.multisig_threshold;
        multisig_signs = other353.multisig_signs;
        return *this;
    }
    void node_session_id_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ")";
    }


    node_session_id_req_body::~node_session_id_req_body() throw() {
    }


    void node_session_id_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req_body &a, node_session_id_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_session_id_req_body::node_session_id_req_body(const node_session_id_req_body& other354) {
        data = other354.data;
    }
    node_session_id_req_body& node_session_id_req_body::operator=(const node_session_id_req_body& other355) {
        data = other355.data;
        return *this;
    }
    void node_session_id_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_session_id_req::~node_session_id_req() throw() {
    }


    void node_session_id_req::__set_body(const node_session_id_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_session_id_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req &a, node_session_id_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_session_id_req::node_session_id_req(const node_session_id_req& other356) {
        body = other356.body;
        __isset = other356.__isset;
    }
    node_session_id_req& node_session_id_req::operator=(const node_session_id_req& other357) {
        body = other357.body;
        __isset = other357.__isset;
        return *this;
    }
    void node_session_id_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_session_id_rsp_body::~node_session_id_rsp_body() throw() {
    }


    void node_session_id_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_rsp_body &a, node_session_id_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_session_id_rsp_body::node_session_id_rsp_body(const node_session_id_rsp_body& other358) {
        data = other358.data;
    }
    node_session_id_rsp_body& node_session_id_rsp_body::operator=(const node_session_id_rsp_body& other359) {
        data = other359.data;
        return *this;
    }
    void node_session_id_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_session_id_rsp::~node_session_id_rsp() throw() {
    }


    void node_session_id_rsp::__set_body(const node_session_id_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_session_id_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_rsp &a, node_session_id_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_session_id_rsp::node_session_id_rsp(const node_session_id_rsp& other360) {
        body = other360.body;
        __isset = other360.__isset;
    }
    node_session_id_rsp& node_session_id_rsp::operator=(const node_session_id_rsp& other361) {
        body = other361.body;
        __isset = other361.__isset;
        return *this;
    }
    void node_session_id_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_query_node_info_req_data::~node_query_node_info_req_data() throw() {
    }


    void node_query_node_info_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_query_node_info_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_query_node_info_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_query_node_info_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_query_node_info_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_query_node_info_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_query_node_info_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_query_node_info_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_query_node_info_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_query_node_info_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size362;
                            ::apache::thrift::protocol::TType _etype365;
                            xfer += iprot->readListBegin(_etype365, _size362);
                            this->peer_nodes_list.resize(_size362);
                            uint32_t _i366;
                            for (_i366 = 0; _i366 < _size362; ++_i366)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i366]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size367;
                            ::apache::thrift::protocol::TType _etype370;
                            xfer += iprot->readListBegin(_etype370, _size367);
                            this->multisig_wallets.resize(_size367);
                            uint32_t _i371;
                            for (_i371 = 0; _i371 < _size367; ++_i371)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i371]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size372;
                            ::apache::thrift::protocol::TType _etype375;
                            xfer += iprot->readListBegin(_etype375, _size372);
                            this->multisig_signs.resize(_size372);
                            uint32_t _i376;
                            for (_i376 = 0; _i376 < _size372; ++_i376)
                            {
                                xfer += this->multisig_signs[_i376].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter377;
            for (_iter377 = this->peer_nodes_list.begin(); _iter377 != this->peer_nodes_list.end(); ++_iter377)
            {
                xfer += oprot->writeString((*_iter377));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter378;
            for (_iter378 = this->multisig_wallets.begin(); _iter378 != this->multisig_wallets.end(); ++_iter378)
            {
                xfer += oprot->writeString((*_iter378));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter379;
            for (_iter379 = this->multisig_signs.begin(); _iter379 != this->multisig_signs.end(); ++_iter379)
            {
                xfer += (*_iter379).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req_data &a, node_query_node_info_req_data &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_query_node_info_req_data::node_query_node_info_req_data(const node_query_node_info_req_data& other380) {
        peer_nodes_list = other380.peer_nodes_list;
        additional = other380.additional;
        wallet = other380.wallet;
        nonce = other380.nonce;
        sign = other380.sign;
        multisig_wallets = other380.multisig_wallets;
        multisig_threshold = other380.multisig_threshold;
        multisig_signs = other380.multisig_signs;
        session_id = other380.session_id;
        session_id_sign = other380.session_id_sign;
    }
    node_query_node_info_req_data& node_query_node_info_req_data::operator=(const node_query_node_info_req_data& other381) {
        peer_nodes_list = other381.peer_nodes_list;
        additional = other381.additional;
        wallet = other381.wallet;
        nonce = other381.nonce;
        sign = other381.sign;
        multisig_wallets = other381.multisig_wallets;
        multisig_threshold = other381.multisig_threshold;
        multisig_signs = other381.multisig_signs;
        session_id = other381.session_id;
        session_id_sign = other381.session_id_sign;
        return *this;
    }
    void node_query_node_info_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_query_node_info_req_body::~node_query_node_info_req_body() throw() {
    }


    void node_query_node_info_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req_body &a, node_query_node_info_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_query_node_info_req_body::node_query_node_info_req_body(const node_query_node_info_req_body& other382) {
        data = other382.data;
    }
    node_query_node_info_req_body& node_query_node_info_req_body::operator=(const node_query_node_info_req_body& other383) {
        data = other383.data;
        return *this;
    }
    void node_query_node_info_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_query_node_info_req::~node_query_node_info_req() throw() {
    }


    void node_query_node_info_req::__set_body(const node_query_node_info_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_query_node_info_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req &a, node_query_node_info_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_query_node_info_req::node_query_node_info_req(const node_query_node_info_req& other384) {
        body = other384.body;
        __isset = other384.__isset;
    }
    node_query_node_info_req& node_query_node_info_req::operator=(const node_query_node_info_req& other385) {
        body = other385.body;
        __isset = other385.__isset;
        return *this;
    }
    void node_query_node_info_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_query_node_info_rsp_body::~node_query_node_info_rsp_body() throw() {
    }


    void node_query_node_info_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_rsp_body &a, node_query_node_info_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_query_node_info_rsp_body::node_query_node_info_rsp_body(const node_query_node_info_rsp_body& other386) {
        data = other386.data;
    }
    node_query_node_info_rsp_body& node_query_node_info_rsp_body::operator=(const node_query_node_info_rsp_body& other387) {
        data = other387.data;
        return *this;
    }
    void node_query_node_info_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_query_node_info_rsp::~node_query_node_info_rsp() throw() {
    }


    void node_query_node_info_rsp::__set_body(const node_query_node_info_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_query_node_info_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_rsp &a, node_query_node_info_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_query_node_info_rsp::node_query_node_info_rsp(const node_query_node_info_rsp& other388) {
        body = other388.body;
        __isset = other388.__isset;
    }
    node_query_node_info_rsp& node_query_node_info_rsp::operator=(const node_query_node_info_rsp& other389) {
        body = other389.body;
        __isset = other389.__isset;
        return *this;
    }
    void node_query_node_info_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_service_info::~node_service_info() throw() {
    }


    void node_service_info::__set_service_list(const std::vector<std::string> & val) {
        this->service_list = val;
    }

    void node_service_info::__set_name(const std::string& val) {
        this->name = val;
        __isset.name = true;
    }

    void node_service_info::__set_time_stamp(const int64_t val) {
        this->time_stamp = val;
        __isset.time_stamp = true;
    }

    void node_service_info::__set_kvs(const std::map<std::string, std::string> & val) {
        this->kvs = val;
        __isset.kvs = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_service_info& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_service_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->service_list.clear();
                            uint32_t _size390;
                            ::apache::thrift::protocol::TType _etype393;
                            xfer += iprot->readListBegin(_etype393, _size390);
                            this->service_list.resize(_size390);
                            uint32_t _i394;
                            for (_i394 = 0; _i394 < _size390; ++_i394)
                            {
                                xfer += iprot->readString(this->service_list[_i394]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_service_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->name);
                        this->__isset.name = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_I64) {
                        xfer += iprot->readI64(this->time_stamp);
                        this->__isset.time_stamp = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_MAP) {
                        {
                            this->kvs.clear();
                            uint32_t _size395;
                            ::apache::thrift::protocol::TType _ktype396;
                            ::apache::thrift::protocol::TType _vtype397;
                            xfer += iprot->readMapBegin(_ktype396, _vtype397, _size395);
                            uint32_t _i399;
                            for (_i399 = 0; _i399 < _size395; ++_i399)
                            {
                                std::string _key400;
                                xfer += iprot->readString(_key400);
                                std::string& _val401 = this->kvs[_key400];
                                xfer += iprot->readString(_val401);
                            }
                            xfer += iprot->readMapEnd();
                        }
                        this->__isset.kvs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_service_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_service_info");

        xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
            std::vector<std::string> ::const_iterator _iter402;
            for (_iter402 = this->service_list.begin(); _iter402 != this->service_list.end(); ++_iter402)
            {
                xfer += oprot->writeString((*_iter402));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        if (this->__isset.name) {
            xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
            xfer += oprot->writeString(this->name);
            xfer += oprot->writeFieldEnd();
        }
        if (this->__isset.time_stamp) {
            xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 3);
            xfer += oprot->writeI64(this->time_stamp);
            xfer += oprot->writeFieldEnd();
        }
        if (this->__isset.kvs) {
            xfer += oprot->writeFieldBegin("kvs", ::apache::thrift::protocol::T_MAP, 4);
            {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kvs.size()));
                std::map<std::string, std::string> ::const_iterator _iter403;
                for (_iter403 = this->kvs.begin(); _iter403 != this->kvs.end(); ++_iter403)
                {
                    xfer += oprot->writeString(_iter403->first);
                    xfer += oprot->writeString(_iter403->second);
                }
                xfer += oprot->writeMapEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_service_info &a, node_service_info &b) {
        using ::std::swap;
        swap(a.service_list, b.service_list);
        swap(a.name, b.name);
        swap(a.time_stamp, b.time_stamp);
        swap(a.kvs, b.kvs);
        swap(a.__isset, b.__isset);
    }

    node_service_info::node_service_info(const node_service_info& other404) {
        service_list = other404.service_list;
        name = other404.name;
        time_stamp = other404.time_stamp;
        kvs = other404.kvs;
        __isset = other404.__isset;
    }
    node_service_info& node_service_info::operator=(const node_service_info& other405) {
        service_list = other405.service_list;
        name = other405.name;
        time_stamp = other405.time_stamp;
        kvs = other405.kvs;
        __isset = other405.__isset;
        return *this;
    }
    void node_service_info::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_service_info(";
        out << "service_list=" << to_string(service_list);
        out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
        out << ", " << "time_stamp="; (__isset.time_stamp ? (out << to_string(time_stamp)) : (out << "<null>"));
        out << ", " << "kvs="; (__isset.kvs ? (out << to_string(kvs)) : (out << "<null>"));
        out << ")";
    }


    service_broadcast_req_body::~service_broadcast_req_body() throw() {
    }


    void service_broadcast_req_body::__set_node_service_info_map(const std::map<std::string, node_service_info> & val) {
        this->node_service_info_map = val;
    }
    std::ostream& operator<<(std::ostream& out, const service_broadcast_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t service_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_service_info_map = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_MAP) {
                        {
                            this->node_service_info_map.clear();
                            uint32_t _size406;
                            ::apache::thrift::protocol::TType _ktype407;
                            ::apache::thrift::protocol::TType _vtype408;
                            xfer += iprot->readMapBegin(_ktype407, _vtype408, _size406);
                            uint32_t _i410;
                            for (_i410 = 0; _i410 < _size406; ++_i410)
                            {
                                std::string _key411;
                                xfer += iprot->readString(_key411);
                                node_service_info& _val412 = this->node_service_info_map[_key411];
                                xfer += _val412.read(iprot);
                            }
                            xfer += iprot->readMapEnd();
                        }
                        isset_node_service_info_map = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_service_info_map)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t service_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("service_broadcast_req_body");

        xfer += oprot->writeFieldBegin("node_service_info_map", ::apache::thrift::protocol::T_MAP, 1);
        {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_service_info_map.size()));
            std::map<std::string, node_service_info> ::const_iterator _iter413;
            for (_iter413 = this->node_service_info_map.begin(); _iter413 != this->node_service_info_map.end(); ++_iter413)
            {
                xfer += oprot->writeString(_iter413->first);
                xfer += _iter413->second.write(oprot);
            }
            xfer += oprot->writeMapEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(service_broadcast_req_body &a, service_broadcast_req_body &b) {
        using ::std::swap;
        swap(a.node_service_info_map, b.node_service_info_map);
    }

    service_broadcast_req_body::service_broadcast_req_body(const service_broadcast_req_body& other414) {
        node_service_info_map = other414.node_service_info_map;
    }
    service_broadcast_req_body& service_broadcast_req_body::operator=(const service_broadcast_req_body& other415) {
        node_service_info_map = other415.node_service_info_map;
        return *this;
    }
    void service_broadcast_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "service_broadcast_req_body(";
        out << "node_service_info_map=" << to_string(node_service_info_map);
        out << ")";
    }


    service_broadcast_req::~service_broadcast_req() throw() {
    }


    void service_broadcast_req::__set_body(const service_broadcast_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const service_broadcast_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t service_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t service_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("service_broadcast_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(service_broadcast_req &a, service_broadcast_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    service_broadcast_req::service_broadcast_req(const service_broadcast_req& other416) {
        body = other416.body;
        __isset = other416.__isset;
    }
    service_broadcast_req& service_broadcast_req::operator=(const service_broadcast_req& other417) {
        body = other417.body;
        __isset = other417.__isset;
        return *this;
    }
    void service_broadcast_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "service_broadcast_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    ver_req_body::~ver_req_body() throw() {
    }


    void ver_req_body::__set_node_id(const std::string& val) {
        this->node_id = val;
    }

    void ver_req_body::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void ver_req_body::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }

    void ver_req_body::__set_time_stamp(const int64_t val) {
        this->time_stamp = val;
    }

    void ver_req_body::__set_addr_me(const network_address& val) {
        this->addr_me = val;
    }

    void ver_req_body::__set_addr_you(const network_address& val) {
        this->addr_you = val;
    }

    void ver_req_body::__set_start_height(const int64_t val) {
        this->start_height = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;
        bool isset_time_stamp = false;
        bool isset_addr_me = false;
        bool isset_addr_you = false;
        bool isset_start_height = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->node_id);
                        isset_node_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->core_version);
                        isset_core_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->protocol_version);
                        isset_protocol_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_I64) {
                        xfer += iprot->readI64(this->time_stamp);
                        isset_time_stamp = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->addr_me.read(iprot);
                        isset_addr_me = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->addr_you.read(iprot);
                        isset_addr_you = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_I64) {
                        xfer += iprot->readI64(this->start_height);
                        isset_start_height = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_time_stamp)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr_me)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr_you)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_start_height)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t ver_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_req_body");

        xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 4);
        xfer += oprot->writeI64(this->time_stamp);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr_me", ::apache::thrift::protocol::T_STRUCT, 5);
        xfer += this->addr_me.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr_you", ::apache::thrift::protocol::T_STRUCT, 6);
        xfer += this->addr_you.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("start_height", ::apache::thrift::protocol::T_I64, 7);
        xfer += oprot->writeI64(this->start_height);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_req_body &a, ver_req_body &b) {
        using ::std::swap;
        swap(a.node_id, b.node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
        swap(a.time_stamp, b.time_stamp);
        swap(a.addr_me, b.addr_me);
        swap(a.addr_you, b.addr_you);
        swap(a.start_height, b.start_height);
    }

    ver_req_body::ver_req_body(const ver_req_body& other418) {
        node_id = other418.node_id;
        core_version = other418.core_version;
        protocol_version = other418.protocol_version;
        time_stamp = other418.time_stamp;
        addr_me = other418.addr_me;
        addr_you = other418.addr_you;
        start_height = other418.start_height;
    }
    ver_req_body& ver_req_body::operator=(const ver_req_body& other419) {
        node_id = other419.node_id;
        core_version = other419.core_version;
        protocol_version = other419.protocol_version;
        time_stamp = other419.time_stamp;
        addr_me = other419.addr_me;
        addr_you = other419.addr_you;
        start_height = other419.start_height;
        return *this;
    }
    void ver_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_req_body(";
        out << "node_id=" << to_string(node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ", " << "time_stamp=" << to_string(time_stamp);
        out << ", " << "addr_me=" << to_string(addr_me);
        out << ", " << "addr_you=" << to_string(addr_you);
        out << ", " << "start_height=" << to_string(start_height);
        out << ")";
    }


    ver_req::~ver_req() throw() {
    }


    void ver_req::__set_body(const ver_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t ver_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_req &a, ver_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    ver_req::ver_req(const ver_req& other420) {
        body = other420.body;
        __isset = other420.__isset;
    }
    ver_req& ver_req::operator=(const ver_req& other421) {
        body = other421.body;
        __isset = other421.__isset;
        return *this;
    }
    void ver_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    ver_resp_body::~ver_resp_body() throw() {
    }


    void ver_resp_body::__set_node_id(const std::string& val) {
        this->node_id = val;
    }

    void ver_resp_body::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void ver_resp_body::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_resp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->node_id);
                        isset_node_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->core_version);
                        isset_core_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->protocol_version);
                        isset_protocol_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t ver_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_resp_body");

        xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_resp_body &a, ver_resp_body &b) {
        using ::std::swap;
        swap(a.node_id, b.node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
    }

    ver_resp_body::ver_resp_body(const ver_resp_body& other422) {
        node_id = other422.node_id;
        core_version = other422.core_version;
        protocol_version = other422.protocol_version;
    }
    ver_resp_body& ver_resp_body::operator=(const ver_resp_body& other423) {
        node_id = other423.node_id;
        core_version = other423.core_version;
        protocol_version = other423.protocol_version;
        return *this;
    }
    void ver_resp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_resp_body(";
        out << "node_id=" << to_string(node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ")";
    }


    ver_resp::~ver_resp() throw() {
    }


    void ver_resp::__set_body(const ver_resp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t ver_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_resp &a, ver_resp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    ver_resp::ver_resp(const ver_resp& other424) {
        body = other424.body;
        __isset = other424.__isset;
    }
    ver_resp& ver_resp::operator=(const ver_resp& other425) {
        body = other425.body;
        __isset = other425.__isset;
        return *this;
    }
    void ver_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    peer_node_info::~peer_node_info() throw() {
    }


    void peer_node_info::__set_peer_node_id(const std::string& val) {
        this->peer_node_id = val;
    }

    void peer_node_info::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void peer_node_info::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }

    void peer_node_info::__set_live_time_stamp(const int32_t val) {
        this->live_time_stamp = val;
    }

    void peer_node_info::__set_addr(const network_address& val) {
        this->addr = val;
    }

    void peer_node_info::__set_service_list(const std::vector<std::string> & val) {
        this->service_list = val;
        __isset.service_list = true;
    }
    std::ostream& operator<<(std::ostream& out, const peer_node_info& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;
        bool isset_live_time_stamp = false;
        bool isset_addr = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->peer_node_id);
                        isset_peer_node_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->core_version);
                        isset_core_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->protocol_version);
                        isset_protocol_version = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->live_time_stamp);
                        isset_live_time_stamp = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->addr.read(iprot);
                        isset_addr = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->service_list.clear();
                            uint32_t _size426;
                            ::apache::thrift::protocol::TType _etype429;
                            xfer += iprot->readListBegin(_etype429, _size426);
                            this->service_list.resize(_size426);
                            uint32_t _i430;
                            for (_i430 = 0; _i430 < _size426; ++_i430)
                            {
                                xfer += iprot->readString(this->service_list[_i430]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        this->__isset.service_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_live_time_stamp)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t peer_node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_node_info");

        xfer += oprot->writeFieldBegin("peer_node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->peer_node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("live_time_stamp", ::apache::thrift::protocol::T_I32, 4);
        xfer += oprot->writeI32(this->live_time_stamp);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRUCT, 5);
        xfer += this->addr.write(oprot);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.service_list) {
            xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 6);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
                std::vector<std::string> ::const_iterator _iter431;
                for (_iter431 = this->service_list.begin(); _iter431 != this->service_list.end(); ++_iter431)
                {
                    xfer += oprot->writeString((*_iter431));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_node_info &a, peer_node_info &b) {
        using ::std::swap;
        swap(a.peer_node_id, b.peer_node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
        swap(a.live_time_stamp, b.live_time_stamp);
        swap(a.addr, b.addr);
        swap(a.service_list, b.service_list);
        swap(a.__isset, b.__isset);
    }

    peer_node_info::peer_node_info(const peer_node_info& other432) {
        peer_node_id = other432.peer_node_id;
        core_version = other432.core_version;
        protocol_version = other432.protocol_version;
        live_time_stamp = other432.live_time_stamp;
        addr = other432.addr;
        service_list = other432.service_list;
        __isset = other432.__isset;
    }
    peer_node_info& peer_node_info::operator=(const peer_node_info& other433) {
        peer_node_id = other433.peer_node_id;
        core_version = other433.core_version;
        protocol_version = other433.protocol_version;
        live_time_stamp = other433.live_time_stamp;
        addr = other433.addr;
        service_list = other433.service_list;
        __isset = other433.__isset;
        return *this;
    }
    void peer_node_info::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_node_info(";
        out << "peer_node_id=" << to_string(peer_node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ", " << "live_time_stamp=" << to_string(live_time_stamp);
        out << ", " << "addr=" << to_string(addr);
        out << ", " << "service_list="; (__isset.service_list ? (out << to_string(service_list)) : (out << "<null>"));
        out << ")";
    }


    get_peer_nodes_req::~get_peer_nodes_req() throw() {
    }


    void get_peer_nodes_req::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t get_peer_nodes_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_req &a, get_peer_nodes_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    get_peer_nodes_req::get_peer_nodes_req(const get_peer_nodes_req& other434) {
        body = other434.body;
        __isset = other434.__isset;
    }
    get_peer_nodes_req& get_peer_nodes_req::operator=(const get_peer_nodes_req& other435) {
        body = other435.body;
        __isset = other435.__isset;
        return *this;
    }
    void get_peer_nodes_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    get_peer_nodes_resp_body::~get_peer_nodes_resp_body() throw() {
    }


    void get_peer_nodes_resp_body::__set_peer_nodes_list(const std::vector<peer_node_info> & val) {
        this->peer_nodes_list = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size436;
                            ::apache::thrift::protocol::TType _etype439;
                            xfer += iprot->readListBegin(_etype439, _size436);
                            this->peer_nodes_list.resize(_size436);
                            uint32_t _i440;
                            for (_i440 = 0; _i440 < _size436; ++_i440)
                            {
                                xfer += this->peer_nodes_list[_i440].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t get_peer_nodes_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_resp_body");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<peer_node_info> ::const_iterator _iter441;
            for (_iter441 = this->peer_nodes_list.begin(); _iter441 != this->peer_nodes_list.end(); ++_iter441)
            {
                xfer += (*_iter441).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_resp_body &a, get_peer_nodes_resp_body &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
    }

    get_peer_nodes_resp_body::get_peer_nodes_resp_body(const get_peer_nodes_resp_body& other442) {
        peer_nodes_list = other442.peer_nodes_list;
    }
    get_peer_nodes_resp_body& get_peer_nodes_resp_body::operator=(const get_peer_nodes_resp_body& other443) {
        peer_nodes_list = other443.peer_nodes_list;
        return *this;
    }
    void get_peer_nodes_resp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_resp_body(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ")";
    }


    get_peer_nodes_resp::~get_peer_nodes_resp() throw() {
    }


    void get_peer_nodes_resp::__set_body(const get_peer_nodes_resp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t get_peer_nodes_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_resp &a, get_peer_nodes_resp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    get_peer_nodes_resp::get_peer_nodes_resp(const get_peer_nodes_resp& other444) {
        body = other444.body;
        __isset = other444.__isset;
    }
    get_peer_nodes_resp& get_peer_nodes_resp::operator=(const get_peer_nodes_resp& other445) {
        body = other445.body;
        __isset = other445.__isset;
        return *this;
    }
    void get_peer_nodes_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    peer_nodes_broadcast_req_body::~peer_nodes_broadcast_req_body() throw() {
    }


    void peer_nodes_broadcast_req_body::__set_peer_nodes_list(const std::vector<peer_node_info> & val) {
        this->peer_nodes_list = val;
    }
    std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_nodes_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size446;
                            ::apache::thrift::protocol::TType _etype449;
                            xfer += iprot->readListBegin(_etype449, _size446);
                            this->peer_nodes_list.resize(_size446);
                            uint32_t _i450;
                            for (_i450 = 0; _i450 < _size446; ++_i450)
                            {
                                xfer += this->peer_nodes_list[_i450].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t peer_nodes_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_nodes_broadcast_req_body");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<peer_node_info> ::const_iterator _iter451;
            for (_iter451 = this->peer_nodes_list.begin(); _iter451 != this->peer_nodes_list.end(); ++_iter451)
            {
                xfer += (*_iter451).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_nodes_broadcast_req_body &a, peer_nodes_broadcast_req_body &b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
    }

    peer_nodes_broadcast_req_body::peer_nodes_broadcast_req_body(const peer_nodes_broadcast_req_body& other452) {
        peer_nodes_list = other452.peer_nodes_list;
    }
    peer_nodes_broadcast_req_body& peer_nodes_broadcast_req_body::operator=(const peer_nodes_broadcast_req_body& other453) {
        peer_nodes_list = other453.peer_nodes_list;
        return *this;
    }
    void peer_nodes_broadcast_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_nodes_broadcast_req_body(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ")";
    }


    peer_nodes_broadcast_req::~peer_nodes_broadcast_req() throw() {
    }


    void peer_nodes_broadcast_req::__set_body(const peer_nodes_broadcast_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_nodes_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t peer_nodes_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_nodes_broadcast_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_nodes_broadcast_req &a, peer_nodes_broadcast_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    peer_nodes_broadcast_req::peer_nodes_broadcast_req(const peer_nodes_broadcast_req& other454) {
        body = other454.body;
        __isset = other454.__isset;
    }
    peer_nodes_broadcast_req& peer_nodes_broadcast_req::operator=(const peer_nodes_broadcast_req& other455) {
        body = other455.body;
        __isset = other455.__isset;
        return *this;
    }
    void peer_nodes_broadcast_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_nodes_broadcast_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_snapshot_req_data::~node_list_snapshot_req_data() throw() {
    }


    void node_list_snapshot_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_list_snapshot_req_data::__set_snapshot_name(const std::string& val) {
        this->snapshot_name = val;
    }

    void node_list_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_list_snapshot_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_list_snapshot_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_list_snapshot_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_list_snapshot_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_list_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_list_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_list_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_list_snapshot_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_list_snapshot_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_snapshot_name = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->snapshot_name);
                        isset_snapshot_name = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size456;
                            ::apache::thrift::protocol::TType _etype459;
                            xfer += iprot->readListBegin(_etype459, _size456);
                            this->peer_nodes_list.resize(_size456);
                            uint32_t _i460;
                            for (_i460 = 0; _i460 < _size456; ++_i460)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i460]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size461;
                            ::apache::thrift::protocol::TType _etype464;
                            xfer += iprot->readListBegin(_etype464, _size461);
                            this->multisig_wallets.resize(_size461);
                            uint32_t _i465;
                            for (_i465 = 0; _i465 < _size461; ++_i465)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i465]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size466;
                            ::apache::thrift::protocol::TType _etype469;
                            xfer += iprot->readListBegin(_etype469, _size466);
                            this->multisig_signs.resize(_size466);
                            uint32_t _i470;
                            for (_i470 = 0; _i470 < _size466; ++_i470)
                            {
                                xfer += this->multisig_signs[_i470].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_snapshot_name)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->snapshot_name);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 3);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter471;
            for (_iter471 = this->peer_nodes_list.begin(); _iter471 != this->peer_nodes_list.end(); ++_iter471)
            {
                xfer += oprot->writeString((*_iter471));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter472;
            for (_iter472 = this->multisig_wallets.begin(); _iter472 != this->multisig_wallets.end(); ++_iter472)
            {
                xfer += oprot->writeString((*_iter472));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 9);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 10);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter473;
            for (_iter473 = this->multisig_signs.begin(); _iter473 != this->multisig_signs.end(); ++_iter473)
            {
                xfer += (*_iter473).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 12);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_req_data &a, node_list_snapshot_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.snapshot_name, b.snapshot_name);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_list_snapshot_req_data::node_list_snapshot_req_data(const node_list_snapshot_req_data& other474) {
        task_id = other474.task_id;
        snapshot_name = other474.snapshot_name;
        peer_nodes_list = other474.peer_nodes_list;
        additional = other474.additional;
        wallet = other474.wallet;
        nonce = other474.nonce;
        sign = other474.sign;
        multisig_wallets = other474.multisig_wallets;
        multisig_threshold = other474.multisig_threshold;
        multisig_signs = other474.multisig_signs;
        session_id = other474.session_id;
        session_id_sign = other474.session_id_sign;
    }
    node_list_snapshot_req_data& node_list_snapshot_req_data::operator=(const node_list_snapshot_req_data& other475) {
        task_id = other475.task_id;
        snapshot_name = other475.snapshot_name;
        peer_nodes_list = other475.peer_nodes_list;
        additional = other475.additional;
        wallet = other475.wallet;
        nonce = other475.nonce;
        sign = other475.sign;
        multisig_wallets = other475.multisig_wallets;
        multisig_threshold = other475.multisig_threshold;
        multisig_signs = other475.multisig_signs;
        session_id = other475.session_id;
        session_id_sign = other475.session_id_sign;
        return *this;
    }
    void node_list_snapshot_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "snapshot_name=" << to_string(snapshot_name);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_list_snapshot_req_body::~node_list_snapshot_req_body() throw() {
    }


    void node_list_snapshot_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_req_body &a, node_list_snapshot_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_snapshot_req_body::node_list_snapshot_req_body(const node_list_snapshot_req_body& other476) {
        data = other476.data;
    }
    node_list_snapshot_req_body& node_list_snapshot_req_body::operator=(const node_list_snapshot_req_body& other477) {
        data = other477.data;
        return *this;
    }
    void node_list_snapshot_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_snapshot_req::~node_list_snapshot_req() throw() {
    }


    void node_list_snapshot_req::__set_body(const node_list_snapshot_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_req &a, node_list_snapshot_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_snapshot_req::node_list_snapshot_req(const node_list_snapshot_req& other478) {
        body = other478.body;
        __isset = other478.__isset;
    }
    node_list_snapshot_req& node_list_snapshot_req::operator=(const node_list_snapshot_req& other479) {
        body = other479.body;
        __isset = other479.__isset;
        return *this;
    }
    void node_list_snapshot_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_snapshot_rsp_body::~node_list_snapshot_rsp_body() throw() {
    }


    void node_list_snapshot_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_rsp_body &a, node_list_snapshot_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_snapshot_rsp_body::node_list_snapshot_rsp_body(const node_list_snapshot_rsp_body& other480) {
        data = other480.data;
    }
    node_list_snapshot_rsp_body& node_list_snapshot_rsp_body::operator=(const node_list_snapshot_rsp_body& other481) {
        data = other481.data;
        return *this;
    }
    void node_list_snapshot_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_snapshot_rsp::~node_list_snapshot_rsp() throw() {
    }


    void node_list_snapshot_rsp::__set_body(const node_list_snapshot_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_rsp &a, node_list_snapshot_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_snapshot_rsp::node_list_snapshot_rsp(const node_list_snapshot_rsp& other482) {
        body = other482.body;
        __isset = other482.__isset;
    }
    node_list_snapshot_rsp& node_list_snapshot_rsp::operator=(const node_list_snapshot_rsp& other483) {
        body = other483.body;
        __isset = other483.__isset;
        return *this;
    }
    void node_list_snapshot_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_snapshot_req_data::~node_create_snapshot_req_data() throw() {
    }


    void node_create_snapshot_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_create_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_create_snapshot_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_create_snapshot_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_create_snapshot_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_create_snapshot_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_create_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_create_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_create_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_create_snapshot_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_create_snapshot_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size484;
                            ::apache::thrift::protocol::TType _etype487;
                            xfer += iprot->readListBegin(_etype487, _size484);
                            this->peer_nodes_list.resize(_size484);
                            uint32_t _i488;
                            for (_i488 = 0; _i488 < _size484; ++_i488)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i488]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size489;
                            ::apache::thrift::protocol::TType _etype492;
                            xfer += iprot->readListBegin(_etype492, _size489);
                            this->multisig_wallets.resize(_size489);
                            uint32_t _i493;
                            for (_i493 = 0; _i493 < _size489; ++_i493)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i493]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size494;
                            ::apache::thrift::protocol::TType _etype497;
                            xfer += iprot->readListBegin(_etype497, _size494);
                            this->multisig_signs.resize(_size494);
                            uint32_t _i498;
                            for (_i498 = 0; _i498 < _size494; ++_i498)
                            {
                                xfer += this->multisig_signs[_i498].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter499;
            for (_iter499 = this->peer_nodes_list.begin(); _iter499 != this->peer_nodes_list.end(); ++_iter499)
            {
                xfer += oprot->writeString((*_iter499));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter500;
            for (_iter500 = this->multisig_wallets.begin(); _iter500 != this->multisig_wallets.end(); ++_iter500)
            {
                xfer += oprot->writeString((*_iter500));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter501;
            for (_iter501 = this->multisig_signs.begin(); _iter501 != this->multisig_signs.end(); ++_iter501)
            {
                xfer += (*_iter501).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_req_data &a, node_create_snapshot_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_create_snapshot_req_data::node_create_snapshot_req_data(const node_create_snapshot_req_data& other502) {
        task_id = other502.task_id;
        peer_nodes_list = other502.peer_nodes_list;
        additional = other502.additional;
        wallet = other502.wallet;
        nonce = other502.nonce;
        sign = other502.sign;
        multisig_wallets = other502.multisig_wallets;
        multisig_threshold = other502.multisig_threshold;
        multisig_signs = other502.multisig_signs;
        session_id = other502.session_id;
        session_id_sign = other502.session_id_sign;
    }
    node_create_snapshot_req_data& node_create_snapshot_req_data::operator=(const node_create_snapshot_req_data& other503) {
        task_id = other503.task_id;
        peer_nodes_list = other503.peer_nodes_list;
        additional = other503.additional;
        wallet = other503.wallet;
        nonce = other503.nonce;
        sign = other503.sign;
        multisig_wallets = other503.multisig_wallets;
        multisig_threshold = other503.multisig_threshold;
        multisig_signs = other503.multisig_signs;
        session_id = other503.session_id;
        session_id_sign = other503.session_id_sign;
        return *this;
    }
    void node_create_snapshot_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_create_snapshot_req_body::~node_create_snapshot_req_body() throw() {
    }


    void node_create_snapshot_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_req_body &a, node_create_snapshot_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_snapshot_req_body::node_create_snapshot_req_body(const node_create_snapshot_req_body& other504) {
        data = other504.data;
    }
    node_create_snapshot_req_body& node_create_snapshot_req_body::operator=(const node_create_snapshot_req_body& other505) {
        data = other505.data;
        return *this;
    }
    void node_create_snapshot_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_snapshot_req::~node_create_snapshot_req() throw() {
    }


    void node_create_snapshot_req::__set_body(const node_create_snapshot_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_req &a, node_create_snapshot_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_snapshot_req::node_create_snapshot_req(const node_create_snapshot_req& other506) {
        body = other506.body;
        __isset = other506.__isset;
    }
    node_create_snapshot_req& node_create_snapshot_req::operator=(const node_create_snapshot_req& other507) {
        body = other507.body;
        __isset = other507.__isset;
        return *this;
    }
    void node_create_snapshot_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_snapshot_rsp_body::~node_create_snapshot_rsp_body() throw() {
    }


    void node_create_snapshot_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_rsp_body &a, node_create_snapshot_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_snapshot_rsp_body::node_create_snapshot_rsp_body(const node_create_snapshot_rsp_body& other508) {
        data = other508.data;
    }
    node_create_snapshot_rsp_body& node_create_snapshot_rsp_body::operator=(const node_create_snapshot_rsp_body& other509) {
        data = other509.data;
        return *this;
    }
    void node_create_snapshot_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_snapshot_rsp::~node_create_snapshot_rsp() throw() {
    }


    void node_create_snapshot_rsp::__set_body(const node_create_snapshot_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_rsp &a, node_create_snapshot_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_snapshot_rsp::node_create_snapshot_rsp(const node_create_snapshot_rsp& other510) {
        body = other510.body;
        __isset = other510.__isset;
    }
    node_create_snapshot_rsp& node_create_snapshot_rsp::operator=(const node_create_snapshot_rsp& other511) {
        body = other511.body;
        __isset = other511.__isset;
        return *this;
    }
    void node_create_snapshot_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_snapshot_req_data::~node_delete_snapshot_req_data() throw() {
    }


    void node_delete_snapshot_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_delete_snapshot_req_data::__set_snapshot_name(const std::string& val) {
        this->snapshot_name = val;
    }

    void node_delete_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
        this->peer_nodes_list = val;
    }

    void node_delete_snapshot_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_delete_snapshot_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_delete_snapshot_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_delete_snapshot_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_delete_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
        this->multisig_wallets = val;
    }

    void node_delete_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_delete_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
        this->multisig_signs = val;
    }

    void node_delete_snapshot_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_delete_snapshot_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_snapshot_name = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->task_id);
                        isset_task_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 2:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->snapshot_name);
                        isset_snapshot_name = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 3:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->peer_nodes_list.clear();
                            uint32_t _size512;
                            ::apache::thrift::protocol::TType _etype515;
                            xfer += iprot->readListBegin(_etype515, _size512);
                            this->peer_nodes_list.resize(_size512);
                            uint32_t _i516;
                            for (_i516 = 0; _i516 < _size512; ++_i516)
                            {
                                xfer += iprot->readString(this->peer_nodes_list[_i516]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_peer_nodes_list = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 4:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->additional);
                        isset_additional = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 5:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->wallet);
                        isset_wallet = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 6:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->nonce);
                        isset_nonce = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 7:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->sign);
                        isset_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 8:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_wallets.clear();
                            uint32_t _size517;
                            ::apache::thrift::protocol::TType _etype520;
                            xfer += iprot->readListBegin(_etype520, _size517);
                            this->multisig_wallets.resize(_size517);
                            uint32_t _i521;
                            for (_i521 = 0; _i521 < _size517; ++_i521)
                            {
                                xfer += iprot->readString(this->multisig_wallets[_i521]);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_wallets = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 9:
                    if (ftype == ::apache::thrift::protocol::T_I32) {
                        xfer += iprot->readI32(this->multisig_threshold);
                        isset_multisig_threshold = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 10:
                    if (ftype == ::apache::thrift::protocol::T_LIST) {
                        {
                            this->multisig_signs.clear();
                            uint32_t _size522;
                            ::apache::thrift::protocol::TType _etype525;
                            xfer += iprot->readListBegin(_etype525, _size522);
                            this->multisig_signs.resize(_size522);
                            uint32_t _i526;
                            for (_i526 = 0; _i526 < _size522; ++_i526)
                            {
                                xfer += this->multisig_signs[_i526].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                        }
                        isset_multisig_signs = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 11:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id);
                        isset_session_id = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                case 12:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->session_id_sign);
                        isset_session_id_sign = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_snapshot_name)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->snapshot_name);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 3);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter527;
            for (_iter527 = this->peer_nodes_list.begin(); _iter527 != this->peer_nodes_list.end(); ++_iter527)
            {
                xfer += oprot->writeString((*_iter527));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter528;
            for (_iter528 = this->multisig_wallets.begin(); _iter528 != this->multisig_wallets.end(); ++_iter528)
            {
                xfer += oprot->writeString((*_iter528));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 9);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 10);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter529;
            for (_iter529 = this->multisig_signs.begin(); _iter529 != this->multisig_signs.end(); ++_iter529)
            {
                xfer += (*_iter529).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 12);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_req_data &a, node_delete_snapshot_req_data &b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.snapshot_name, b.snapshot_name);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_delete_snapshot_req_data::node_delete_snapshot_req_data(const node_delete_snapshot_req_data& other530) {
        task_id = other530.task_id;
        snapshot_name = other530.snapshot_name;
        peer_nodes_list = other530.peer_nodes_list;
        additional = other530.additional;
        wallet = other530.wallet;
        nonce = other530.nonce;
        sign = other530.sign;
        multisig_wallets = other530.multisig_wallets;
        multisig_threshold = other530.multisig_threshold;
        multisig_signs = other530.multisig_signs;
        session_id = other530.session_id;
        session_id_sign = other530.session_id_sign;
    }
    node_delete_snapshot_req_data& node_delete_snapshot_req_data::operator=(const node_delete_snapshot_req_data& other531) {
        task_id = other531.task_id;
        snapshot_name = other531.snapshot_name;
        peer_nodes_list = other531.peer_nodes_list;
        additional = other531.additional;
        wallet = other531.wallet;
        nonce = other531.nonce;
        sign = other531.sign;
        multisig_wallets = other531.multisig_wallets;
        multisig_threshold = other531.multisig_threshold;
        multisig_signs = other531.multisig_signs;
        session_id = other531.session_id;
        session_id_sign = other531.session_id_sign;
        return *this;
    }
    void node_delete_snapshot_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "snapshot_name=" << to_string(snapshot_name);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_delete_snapshot_req_body::~node_delete_snapshot_req_body() throw() {
    }


    void node_delete_snapshot_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_req_body &a, node_delete_snapshot_req_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_snapshot_req_body::node_delete_snapshot_req_body(const node_delete_snapshot_req_body& other532) {
        data = other532.data;
    }
    node_delete_snapshot_req_body& node_delete_snapshot_req_body::operator=(const node_delete_snapshot_req_body& other533) {
        data = other533.data;
        return *this;
    }
    void node_delete_snapshot_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_snapshot_req::~node_delete_snapshot_req() throw() {
    }


    void node_delete_snapshot_req::__set_body(const node_delete_snapshot_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_req &a, node_delete_snapshot_req &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_snapshot_req::node_delete_snapshot_req(const node_delete_snapshot_req& other534) {
        body = other534.body;
        __isset = other534.__isset;
    }
    node_delete_snapshot_req& node_delete_snapshot_req::operator=(const node_delete_snapshot_req& other535) {
        body = other535.body;
        __isset = other535.__isset;
        return *this;
    }
    void node_delete_snapshot_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_snapshot_rsp_body::~node_delete_snapshot_rsp_body() throw() {
    }


    void node_delete_snapshot_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRING) {
                        xfer += iprot->readString(this->data);
                        isset_data = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_rsp_body &a, node_delete_snapshot_rsp_body &b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_snapshot_rsp_body::node_delete_snapshot_rsp_body(const node_delete_snapshot_rsp_body& other536) {
        data = other536.data;
    }
    node_delete_snapshot_rsp_body& node_delete_snapshot_rsp_body::operator=(const node_delete_snapshot_rsp_body& other537) {
        data = other537.data;
        return *this;
    }
    void node_delete_snapshot_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_snapshot_rsp::~node_delete_snapshot_rsp() throw() {
    }


    void node_delete_snapshot_rsp::__set_body(const node_delete_snapshot_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
                case 1:
                    if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                        xfer += this->body.read(iprot);
                        this->__isset.body = true;
                    } else {
                        xfer += iprot->skip(ftype);
                    }
                    break;
                default:
                    xfer += iprot->skip(ftype);
                    break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_rsp &a, node_delete_snapshot_rsp &b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_snapshot_rsp::node_delete_snapshot_rsp(const node_delete_snapshot_rsp& other538) {
        body = other538.body;
        __isset = other538.__isset;
    }
    node_delete_snapshot_rsp& node_delete_snapshot_rsp::operator=(const node_delete_snapshot_rsp& other539) {
        body = other539.body;
        __isset = other539.__isset;
        return *this;
    }
    void node_delete_snapshot_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }

} // namespace
