/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "matrix_types.h"

#include <algorithm>
#include <ostream>

// #include <thrift/TToString.h>

namespace dbc {


empty::~empty() noexcept {
}

std::ostream& operator<<(std::ostream& out, const empty& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t empty::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t empty::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("empty");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(empty &a, empty &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

empty::empty(const empty& other0) {
  (void) other0;
}
empty& empty::operator=(const empty& other1) {
  (void) other1;
  return *this;
}
void empty::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "empty(";
  out << ")";
}


network_address::~network_address() noexcept {
}


void network_address::__set_ip(const std::string& val) {
  this->ip = val;
}

void network_address::__set_port(const int16_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const network_address& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t network_address::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ip = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          isset_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ip)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t network_address::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("network_address");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(network_address &a, network_address &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.port, b.port);
}

network_address::network_address(const network_address& other2) {
  ip = other2.ip;
  port = other2.port;
}
network_address& network_address::operator=(const network_address& other3) {
  ip = other3.ip;
  port = other3.port;
  return *this;
}
void network_address::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "network_address(";
  out << "ip=" << to_string(ip);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


shake_hand_req::~shake_hand_req() noexcept {
}


void shake_hand_req::__set_body(const empty& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const shake_hand_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t shake_hand_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t shake_hand_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("shake_hand_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(shake_hand_req &a, shake_hand_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

shake_hand_req::shake_hand_req(const shake_hand_req& other4) {
  body = other4.body;
  __isset = other4.__isset;
}
shake_hand_req& shake_hand_req::operator=(const shake_hand_req& other5) {
  body = other5.body;
  __isset = other5.__isset;
  return *this;
}
void shake_hand_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "shake_hand_req(";
  out << "body=" << to_string(body);
  out << ")";
}


shake_hand_resp::~shake_hand_resp() noexcept {
}


void shake_hand_resp::__set_body(const empty& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const shake_hand_resp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t shake_hand_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t shake_hand_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("shake_hand_resp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(shake_hand_resp &a, shake_hand_resp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

shake_hand_resp::shake_hand_resp(const shake_hand_resp& other6) {
  body = other6.body;
  __isset = other6.__isset;
}
shake_hand_resp& shake_hand_resp::operator=(const shake_hand_resp& other7) {
  body = other7.body;
  __isset = other7.__isset;
  return *this;
}
void shake_hand_resp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "shake_hand_resp(";
  out << "body=" << to_string(body);
  out << ")";
}


multisig_sign_item::~multisig_sign_item() noexcept {
}


void multisig_sign_item::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void multisig_sign_item::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void multisig_sign_item::__set_sign(const std::string& val) {
  this->sign = val;
}
std::ostream& operator<<(std::ostream& out, const multisig_sign_item& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t multisig_sign_item::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t multisig_sign_item::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("multisig_sign_item");

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(multisig_sign_item &a, multisig_sign_item &b) {
  using ::std::swap;
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
}

multisig_sign_item::multisig_sign_item(const multisig_sign_item& other8) {
  wallet = other8.wallet;
  nonce = other8.nonce;
  sign = other8.sign;
}
multisig_sign_item& multisig_sign_item::operator=(const multisig_sign_item& other9) {
  wallet = other9.wallet;
  nonce = other9.nonce;
  sign = other9.sign;
  return *this;
}
void multisig_sign_item::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "multisig_sign_item(";
  out << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ")";
}


node_list_task_req_data::~node_list_task_req_data() noexcept {
}


void node_list_task_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_list_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_list_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_list_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_list_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_list_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_list_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_list_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_list_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_list_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_list_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_list_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_list_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->peer_nodes_list.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->multisig_wallets.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += iprot->readString(this->multisig_wallets[_i19]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->multisig_signs.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->multisig_signs[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_task_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter25;
    for (_iter25 = this->peer_nodes_list.begin(); _iter25 != this->peer_nodes_list.end(); ++_iter25)
    {
      xfer += oprot->writeString((*_iter25));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter26;
    for (_iter26 = this->multisig_wallets.begin(); _iter26 != this->multisig_wallets.end(); ++_iter26)
    {
      xfer += oprot->writeString((*_iter26));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter27;
    for (_iter27 = this->multisig_signs.begin(); _iter27 != this->multisig_signs.end(); ++_iter27)
    {
      xfer += (*_iter27).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_task_req_data &a, node_list_task_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_list_task_req_data::node_list_task_req_data(const node_list_task_req_data& other28) {
  task_id = other28.task_id;
  peer_nodes_list = other28.peer_nodes_list;
  additional = other28.additional;
  wallet = other28.wallet;
  nonce = other28.nonce;
  sign = other28.sign;
  multisig_wallets = other28.multisig_wallets;
  multisig_threshold = other28.multisig_threshold;
  multisig_signs = other28.multisig_signs;
  session_id = other28.session_id;
  session_id_sign = other28.session_id_sign;
  rent_order = other28.rent_order;
  __isset = other28.__isset;
}
node_list_task_req_data& node_list_task_req_data::operator=(const node_list_task_req_data& other29) {
  task_id = other29.task_id;
  peer_nodes_list = other29.peer_nodes_list;
  additional = other29.additional;
  wallet = other29.wallet;
  nonce = other29.nonce;
  sign = other29.sign;
  multisig_wallets = other29.multisig_wallets;
  multisig_threshold = other29.multisig_threshold;
  multisig_signs = other29.multisig_signs;
  session_id = other29.session_id;
  session_id_sign = other29.session_id_sign;
  rent_order = other29.rent_order;
  __isset = other29.__isset;
  return *this;
}
void node_list_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_task_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_list_task_req_body::~node_list_task_req_body() noexcept {
}


void node_list_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_task_req_body &a, node_list_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_task_req_body::node_list_task_req_body(const node_list_task_req_body& other30) {
  data = other30.data;
}
node_list_task_req_body& node_list_task_req_body::operator=(const node_list_task_req_body& other31) {
  data = other31.data;
  return *this;
}
void node_list_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_task_req::~node_list_task_req() noexcept {
}


void node_list_task_req::__set_body(const node_list_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_task_req &a, node_list_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_task_req::node_list_task_req(const node_list_task_req& other32) {
  body = other32.body;
  __isset = other32.__isset;
}
node_list_task_req& node_list_task_req::operator=(const node_list_task_req& other33) {
  body = other33.body;
  __isset = other33.__isset;
  return *this;
}
void node_list_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_task_rsp_body::~node_list_task_rsp_body() noexcept {
}


void node_list_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_task_rsp_body &a, node_list_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_task_rsp_body::node_list_task_rsp_body(const node_list_task_rsp_body& other34) {
  data = other34.data;
}
node_list_task_rsp_body& node_list_task_rsp_body::operator=(const node_list_task_rsp_body& other35) {
  data = other35.data;
  return *this;
}
void node_list_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_task_rsp::~node_list_task_rsp() noexcept {
}


void node_list_task_rsp::__set_body(const node_list_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_task_rsp &a, node_list_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_task_rsp::node_list_task_rsp(const node_list_task_rsp& other36) {
  body = other36.body;
  __isset = other36.__isset;
}
node_list_task_rsp& node_list_task_rsp::operator=(const node_list_task_rsp& other37) {
  body = other37.body;
  __isset = other37.__isset;
  return *this;
}
void node_list_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_create_task_req_data::~node_create_task_req_data() noexcept {
}


void node_create_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_create_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_create_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_create_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_create_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_create_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_create_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_create_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_create_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_create_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_create_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_create_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_create_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->peer_nodes_list.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->multisig_wallets.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readString(this->multisig_wallets[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->multisig_signs.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += this->multisig_signs[_i52].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_create_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_create_task_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter53;
    for (_iter53 = this->peer_nodes_list.begin(); _iter53 != this->peer_nodes_list.end(); ++_iter53)
    {
      xfer += oprot->writeString((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter54;
    for (_iter54 = this->multisig_wallets.begin(); _iter54 != this->multisig_wallets.end(); ++_iter54)
    {
      xfer += oprot->writeString((*_iter54));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter55;
    for (_iter55 = this->multisig_signs.begin(); _iter55 != this->multisig_signs.end(); ++_iter55)
    {
      xfer += (*_iter55).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_create_task_req_data &a, node_create_task_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_create_task_req_data::node_create_task_req_data(const node_create_task_req_data& other56) {
  peer_nodes_list = other56.peer_nodes_list;
  additional = other56.additional;
  wallet = other56.wallet;
  nonce = other56.nonce;
  sign = other56.sign;
  multisig_wallets = other56.multisig_wallets;
  multisig_threshold = other56.multisig_threshold;
  multisig_signs = other56.multisig_signs;
  session_id = other56.session_id;
  session_id_sign = other56.session_id_sign;
  rent_order = other56.rent_order;
  __isset = other56.__isset;
}
node_create_task_req_data& node_create_task_req_data::operator=(const node_create_task_req_data& other57) {
  peer_nodes_list = other57.peer_nodes_list;
  additional = other57.additional;
  wallet = other57.wallet;
  nonce = other57.nonce;
  sign = other57.sign;
  multisig_wallets = other57.multisig_wallets;
  multisig_threshold = other57.multisig_threshold;
  multisig_signs = other57.multisig_signs;
  session_id = other57.session_id;
  session_id_sign = other57.session_id_sign;
  rent_order = other57.rent_order;
  __isset = other57.__isset;
  return *this;
}
void node_create_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_create_task_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_create_task_req_body::~node_create_task_req_body() noexcept {
}


void node_create_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_create_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_create_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_create_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_create_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_create_task_req_body &a, node_create_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_create_task_req_body::node_create_task_req_body(const node_create_task_req_body& other58) {
  data = other58.data;
}
node_create_task_req_body& node_create_task_req_body::operator=(const node_create_task_req_body& other59) {
  data = other59.data;
  return *this;
}
void node_create_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_create_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_create_task_req::~node_create_task_req() noexcept {
}


void node_create_task_req::__set_body(const node_create_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_create_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_create_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_create_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_create_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_create_task_req &a, node_create_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_create_task_req::node_create_task_req(const node_create_task_req& other60) {
  body = other60.body;
  __isset = other60.__isset;
}
node_create_task_req& node_create_task_req::operator=(const node_create_task_req& other61) {
  body = other61.body;
  __isset = other61.__isset;
  return *this;
}
void node_create_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_create_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_create_task_rsp_body::~node_create_task_rsp_body() noexcept {
}


void node_create_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_create_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_create_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_create_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_create_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_create_task_rsp_body &a, node_create_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_create_task_rsp_body::node_create_task_rsp_body(const node_create_task_rsp_body& other62) {
  data = other62.data;
}
node_create_task_rsp_body& node_create_task_rsp_body::operator=(const node_create_task_rsp_body& other63) {
  data = other63.data;
  return *this;
}
void node_create_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_create_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_create_task_rsp::~node_create_task_rsp() noexcept {
}


void node_create_task_rsp::__set_body(const node_create_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_create_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_create_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_create_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_create_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_create_task_rsp &a, node_create_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_create_task_rsp::node_create_task_rsp(const node_create_task_rsp& other64) {
  body = other64.body;
  __isset = other64.__isset;
}
node_create_task_rsp& node_create_task_rsp::operator=(const node_create_task_rsp& other65) {
  body = other65.body;
  __isset = other65.__isset;
  return *this;
}
void node_create_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_create_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_start_task_req_data::~node_start_task_req_data() noexcept {
}


void node_start_task_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_start_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_start_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_start_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_start_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_start_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_start_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_start_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_start_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_start_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_start_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_start_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_start_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_start_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            xfer += iprot->readListBegin(_etype69, _size66);
            this->peer_nodes_list.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i70]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->multisig_wallets.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += iprot->readString(this->multisig_wallets[_i75]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size76;
            ::apache::thrift::protocol::TType _etype79;
            xfer += iprot->readListBegin(_etype79, _size76);
            this->multisig_signs.resize(_size76);
            uint32_t _i80;
            for (_i80 = 0; _i80 < _size76; ++_i80)
            {
              xfer += this->multisig_signs[_i80].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_start_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_start_task_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter81;
    for (_iter81 = this->peer_nodes_list.begin(); _iter81 != this->peer_nodes_list.end(); ++_iter81)
    {
      xfer += oprot->writeString((*_iter81));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter82;
    for (_iter82 = this->multisig_wallets.begin(); _iter82 != this->multisig_wallets.end(); ++_iter82)
    {
      xfer += oprot->writeString((*_iter82));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter83;
    for (_iter83 = this->multisig_signs.begin(); _iter83 != this->multisig_signs.end(); ++_iter83)
    {
      xfer += (*_iter83).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_start_task_req_data &a, node_start_task_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_start_task_req_data::node_start_task_req_data(const node_start_task_req_data& other84) {
  task_id = other84.task_id;
  peer_nodes_list = other84.peer_nodes_list;
  additional = other84.additional;
  wallet = other84.wallet;
  nonce = other84.nonce;
  sign = other84.sign;
  multisig_wallets = other84.multisig_wallets;
  multisig_threshold = other84.multisig_threshold;
  multisig_signs = other84.multisig_signs;
  session_id = other84.session_id;
  session_id_sign = other84.session_id_sign;
  rent_order = other84.rent_order;
  __isset = other84.__isset;
}
node_start_task_req_data& node_start_task_req_data::operator=(const node_start_task_req_data& other85) {
  task_id = other85.task_id;
  peer_nodes_list = other85.peer_nodes_list;
  additional = other85.additional;
  wallet = other85.wallet;
  nonce = other85.nonce;
  sign = other85.sign;
  multisig_wallets = other85.multisig_wallets;
  multisig_threshold = other85.multisig_threshold;
  multisig_signs = other85.multisig_signs;
  session_id = other85.session_id;
  session_id_sign = other85.session_id_sign;
  rent_order = other85.rent_order;
  __isset = other85.__isset;
  return *this;
}
void node_start_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_start_task_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_start_task_req_body::~node_start_task_req_body() noexcept {
}


void node_start_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_start_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_start_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_start_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_start_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_start_task_req_body &a, node_start_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_start_task_req_body::node_start_task_req_body(const node_start_task_req_body& other86) {
  data = other86.data;
}
node_start_task_req_body& node_start_task_req_body::operator=(const node_start_task_req_body& other87) {
  data = other87.data;
  return *this;
}
void node_start_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_start_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_start_task_req::~node_start_task_req() noexcept {
}


void node_start_task_req::__set_body(const node_start_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_start_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_start_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_start_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_start_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_start_task_req &a, node_start_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_start_task_req::node_start_task_req(const node_start_task_req& other88) {
  body = other88.body;
  __isset = other88.__isset;
}
node_start_task_req& node_start_task_req::operator=(const node_start_task_req& other89) {
  body = other89.body;
  __isset = other89.__isset;
  return *this;
}
void node_start_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_start_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_start_task_rsp_body::~node_start_task_rsp_body() noexcept {
}


void node_start_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_start_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_start_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_start_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_start_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_start_task_rsp_body &a, node_start_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_start_task_rsp_body::node_start_task_rsp_body(const node_start_task_rsp_body& other90) {
  data = other90.data;
}
node_start_task_rsp_body& node_start_task_rsp_body::operator=(const node_start_task_rsp_body& other91) {
  data = other91.data;
  return *this;
}
void node_start_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_start_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_start_task_rsp::~node_start_task_rsp() noexcept {
}


void node_start_task_rsp::__set_body(const node_start_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_start_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_start_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_start_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_start_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_start_task_rsp &a, node_start_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_start_task_rsp::node_start_task_rsp(const node_start_task_rsp& other92) {
  body = other92.body;
  __isset = other92.__isset;
}
node_start_task_rsp& node_start_task_rsp::operator=(const node_start_task_rsp& other93) {
  body = other93.body;
  __isset = other93.__isset;
  return *this;
}
void node_start_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_start_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_shutdown_task_req_data::~node_shutdown_task_req_data() noexcept {
}


void node_shutdown_task_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_shutdown_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_shutdown_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_shutdown_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_shutdown_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_shutdown_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_shutdown_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_shutdown_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_shutdown_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_shutdown_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_shutdown_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_shutdown_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_shutdown_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_shutdown_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->peer_nodes_list.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i98]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readListBegin(_etype102, _size99);
            this->multisig_wallets.resize(_size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              xfer += iprot->readString(this->multisig_wallets[_i103]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->multisig_signs.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += this->multisig_signs[_i108].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_shutdown_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_shutdown_task_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter109;
    for (_iter109 = this->peer_nodes_list.begin(); _iter109 != this->peer_nodes_list.end(); ++_iter109)
    {
      xfer += oprot->writeString((*_iter109));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter110;
    for (_iter110 = this->multisig_wallets.begin(); _iter110 != this->multisig_wallets.end(); ++_iter110)
    {
      xfer += oprot->writeString((*_iter110));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter111;
    for (_iter111 = this->multisig_signs.begin(); _iter111 != this->multisig_signs.end(); ++_iter111)
    {
      xfer += (*_iter111).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_shutdown_task_req_data &a, node_shutdown_task_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_shutdown_task_req_data::node_shutdown_task_req_data(const node_shutdown_task_req_data& other112) {
  task_id = other112.task_id;
  peer_nodes_list = other112.peer_nodes_list;
  additional = other112.additional;
  wallet = other112.wallet;
  nonce = other112.nonce;
  sign = other112.sign;
  multisig_wallets = other112.multisig_wallets;
  multisig_threshold = other112.multisig_threshold;
  multisig_signs = other112.multisig_signs;
  session_id = other112.session_id;
  session_id_sign = other112.session_id_sign;
  rent_order = other112.rent_order;
  __isset = other112.__isset;
}
node_shutdown_task_req_data& node_shutdown_task_req_data::operator=(const node_shutdown_task_req_data& other113) {
  task_id = other113.task_id;
  peer_nodes_list = other113.peer_nodes_list;
  additional = other113.additional;
  wallet = other113.wallet;
  nonce = other113.nonce;
  sign = other113.sign;
  multisig_wallets = other113.multisig_wallets;
  multisig_threshold = other113.multisig_threshold;
  multisig_signs = other113.multisig_signs;
  session_id = other113.session_id;
  session_id_sign = other113.session_id_sign;
  rent_order = other113.rent_order;
  __isset = other113.__isset;
  return *this;
}
void node_shutdown_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_shutdown_task_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_shutdown_task_req_body::~node_shutdown_task_req_body() noexcept {
}


void node_shutdown_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_shutdown_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_shutdown_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_shutdown_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_shutdown_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_shutdown_task_req_body &a, node_shutdown_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_shutdown_task_req_body::node_shutdown_task_req_body(const node_shutdown_task_req_body& other114) {
  data = other114.data;
}
node_shutdown_task_req_body& node_shutdown_task_req_body::operator=(const node_shutdown_task_req_body& other115) {
  data = other115.data;
  return *this;
}
void node_shutdown_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_shutdown_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_shutdown_task_req::~node_shutdown_task_req() noexcept {
}


void node_shutdown_task_req::__set_body(const node_shutdown_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_shutdown_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_shutdown_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_shutdown_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_shutdown_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_shutdown_task_req &a, node_shutdown_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_shutdown_task_req::node_shutdown_task_req(const node_shutdown_task_req& other116) {
  body = other116.body;
  __isset = other116.__isset;
}
node_shutdown_task_req& node_shutdown_task_req::operator=(const node_shutdown_task_req& other117) {
  body = other117.body;
  __isset = other117.__isset;
  return *this;
}
void node_shutdown_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_shutdown_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_shutdown_task_rsp_body::~node_shutdown_task_rsp_body() noexcept {
}


void node_shutdown_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_shutdown_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_shutdown_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_shutdown_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_shutdown_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_shutdown_task_rsp_body &a, node_shutdown_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_shutdown_task_rsp_body::node_shutdown_task_rsp_body(const node_shutdown_task_rsp_body& other118) {
  data = other118.data;
}
node_shutdown_task_rsp_body& node_shutdown_task_rsp_body::operator=(const node_shutdown_task_rsp_body& other119) {
  data = other119.data;
  return *this;
}
void node_shutdown_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_shutdown_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_shutdown_task_rsp::~node_shutdown_task_rsp() noexcept {
}


void node_shutdown_task_rsp::__set_body(const node_shutdown_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_shutdown_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_shutdown_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_shutdown_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_shutdown_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_shutdown_task_rsp &a, node_shutdown_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_shutdown_task_rsp::node_shutdown_task_rsp(const node_shutdown_task_rsp& other120) {
  body = other120.body;
  __isset = other120.__isset;
}
node_shutdown_task_rsp& node_shutdown_task_rsp::operator=(const node_shutdown_task_rsp& other121) {
  body = other121.body;
  __isset = other121.__isset;
  return *this;
}
void node_shutdown_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_shutdown_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_poweroff_task_req_data::~node_poweroff_task_req_data() noexcept {
}


void node_poweroff_task_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_poweroff_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_poweroff_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_poweroff_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_poweroff_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_poweroff_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_poweroff_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_poweroff_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_poweroff_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_poweroff_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_poweroff_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_poweroff_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_poweroff_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_poweroff_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            this->peer_nodes_list.resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i126]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readListBegin(_etype130, _size127);
            this->multisig_wallets.resize(_size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              xfer += iprot->readString(this->multisig_wallets[_i131]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size132;
            ::apache::thrift::protocol::TType _etype135;
            xfer += iprot->readListBegin(_etype135, _size132);
            this->multisig_signs.resize(_size132);
            uint32_t _i136;
            for (_i136 = 0; _i136 < _size132; ++_i136)
            {
              xfer += this->multisig_signs[_i136].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_poweroff_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_poweroff_task_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter137;
    for (_iter137 = this->peer_nodes_list.begin(); _iter137 != this->peer_nodes_list.end(); ++_iter137)
    {
      xfer += oprot->writeString((*_iter137));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter138;
    for (_iter138 = this->multisig_wallets.begin(); _iter138 != this->multisig_wallets.end(); ++_iter138)
    {
      xfer += oprot->writeString((*_iter138));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter139;
    for (_iter139 = this->multisig_signs.begin(); _iter139 != this->multisig_signs.end(); ++_iter139)
    {
      xfer += (*_iter139).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_poweroff_task_req_data &a, node_poweroff_task_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_poweroff_task_req_data::node_poweroff_task_req_data(const node_poweroff_task_req_data& other140) {
  task_id = other140.task_id;
  peer_nodes_list = other140.peer_nodes_list;
  additional = other140.additional;
  wallet = other140.wallet;
  nonce = other140.nonce;
  sign = other140.sign;
  multisig_wallets = other140.multisig_wallets;
  multisig_threshold = other140.multisig_threshold;
  multisig_signs = other140.multisig_signs;
  session_id = other140.session_id;
  session_id_sign = other140.session_id_sign;
  rent_order = other140.rent_order;
  __isset = other140.__isset;
}
node_poweroff_task_req_data& node_poweroff_task_req_data::operator=(const node_poweroff_task_req_data& other141) {
  task_id = other141.task_id;
  peer_nodes_list = other141.peer_nodes_list;
  additional = other141.additional;
  wallet = other141.wallet;
  nonce = other141.nonce;
  sign = other141.sign;
  multisig_wallets = other141.multisig_wallets;
  multisig_threshold = other141.multisig_threshold;
  multisig_signs = other141.multisig_signs;
  session_id = other141.session_id;
  session_id_sign = other141.session_id_sign;
  rent_order = other141.rent_order;
  __isset = other141.__isset;
  return *this;
}
void node_poweroff_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_poweroff_task_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_poweroff_task_req_body::~node_poweroff_task_req_body() noexcept {
}


void node_poweroff_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_poweroff_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_poweroff_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_poweroff_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_poweroff_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_poweroff_task_req_body &a, node_poweroff_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_poweroff_task_req_body::node_poweroff_task_req_body(const node_poweroff_task_req_body& other142) {
  data = other142.data;
}
node_poweroff_task_req_body& node_poweroff_task_req_body::operator=(const node_poweroff_task_req_body& other143) {
  data = other143.data;
  return *this;
}
void node_poweroff_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_poweroff_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_poweroff_task_req::~node_poweroff_task_req() noexcept {
}


void node_poweroff_task_req::__set_body(const node_poweroff_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_poweroff_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_poweroff_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_poweroff_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_poweroff_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_poweroff_task_req &a, node_poweroff_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_poweroff_task_req::node_poweroff_task_req(const node_poweroff_task_req& other144) {
  body = other144.body;
  __isset = other144.__isset;
}
node_poweroff_task_req& node_poweroff_task_req::operator=(const node_poweroff_task_req& other145) {
  body = other145.body;
  __isset = other145.__isset;
  return *this;
}
void node_poweroff_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_poweroff_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_poweroff_task_rsp_body::~node_poweroff_task_rsp_body() noexcept {
}


void node_poweroff_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_poweroff_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_poweroff_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_poweroff_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_poweroff_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_poweroff_task_rsp_body &a, node_poweroff_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_poweroff_task_rsp_body::node_poweroff_task_rsp_body(const node_poweroff_task_rsp_body& other146) {
  data = other146.data;
}
node_poweroff_task_rsp_body& node_poweroff_task_rsp_body::operator=(const node_poweroff_task_rsp_body& other147) {
  data = other147.data;
  return *this;
}
void node_poweroff_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_poweroff_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_poweroff_task_rsp::~node_poweroff_task_rsp() noexcept {
}


void node_poweroff_task_rsp::__set_body(const node_poweroff_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_poweroff_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_poweroff_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_poweroff_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_poweroff_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_poweroff_task_rsp &a, node_poweroff_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_poweroff_task_rsp::node_poweroff_task_rsp(const node_poweroff_task_rsp& other148) {
  body = other148.body;
  __isset = other148.__isset;
}
node_poweroff_task_rsp& node_poweroff_task_rsp::operator=(const node_poweroff_task_rsp& other149) {
  body = other149.body;
  __isset = other149.__isset;
  return *this;
}
void node_poweroff_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_poweroff_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_stop_task_req_data::~node_stop_task_req_data() noexcept {
}


void node_stop_task_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_stop_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_stop_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_stop_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_stop_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_stop_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_stop_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_stop_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_stop_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_stop_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_stop_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_stop_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_stop_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size150;
            ::apache::thrift::protocol::TType _etype153;
            xfer += iprot->readListBegin(_etype153, _size150);
            this->peer_nodes_list.resize(_size150);
            uint32_t _i154;
            for (_i154 = 0; _i154 < _size150; ++_i154)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i154]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size155;
            ::apache::thrift::protocol::TType _etype158;
            xfer += iprot->readListBegin(_etype158, _size155);
            this->multisig_wallets.resize(_size155);
            uint32_t _i159;
            for (_i159 = 0; _i159 < _size155; ++_i159)
            {
              xfer += iprot->readString(this->multisig_wallets[_i159]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readListBegin(_etype163, _size160);
            this->multisig_signs.resize(_size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              xfer += this->multisig_signs[_i164].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_stop_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_task_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter165;
    for (_iter165 = this->peer_nodes_list.begin(); _iter165 != this->peer_nodes_list.end(); ++_iter165)
    {
      xfer += oprot->writeString((*_iter165));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter166;
    for (_iter166 = this->multisig_wallets.begin(); _iter166 != this->multisig_wallets.end(); ++_iter166)
    {
      xfer += oprot->writeString((*_iter166));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter167;
    for (_iter167 = this->multisig_signs.begin(); _iter167 != this->multisig_signs.end(); ++_iter167)
    {
      xfer += (*_iter167).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_task_req_data &a, node_stop_task_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_stop_task_req_data::node_stop_task_req_data(const node_stop_task_req_data& other168) {
  task_id = other168.task_id;
  peer_nodes_list = other168.peer_nodes_list;
  additional = other168.additional;
  wallet = other168.wallet;
  nonce = other168.nonce;
  sign = other168.sign;
  multisig_wallets = other168.multisig_wallets;
  multisig_threshold = other168.multisig_threshold;
  multisig_signs = other168.multisig_signs;
  session_id = other168.session_id;
  session_id_sign = other168.session_id_sign;
  rent_order = other168.rent_order;
  __isset = other168.__isset;
}
node_stop_task_req_data& node_stop_task_req_data::operator=(const node_stop_task_req_data& other169) {
  task_id = other169.task_id;
  peer_nodes_list = other169.peer_nodes_list;
  additional = other169.additional;
  wallet = other169.wallet;
  nonce = other169.nonce;
  sign = other169.sign;
  multisig_wallets = other169.multisig_wallets;
  multisig_threshold = other169.multisig_threshold;
  multisig_signs = other169.multisig_signs;
  session_id = other169.session_id;
  session_id_sign = other169.session_id_sign;
  rent_order = other169.rent_order;
  __isset = other169.__isset;
  return *this;
}
void node_stop_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_task_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_stop_task_req_body::~node_stop_task_req_body() noexcept {
}


void node_stop_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_stop_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_task_req_body &a, node_stop_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_stop_task_req_body::node_stop_task_req_body(const node_stop_task_req_body& other170) {
  data = other170.data;
}
node_stop_task_req_body& node_stop_task_req_body::operator=(const node_stop_task_req_body& other171) {
  data = other171.data;
  return *this;
}
void node_stop_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_stop_task_req::~node_stop_task_req() noexcept {
}


void node_stop_task_req::__set_body(const node_stop_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_stop_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_task_req &a, node_stop_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_stop_task_req::node_stop_task_req(const node_stop_task_req& other172) {
  body = other172.body;
  __isset = other172.__isset;
}
node_stop_task_req& node_stop_task_req::operator=(const node_stop_task_req& other173) {
  body = other173.body;
  __isset = other173.__isset;
  return *this;
}
void node_stop_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_stop_task_rsp_body::~node_stop_task_rsp_body() noexcept {
}


void node_stop_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_stop_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_task_rsp_body &a, node_stop_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_stop_task_rsp_body::node_stop_task_rsp_body(const node_stop_task_rsp_body& other174) {
  data = other174.data;
}
node_stop_task_rsp_body& node_stop_task_rsp_body::operator=(const node_stop_task_rsp_body& other175) {
  data = other175.data;
  return *this;
}
void node_stop_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_stop_task_rsp::~node_stop_task_rsp() noexcept {
}


void node_stop_task_rsp::__set_body(const node_stop_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_stop_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_task_rsp &a, node_stop_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_stop_task_rsp::node_stop_task_rsp(const node_stop_task_rsp& other176) {
  body = other176.body;
  __isset = other176.__isset;
}
node_stop_task_rsp& node_stop_task_rsp::operator=(const node_stop_task_rsp& other177) {
  body = other177.body;
  __isset = other177.__isset;
  return *this;
}
void node_stop_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_restart_task_req_data::~node_restart_task_req_data() noexcept {
}


void node_restart_task_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_restart_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_restart_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_restart_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_restart_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_restart_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_restart_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_restart_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_restart_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_restart_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_restart_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_restart_task_req_data::__set_force_reboot(const int16_t val) {
  this->force_reboot = val;
__isset.force_reboot = true;
}

void node_restart_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_restart_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_restart_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size178;
            ::apache::thrift::protocol::TType _etype181;
            xfer += iprot->readListBegin(_etype181, _size178);
            this->peer_nodes_list.resize(_size178);
            uint32_t _i182;
            for (_i182 = 0; _i182 < _size178; ++_i182)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i182]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size183;
            ::apache::thrift::protocol::TType _etype186;
            xfer += iprot->readListBegin(_etype186, _size183);
            this->multisig_wallets.resize(_size183);
            uint32_t _i187;
            for (_i187 = 0; _i187 < _size183; ++_i187)
            {
              xfer += iprot->readString(this->multisig_wallets[_i187]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size188;
            ::apache::thrift::protocol::TType _etype191;
            xfer += iprot->readListBegin(_etype191, _size188);
            this->multisig_signs.resize(_size188);
            uint32_t _i192;
            for (_i192 = 0; _i192 < _size188; ++_i192)
            {
              xfer += this->multisig_signs[_i192].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->force_reboot);
          this->__isset.force_reboot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_restart_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_restart_task_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter193;
    for (_iter193 = this->peer_nodes_list.begin(); _iter193 != this->peer_nodes_list.end(); ++_iter193)
    {
      xfer += oprot->writeString((*_iter193));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter194;
    for (_iter194 = this->multisig_wallets.begin(); _iter194 != this->multisig_wallets.end(); ++_iter194)
    {
      xfer += oprot->writeString((*_iter194));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter195;
    for (_iter195 = this->multisig_signs.begin(); _iter195 != this->multisig_signs.end(); ++_iter195)
    {
      xfer += (*_iter195).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.force_reboot) {
    xfer += oprot->writeFieldBegin("force_reboot", ::apache::thrift::protocol::T_I16, 12);
    xfer += oprot->writeI16(this->force_reboot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_restart_task_req_data &a, node_restart_task_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.force_reboot, b.force_reboot);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_restart_task_req_data::node_restart_task_req_data(const node_restart_task_req_data& other196) {
  task_id = other196.task_id;
  peer_nodes_list = other196.peer_nodes_list;
  additional = other196.additional;
  wallet = other196.wallet;
  nonce = other196.nonce;
  sign = other196.sign;
  multisig_wallets = other196.multisig_wallets;
  multisig_threshold = other196.multisig_threshold;
  multisig_signs = other196.multisig_signs;
  session_id = other196.session_id;
  session_id_sign = other196.session_id_sign;
  force_reboot = other196.force_reboot;
  rent_order = other196.rent_order;
  __isset = other196.__isset;
}
node_restart_task_req_data& node_restart_task_req_data::operator=(const node_restart_task_req_data& other197) {
  task_id = other197.task_id;
  peer_nodes_list = other197.peer_nodes_list;
  additional = other197.additional;
  wallet = other197.wallet;
  nonce = other197.nonce;
  sign = other197.sign;
  multisig_wallets = other197.multisig_wallets;
  multisig_threshold = other197.multisig_threshold;
  multisig_signs = other197.multisig_signs;
  session_id = other197.session_id;
  session_id_sign = other197.session_id_sign;
  force_reboot = other197.force_reboot;
  rent_order = other197.rent_order;
  __isset = other197.__isset;
  return *this;
}
void node_restart_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_restart_task_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "force_reboot="; (__isset.force_reboot ? (out << to_string(force_reboot)) : (out << "<null>"));
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_restart_task_req_body::~node_restart_task_req_body() noexcept {
}


void node_restart_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_restart_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_restart_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_restart_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_restart_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_restart_task_req_body &a, node_restart_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_restart_task_req_body::node_restart_task_req_body(const node_restart_task_req_body& other198) {
  data = other198.data;
}
node_restart_task_req_body& node_restart_task_req_body::operator=(const node_restart_task_req_body& other199) {
  data = other199.data;
  return *this;
}
void node_restart_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_restart_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_restart_task_req::~node_restart_task_req() noexcept {
}


void node_restart_task_req::__set_body(const node_restart_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_restart_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_restart_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_restart_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_restart_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_restart_task_req &a, node_restart_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_restart_task_req::node_restart_task_req(const node_restart_task_req& other200) {
  body = other200.body;
  __isset = other200.__isset;
}
node_restart_task_req& node_restart_task_req::operator=(const node_restart_task_req& other201) {
  body = other201.body;
  __isset = other201.__isset;
  return *this;
}
void node_restart_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_restart_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_restart_task_rsp_body::~node_restart_task_rsp_body() noexcept {
}


void node_restart_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_restart_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_restart_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_restart_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_restart_task_rsp_body &a, node_restart_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_restart_task_rsp_body::node_restart_task_rsp_body(const node_restart_task_rsp_body& other202) {
  data = other202.data;
}
node_restart_task_rsp_body& node_restart_task_rsp_body::operator=(const node_restart_task_rsp_body& other203) {
  data = other203.data;
  return *this;
}
void node_restart_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_restart_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_restart_task_rsp::~node_restart_task_rsp() noexcept {
}


void node_restart_task_rsp::__set_body(const node_restart_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_restart_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_restart_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_restart_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_restart_task_rsp &a, node_restart_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_restart_task_rsp::node_restart_task_rsp(const node_restart_task_rsp& other204) {
  body = other204.body;
  __isset = other204.__isset;
}
node_restart_task_rsp& node_restart_task_rsp::operator=(const node_restart_task_rsp& other205) {
  body = other205.body;
  __isset = other205.__isset;
  return *this;
}
void node_restart_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_restart_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_reset_task_req_data::~node_reset_task_req_data() noexcept {
}


void node_reset_task_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_reset_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_reset_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_reset_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_reset_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_reset_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_reset_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_reset_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_reset_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_reset_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_reset_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_reset_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_reset_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_reset_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size206;
            ::apache::thrift::protocol::TType _etype209;
            xfer += iprot->readListBegin(_etype209, _size206);
            this->peer_nodes_list.resize(_size206);
            uint32_t _i210;
            for (_i210 = 0; _i210 < _size206; ++_i210)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i210]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size211;
            ::apache::thrift::protocol::TType _etype214;
            xfer += iprot->readListBegin(_etype214, _size211);
            this->multisig_wallets.resize(_size211);
            uint32_t _i215;
            for (_i215 = 0; _i215 < _size211; ++_i215)
            {
              xfer += iprot->readString(this->multisig_wallets[_i215]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size216;
            ::apache::thrift::protocol::TType _etype219;
            xfer += iprot->readListBegin(_etype219, _size216);
            this->multisig_signs.resize(_size216);
            uint32_t _i220;
            for (_i220 = 0; _i220 < _size216; ++_i220)
            {
              xfer += this->multisig_signs[_i220].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_reset_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_reset_task_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter221;
    for (_iter221 = this->peer_nodes_list.begin(); _iter221 != this->peer_nodes_list.end(); ++_iter221)
    {
      xfer += oprot->writeString((*_iter221));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter222;
    for (_iter222 = this->multisig_wallets.begin(); _iter222 != this->multisig_wallets.end(); ++_iter222)
    {
      xfer += oprot->writeString((*_iter222));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter223;
    for (_iter223 = this->multisig_signs.begin(); _iter223 != this->multisig_signs.end(); ++_iter223)
    {
      xfer += (*_iter223).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_reset_task_req_data &a, node_reset_task_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_reset_task_req_data::node_reset_task_req_data(const node_reset_task_req_data& other224) {
  task_id = other224.task_id;
  peer_nodes_list = other224.peer_nodes_list;
  additional = other224.additional;
  wallet = other224.wallet;
  nonce = other224.nonce;
  sign = other224.sign;
  multisig_wallets = other224.multisig_wallets;
  multisig_threshold = other224.multisig_threshold;
  multisig_signs = other224.multisig_signs;
  session_id = other224.session_id;
  session_id_sign = other224.session_id_sign;
  rent_order = other224.rent_order;
  __isset = other224.__isset;
}
node_reset_task_req_data& node_reset_task_req_data::operator=(const node_reset_task_req_data& other225) {
  task_id = other225.task_id;
  peer_nodes_list = other225.peer_nodes_list;
  additional = other225.additional;
  wallet = other225.wallet;
  nonce = other225.nonce;
  sign = other225.sign;
  multisig_wallets = other225.multisig_wallets;
  multisig_threshold = other225.multisig_threshold;
  multisig_signs = other225.multisig_signs;
  session_id = other225.session_id;
  session_id_sign = other225.session_id_sign;
  rent_order = other225.rent_order;
  __isset = other225.__isset;
  return *this;
}
void node_reset_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_reset_task_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_reset_task_req_body::~node_reset_task_req_body() noexcept {
}


void node_reset_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_reset_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_reset_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_reset_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_reset_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_reset_task_req_body &a, node_reset_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_reset_task_req_body::node_reset_task_req_body(const node_reset_task_req_body& other226) {
  data = other226.data;
}
node_reset_task_req_body& node_reset_task_req_body::operator=(const node_reset_task_req_body& other227) {
  data = other227.data;
  return *this;
}
void node_reset_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_reset_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_reset_task_req::~node_reset_task_req() noexcept {
}


void node_reset_task_req::__set_body(const node_reset_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_reset_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_reset_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_reset_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_reset_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_reset_task_req &a, node_reset_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_reset_task_req::node_reset_task_req(const node_reset_task_req& other228) {
  body = other228.body;
  __isset = other228.__isset;
}
node_reset_task_req& node_reset_task_req::operator=(const node_reset_task_req& other229) {
  body = other229.body;
  __isset = other229.__isset;
  return *this;
}
void node_reset_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_reset_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_reset_task_rsp_body::~node_reset_task_rsp_body() noexcept {
}


void node_reset_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_reset_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_reset_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_reset_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_reset_task_rsp_body &a, node_reset_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_reset_task_rsp_body::node_reset_task_rsp_body(const node_reset_task_rsp_body& other230) {
  data = other230.data;
}
node_reset_task_rsp_body& node_reset_task_rsp_body::operator=(const node_reset_task_rsp_body& other231) {
  data = other231.data;
  return *this;
}
void node_reset_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_reset_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_reset_task_rsp::~node_reset_task_rsp() noexcept {
}


void node_reset_task_rsp::__set_body(const node_reset_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_reset_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_reset_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_reset_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_reset_task_rsp &a, node_reset_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_reset_task_rsp::node_reset_task_rsp(const node_reset_task_rsp& other232) {
  body = other232.body;
  __isset = other232.__isset;
}
node_reset_task_rsp& node_reset_task_rsp::operator=(const node_reset_task_rsp& other233) {
  body = other233.body;
  __isset = other233.__isset;
  return *this;
}
void node_reset_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_reset_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_delete_task_req_data::~node_delete_task_req_data() noexcept {
}


void node_delete_task_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_delete_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_delete_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_delete_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_delete_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_delete_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_delete_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_delete_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_delete_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_delete_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_delete_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_delete_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_delete_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size234;
            ::apache::thrift::protocol::TType _etype237;
            xfer += iprot->readListBegin(_etype237, _size234);
            this->peer_nodes_list.resize(_size234);
            uint32_t _i238;
            for (_i238 = 0; _i238 < _size234; ++_i238)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i238]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size239;
            ::apache::thrift::protocol::TType _etype242;
            xfer += iprot->readListBegin(_etype242, _size239);
            this->multisig_wallets.resize(_size239);
            uint32_t _i243;
            for (_i243 = 0; _i243 < _size239; ++_i243)
            {
              xfer += iprot->readString(this->multisig_wallets[_i243]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size244;
            ::apache::thrift::protocol::TType _etype247;
            xfer += iprot->readListBegin(_etype247, _size244);
            this->multisig_signs.resize(_size244);
            uint32_t _i248;
            for (_i248 = 0; _i248 < _size244; ++_i248)
            {
              xfer += this->multisig_signs[_i248].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_task_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter249;
    for (_iter249 = this->peer_nodes_list.begin(); _iter249 != this->peer_nodes_list.end(); ++_iter249)
    {
      xfer += oprot->writeString((*_iter249));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter250;
    for (_iter250 = this->multisig_wallets.begin(); _iter250 != this->multisig_wallets.end(); ++_iter250)
    {
      xfer += oprot->writeString((*_iter250));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter251;
    for (_iter251 = this->multisig_signs.begin(); _iter251 != this->multisig_signs.end(); ++_iter251)
    {
      xfer += (*_iter251).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_task_req_data &a, node_delete_task_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_delete_task_req_data::node_delete_task_req_data(const node_delete_task_req_data& other252) {
  task_id = other252.task_id;
  peer_nodes_list = other252.peer_nodes_list;
  additional = other252.additional;
  wallet = other252.wallet;
  nonce = other252.nonce;
  sign = other252.sign;
  multisig_wallets = other252.multisig_wallets;
  multisig_threshold = other252.multisig_threshold;
  multisig_signs = other252.multisig_signs;
  session_id = other252.session_id;
  session_id_sign = other252.session_id_sign;
  rent_order = other252.rent_order;
  __isset = other252.__isset;
}
node_delete_task_req_data& node_delete_task_req_data::operator=(const node_delete_task_req_data& other253) {
  task_id = other253.task_id;
  peer_nodes_list = other253.peer_nodes_list;
  additional = other253.additional;
  wallet = other253.wallet;
  nonce = other253.nonce;
  sign = other253.sign;
  multisig_wallets = other253.multisig_wallets;
  multisig_threshold = other253.multisig_threshold;
  multisig_signs = other253.multisig_signs;
  session_id = other253.session_id;
  session_id_sign = other253.session_id_sign;
  rent_order = other253.rent_order;
  __isset = other253.__isset;
  return *this;
}
void node_delete_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_task_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_delete_task_req_body::~node_delete_task_req_body() noexcept {
}


void node_delete_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_task_req_body &a, node_delete_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_delete_task_req_body::node_delete_task_req_body(const node_delete_task_req_body& other254) {
  data = other254.data;
}
node_delete_task_req_body& node_delete_task_req_body::operator=(const node_delete_task_req_body& other255) {
  data = other255.data;
  return *this;
}
void node_delete_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_delete_task_req::~node_delete_task_req() noexcept {
}


void node_delete_task_req::__set_body(const node_delete_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_delete_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_task_req &a, node_delete_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_delete_task_req::node_delete_task_req(const node_delete_task_req& other256) {
  body = other256.body;
  __isset = other256.__isset;
}
node_delete_task_req& node_delete_task_req::operator=(const node_delete_task_req& other257) {
  body = other257.body;
  __isset = other257.__isset;
  return *this;
}
void node_delete_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_delete_task_rsp_body::~node_delete_task_rsp_body() noexcept {
}


void node_delete_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_task_rsp_body &a, node_delete_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_delete_task_rsp_body::node_delete_task_rsp_body(const node_delete_task_rsp_body& other258) {
  data = other258.data;
}
node_delete_task_rsp_body& node_delete_task_rsp_body::operator=(const node_delete_task_rsp_body& other259) {
  data = other259.data;
  return *this;
}
void node_delete_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_delete_task_rsp::~node_delete_task_rsp() noexcept {
}


void node_delete_task_rsp::__set_body(const node_delete_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_delete_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_task_rsp &a, node_delete_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_delete_task_rsp::node_delete_task_rsp(const node_delete_task_rsp& other260) {
  body = other260.body;
  __isset = other260.__isset;
}
node_delete_task_rsp& node_delete_task_rsp::operator=(const node_delete_task_rsp& other261) {
  body = other261.body;
  __isset = other261.__isset;
  return *this;
}
void node_delete_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_task_logs_req_data::~node_task_logs_req_data() noexcept {
}


void node_task_logs_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_task_logs_req_data::__set_head_or_tail(const int16_t val) {
  this->head_or_tail = val;
}

void node_task_logs_req_data::__set_number_of_lines(const int32_t val) {
  this->number_of_lines = val;
}

void node_task_logs_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_task_logs_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_task_logs_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_task_logs_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_task_logs_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_task_logs_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_task_logs_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_task_logs_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_task_logs_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_task_logs_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_task_logs_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_task_logs_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_task_logs_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_head_or_tail = false;
  bool isset_number_of_lines = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->head_or_tail);
          isset_head_or_tail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_lines);
          isset_number_of_lines = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _etype265;
            xfer += iprot->readListBegin(_etype265, _size262);
            this->peer_nodes_list.resize(_size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i266]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readListBegin(_etype270, _size267);
            this->multisig_wallets.resize(_size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              xfer += iprot->readString(this->multisig_wallets[_i271]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size272;
            ::apache::thrift::protocol::TType _etype275;
            xfer += iprot->readListBegin(_etype275, _size272);
            this->multisig_signs.resize(_size272);
            uint32_t _i276;
            for (_i276 = 0; _i276 < _size272; ++_i276)
            {
              xfer += this->multisig_signs[_i276].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_head_or_tail)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_number_of_lines)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_task_logs_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_task_logs_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("head_or_tail", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->head_or_tail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_lines", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_lines);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter277;
    for (_iter277 = this->peer_nodes_list.begin(); _iter277 != this->peer_nodes_list.end(); ++_iter277)
    {
      xfer += oprot->writeString((*_iter277));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter278;
    for (_iter278 = this->multisig_wallets.begin(); _iter278 != this->multisig_wallets.end(); ++_iter278)
    {
      xfer += oprot->writeString((*_iter278));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter279;
    for (_iter279 = this->multisig_signs.begin(); _iter279 != this->multisig_signs.end(); ++_iter279)
    {
      xfer += (*_iter279).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_task_logs_req_data &a, node_task_logs_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.head_or_tail, b.head_or_tail);
  swap(a.number_of_lines, b.number_of_lines);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_task_logs_req_data::node_task_logs_req_data(const node_task_logs_req_data& other280) {
  task_id = other280.task_id;
  head_or_tail = other280.head_or_tail;
  number_of_lines = other280.number_of_lines;
  peer_nodes_list = other280.peer_nodes_list;
  additional = other280.additional;
  wallet = other280.wallet;
  nonce = other280.nonce;
  sign = other280.sign;
  multisig_wallets = other280.multisig_wallets;
  multisig_threshold = other280.multisig_threshold;
  multisig_signs = other280.multisig_signs;
  session_id = other280.session_id;
  session_id_sign = other280.session_id_sign;
  rent_order = other280.rent_order;
  __isset = other280.__isset;
}
node_task_logs_req_data& node_task_logs_req_data::operator=(const node_task_logs_req_data& other281) {
  task_id = other281.task_id;
  head_or_tail = other281.head_or_tail;
  number_of_lines = other281.number_of_lines;
  peer_nodes_list = other281.peer_nodes_list;
  additional = other281.additional;
  wallet = other281.wallet;
  nonce = other281.nonce;
  sign = other281.sign;
  multisig_wallets = other281.multisig_wallets;
  multisig_threshold = other281.multisig_threshold;
  multisig_signs = other281.multisig_signs;
  session_id = other281.session_id;
  session_id_sign = other281.session_id_sign;
  rent_order = other281.rent_order;
  __isset = other281.__isset;
  return *this;
}
void node_task_logs_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_task_logs_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "head_or_tail=" << to_string(head_or_tail);
  out << ", " << "number_of_lines=" << to_string(number_of_lines);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_task_logs_req_body::~node_task_logs_req_body() noexcept {
}


void node_task_logs_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_task_logs_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_task_logs_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_task_logs_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_task_logs_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_task_logs_req_body &a, node_task_logs_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_task_logs_req_body::node_task_logs_req_body(const node_task_logs_req_body& other282) {
  data = other282.data;
}
node_task_logs_req_body& node_task_logs_req_body::operator=(const node_task_logs_req_body& other283) {
  data = other283.data;
  return *this;
}
void node_task_logs_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_task_logs_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_task_logs_req::~node_task_logs_req() noexcept {
}


void node_task_logs_req::__set_body(const node_task_logs_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_task_logs_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_task_logs_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_task_logs_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_task_logs_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_task_logs_req &a, node_task_logs_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_task_logs_req::node_task_logs_req(const node_task_logs_req& other284) {
  body = other284.body;
  __isset = other284.__isset;
}
node_task_logs_req& node_task_logs_req::operator=(const node_task_logs_req& other285) {
  body = other285.body;
  __isset = other285.__isset;
  return *this;
}
void node_task_logs_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_task_logs_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_task_logs_rsp_body::~node_task_logs_rsp_body() noexcept {
}


void node_task_logs_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_task_logs_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_task_logs_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_task_logs_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_task_logs_rsp_body &a, node_task_logs_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_task_logs_rsp_body::node_task_logs_rsp_body(const node_task_logs_rsp_body& other286) {
  data = other286.data;
}
node_task_logs_rsp_body& node_task_logs_rsp_body::operator=(const node_task_logs_rsp_body& other287) {
  data = other287.data;
  return *this;
}
void node_task_logs_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_task_logs_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_task_logs_rsp::~node_task_logs_rsp() noexcept {
}


void node_task_logs_rsp::__set_body(const node_task_logs_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_task_logs_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_task_logs_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_task_logs_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_task_logs_rsp &a, node_task_logs_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_task_logs_rsp::node_task_logs_rsp(const node_task_logs_rsp& other288) {
  body = other288.body;
  __isset = other288.__isset;
}
node_task_logs_rsp& node_task_logs_rsp::operator=(const node_task_logs_rsp& other289) {
  body = other289.body;
  __isset = other289.__isset;
  return *this;
}
void node_task_logs_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_task_logs_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_modify_task_req_data::~node_modify_task_req_data() noexcept {
}


void node_modify_task_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_modify_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_modify_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_modify_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_modify_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_modify_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_modify_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_modify_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_modify_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_modify_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_modify_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_modify_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_modify_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_modify_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size290;
            ::apache::thrift::protocol::TType _etype293;
            xfer += iprot->readListBegin(_etype293, _size290);
            this->peer_nodes_list.resize(_size290);
            uint32_t _i294;
            for (_i294 = 0; _i294 < _size290; ++_i294)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i294]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size295;
            ::apache::thrift::protocol::TType _etype298;
            xfer += iprot->readListBegin(_etype298, _size295);
            this->multisig_wallets.resize(_size295);
            uint32_t _i299;
            for (_i299 = 0; _i299 < _size295; ++_i299)
            {
              xfer += iprot->readString(this->multisig_wallets[_i299]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size300;
            ::apache::thrift::protocol::TType _etype303;
            xfer += iprot->readListBegin(_etype303, _size300);
            this->multisig_signs.resize(_size300);
            uint32_t _i304;
            for (_i304 = 0; _i304 < _size300; ++_i304)
            {
              xfer += this->multisig_signs[_i304].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_modify_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_modify_task_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter305;
    for (_iter305 = this->peer_nodes_list.begin(); _iter305 != this->peer_nodes_list.end(); ++_iter305)
    {
      xfer += oprot->writeString((*_iter305));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter306;
    for (_iter306 = this->multisig_wallets.begin(); _iter306 != this->multisig_wallets.end(); ++_iter306)
    {
      xfer += oprot->writeString((*_iter306));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter307;
    for (_iter307 = this->multisig_signs.begin(); _iter307 != this->multisig_signs.end(); ++_iter307)
    {
      xfer += (*_iter307).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_modify_task_req_data &a, node_modify_task_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_modify_task_req_data::node_modify_task_req_data(const node_modify_task_req_data& other308) {
  task_id = other308.task_id;
  peer_nodes_list = other308.peer_nodes_list;
  additional = other308.additional;
  wallet = other308.wallet;
  nonce = other308.nonce;
  sign = other308.sign;
  multisig_wallets = other308.multisig_wallets;
  multisig_threshold = other308.multisig_threshold;
  multisig_signs = other308.multisig_signs;
  session_id = other308.session_id;
  session_id_sign = other308.session_id_sign;
  rent_order = other308.rent_order;
  __isset = other308.__isset;
}
node_modify_task_req_data& node_modify_task_req_data::operator=(const node_modify_task_req_data& other309) {
  task_id = other309.task_id;
  peer_nodes_list = other309.peer_nodes_list;
  additional = other309.additional;
  wallet = other309.wallet;
  nonce = other309.nonce;
  sign = other309.sign;
  multisig_wallets = other309.multisig_wallets;
  multisig_threshold = other309.multisig_threshold;
  multisig_signs = other309.multisig_signs;
  session_id = other309.session_id;
  session_id_sign = other309.session_id_sign;
  rent_order = other309.rent_order;
  __isset = other309.__isset;
  return *this;
}
void node_modify_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_modify_task_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_modify_task_req_body::~node_modify_task_req_body() noexcept {
}


void node_modify_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_modify_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_modify_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_modify_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_modify_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_modify_task_req_body &a, node_modify_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_modify_task_req_body::node_modify_task_req_body(const node_modify_task_req_body& other310) {
  data = other310.data;
}
node_modify_task_req_body& node_modify_task_req_body::operator=(const node_modify_task_req_body& other311) {
  data = other311.data;
  return *this;
}
void node_modify_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_modify_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_modify_task_req::~node_modify_task_req() noexcept {
}


void node_modify_task_req::__set_body(const node_modify_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_modify_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_modify_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_modify_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_modify_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_modify_task_req &a, node_modify_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_modify_task_req::node_modify_task_req(const node_modify_task_req& other312) {
  body = other312.body;
  __isset = other312.__isset;
}
node_modify_task_req& node_modify_task_req::operator=(const node_modify_task_req& other313) {
  body = other313.body;
  __isset = other313.__isset;
  return *this;
}
void node_modify_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_modify_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_modify_task_rsp_body::~node_modify_task_rsp_body() noexcept {
}


void node_modify_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_modify_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_modify_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_modify_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_modify_task_rsp_body &a, node_modify_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_modify_task_rsp_body::node_modify_task_rsp_body(const node_modify_task_rsp_body& other314) {
  data = other314.data;
}
node_modify_task_rsp_body& node_modify_task_rsp_body::operator=(const node_modify_task_rsp_body& other315) {
  data = other315.data;
  return *this;
}
void node_modify_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_modify_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_modify_task_rsp::~node_modify_task_rsp() noexcept {
}


void node_modify_task_rsp::__set_body(const node_modify_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_modify_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_modify_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_modify_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_modify_task_rsp &a, node_modify_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_modify_task_rsp::node_modify_task_rsp(const node_modify_task_rsp& other316) {
  body = other316.body;
  __isset = other316.__isset;
}
node_modify_task_rsp& node_modify_task_rsp::operator=(const node_modify_task_rsp& other317) {
  body = other317.body;
  __isset = other317.__isset;
  return *this;
}
void node_modify_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_modify_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_passwd_task_req_data::~node_passwd_task_req_data() noexcept {
}


void node_passwd_task_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_passwd_task_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_passwd_task_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_passwd_task_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_passwd_task_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_passwd_task_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_passwd_task_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_passwd_task_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_passwd_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_passwd_task_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_passwd_task_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_passwd_task_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_passwd_task_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_passwd_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size318;
            ::apache::thrift::protocol::TType _etype321;
            xfer += iprot->readListBegin(_etype321, _size318);
            this->peer_nodes_list.resize(_size318);
            uint32_t _i322;
            for (_i322 = 0; _i322 < _size318; ++_i322)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i322]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size323;
            ::apache::thrift::protocol::TType _etype326;
            xfer += iprot->readListBegin(_etype326, _size323);
            this->multisig_wallets.resize(_size323);
            uint32_t _i327;
            for (_i327 = 0; _i327 < _size323; ++_i327)
            {
              xfer += iprot->readString(this->multisig_wallets[_i327]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size328;
            ::apache::thrift::protocol::TType _etype331;
            xfer += iprot->readListBegin(_etype331, _size328);
            this->multisig_signs.resize(_size328);
            uint32_t _i332;
            for (_i332 = 0; _i332 < _size328; ++_i332)
            {
              xfer += this->multisig_signs[_i332].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_passwd_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_passwd_task_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter333;
    for (_iter333 = this->peer_nodes_list.begin(); _iter333 != this->peer_nodes_list.end(); ++_iter333)
    {
      xfer += oprot->writeString((*_iter333));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter334;
    for (_iter334 = this->multisig_wallets.begin(); _iter334 != this->multisig_wallets.end(); ++_iter334)
    {
      xfer += oprot->writeString((*_iter334));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter335;
    for (_iter335 = this->multisig_signs.begin(); _iter335 != this->multisig_signs.end(); ++_iter335)
    {
      xfer += (*_iter335).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_passwd_task_req_data &a, node_passwd_task_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_passwd_task_req_data::node_passwd_task_req_data(const node_passwd_task_req_data& other336) {
  task_id = other336.task_id;
  peer_nodes_list = other336.peer_nodes_list;
  additional = other336.additional;
  wallet = other336.wallet;
  nonce = other336.nonce;
  sign = other336.sign;
  multisig_wallets = other336.multisig_wallets;
  multisig_threshold = other336.multisig_threshold;
  multisig_signs = other336.multisig_signs;
  session_id = other336.session_id;
  session_id_sign = other336.session_id_sign;
  rent_order = other336.rent_order;
  __isset = other336.__isset;
}
node_passwd_task_req_data& node_passwd_task_req_data::operator=(const node_passwd_task_req_data& other337) {
  task_id = other337.task_id;
  peer_nodes_list = other337.peer_nodes_list;
  additional = other337.additional;
  wallet = other337.wallet;
  nonce = other337.nonce;
  sign = other337.sign;
  multisig_wallets = other337.multisig_wallets;
  multisig_threshold = other337.multisig_threshold;
  multisig_signs = other337.multisig_signs;
  session_id = other337.session_id;
  session_id_sign = other337.session_id_sign;
  rent_order = other337.rent_order;
  __isset = other337.__isset;
  return *this;
}
void node_passwd_task_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_passwd_task_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_passwd_task_req_body::~node_passwd_task_req_body() noexcept {
}


void node_passwd_task_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_passwd_task_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_passwd_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_passwd_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_passwd_task_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_passwd_task_req_body &a, node_passwd_task_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_passwd_task_req_body::node_passwd_task_req_body(const node_passwd_task_req_body& other338) {
  data = other338.data;
}
node_passwd_task_req_body& node_passwd_task_req_body::operator=(const node_passwd_task_req_body& other339) {
  data = other339.data;
  return *this;
}
void node_passwd_task_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_passwd_task_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_passwd_task_req::~node_passwd_task_req() noexcept {
}


void node_passwd_task_req::__set_body(const node_passwd_task_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_passwd_task_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_passwd_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_passwd_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_passwd_task_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_passwd_task_req &a, node_passwd_task_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_passwd_task_req::node_passwd_task_req(const node_passwd_task_req& other340) {
  body = other340.body;
  __isset = other340.__isset;
}
node_passwd_task_req& node_passwd_task_req::operator=(const node_passwd_task_req& other341) {
  body = other341.body;
  __isset = other341.__isset;
  return *this;
}
void node_passwd_task_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_passwd_task_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_passwd_task_rsp_body::~node_passwd_task_rsp_body() noexcept {
}


void node_passwd_task_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_passwd_task_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_passwd_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_passwd_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_passwd_task_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_passwd_task_rsp_body &a, node_passwd_task_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_passwd_task_rsp_body::node_passwd_task_rsp_body(const node_passwd_task_rsp_body& other342) {
  data = other342.data;
}
node_passwd_task_rsp_body& node_passwd_task_rsp_body::operator=(const node_passwd_task_rsp_body& other343) {
  data = other343.data;
  return *this;
}
void node_passwd_task_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_passwd_task_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_passwd_task_rsp::~node_passwd_task_rsp() noexcept {
}


void node_passwd_task_rsp::__set_body(const node_passwd_task_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_passwd_task_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_passwd_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_passwd_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_passwd_task_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_passwd_task_rsp &a, node_passwd_task_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_passwd_task_rsp::node_passwd_task_rsp(const node_passwd_task_rsp& other344) {
  body = other344.body;
  __isset = other344.__isset;
}
node_passwd_task_rsp& node_passwd_task_rsp::operator=(const node_passwd_task_rsp& other345) {
  body = other345.body;
  __isset = other345.__isset;
  return *this;
}
void node_passwd_task_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_passwd_task_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_images_req_data::~node_list_images_req_data() noexcept {
}


void node_list_images_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_list_images_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_list_images_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_list_images_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_list_images_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_list_images_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_list_images_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_list_images_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_list_images_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_list_images_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_list_images_req_data::__set_image_server(const std::string& val) {
  this->image_server = val;
__isset.image_server = true;
}

void node_list_images_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_list_images_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_images_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size346;
            ::apache::thrift::protocol::TType _etype349;
            xfer += iprot->readListBegin(_etype349, _size346);
            this->peer_nodes_list.resize(_size346);
            uint32_t _i350;
            for (_i350 = 0; _i350 < _size346; ++_i350)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i350]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size351;
            ::apache::thrift::protocol::TType _etype354;
            xfer += iprot->readListBegin(_etype354, _size351);
            this->multisig_wallets.resize(_size351);
            uint32_t _i355;
            for (_i355 = 0; _i355 < _size351; ++_i355)
            {
              xfer += iprot->readString(this->multisig_wallets[_i355]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size356;
            ::apache::thrift::protocol::TType _etype359;
            xfer += iprot->readListBegin(_etype359, _size356);
            this->multisig_signs.resize(_size356);
            uint32_t _i360;
            for (_i360 = 0; _i360 < _size356; ++_i360)
            {
              xfer += this->multisig_signs[_i360].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_server);
          this->__isset.image_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_images_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_images_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter361;
    for (_iter361 = this->peer_nodes_list.begin(); _iter361 != this->peer_nodes_list.end(); ++_iter361)
    {
      xfer += oprot->writeString((*_iter361));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter362;
    for (_iter362 = this->multisig_wallets.begin(); _iter362 != this->multisig_wallets.end(); ++_iter362)
    {
      xfer += oprot->writeString((*_iter362));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter363;
    for (_iter363 = this->multisig_signs.begin(); _iter363 != this->multisig_signs.end(); ++_iter363)
    {
      xfer += (*_iter363).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.image_server) {
    xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->image_server);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_images_req_data &a, node_list_images_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.image_server, b.image_server);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_list_images_req_data::node_list_images_req_data(const node_list_images_req_data& other364) {
  peer_nodes_list = other364.peer_nodes_list;
  additional = other364.additional;
  wallet = other364.wallet;
  nonce = other364.nonce;
  sign = other364.sign;
  multisig_wallets = other364.multisig_wallets;
  multisig_threshold = other364.multisig_threshold;
  multisig_signs = other364.multisig_signs;
  session_id = other364.session_id;
  session_id_sign = other364.session_id_sign;
  image_server = other364.image_server;
  rent_order = other364.rent_order;
  __isset = other364.__isset;
}
node_list_images_req_data& node_list_images_req_data::operator=(const node_list_images_req_data& other365) {
  peer_nodes_list = other365.peer_nodes_list;
  additional = other365.additional;
  wallet = other365.wallet;
  nonce = other365.nonce;
  sign = other365.sign;
  multisig_wallets = other365.multisig_wallets;
  multisig_threshold = other365.multisig_threshold;
  multisig_signs = other365.multisig_signs;
  session_id = other365.session_id;
  session_id_sign = other365.session_id_sign;
  image_server = other365.image_server;
  rent_order = other365.rent_order;
  __isset = other365.__isset;
  return *this;
}
void node_list_images_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_images_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_list_images_req_body::~node_list_images_req_body() noexcept {
}


void node_list_images_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_images_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_images_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_images_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_images_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_images_req_body &a, node_list_images_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_images_req_body::node_list_images_req_body(const node_list_images_req_body& other366) {
  data = other366.data;
}
node_list_images_req_body& node_list_images_req_body::operator=(const node_list_images_req_body& other367) {
  data = other367.data;
  return *this;
}
void node_list_images_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_images_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_images_req::~node_list_images_req() noexcept {
}


void node_list_images_req::__set_body(const node_list_images_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_images_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_images_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_images_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_images_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_images_req &a, node_list_images_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_images_req::node_list_images_req(const node_list_images_req& other368) {
  body = other368.body;
  __isset = other368.__isset;
}
node_list_images_req& node_list_images_req::operator=(const node_list_images_req& other369) {
  body = other369.body;
  __isset = other369.__isset;
  return *this;
}
void node_list_images_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_images_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_images_rsp_body::~node_list_images_rsp_body() noexcept {
}


void node_list_images_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_images_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_images_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_images_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_images_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_images_rsp_body &a, node_list_images_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_images_rsp_body::node_list_images_rsp_body(const node_list_images_rsp_body& other370) {
  data = other370.data;
}
node_list_images_rsp_body& node_list_images_rsp_body::operator=(const node_list_images_rsp_body& other371) {
  data = other371.data;
  return *this;
}
void node_list_images_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_images_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_images_rsp::~node_list_images_rsp() noexcept {
}


void node_list_images_rsp::__set_body(const node_list_images_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_images_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_images_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_images_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_images_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_images_rsp &a, node_list_images_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_images_rsp::node_list_images_rsp(const node_list_images_rsp& other372) {
  body = other372.body;
  __isset = other372.__isset;
}
node_list_images_rsp& node_list_images_rsp::operator=(const node_list_images_rsp& other373) {
  body = other373.body;
  __isset = other373.__isset;
  return *this;
}
void node_list_images_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_images_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_download_image_req_data::~node_download_image_req_data() noexcept {
}


void node_download_image_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_download_image_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_download_image_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_download_image_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_download_image_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_download_image_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_download_image_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_download_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_download_image_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_download_image_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_download_image_req_data::__set_image_server(const std::string& val) {
  this->image_server = val;
__isset.image_server = true;
}

void node_download_image_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_download_image_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_download_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size374;
            ::apache::thrift::protocol::TType _etype377;
            xfer += iprot->readListBegin(_etype377, _size374);
            this->peer_nodes_list.resize(_size374);
            uint32_t _i378;
            for (_i378 = 0; _i378 < _size374; ++_i378)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i378]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size379;
            ::apache::thrift::protocol::TType _etype382;
            xfer += iprot->readListBegin(_etype382, _size379);
            this->multisig_wallets.resize(_size379);
            uint32_t _i383;
            for (_i383 = 0; _i383 < _size379; ++_i383)
            {
              xfer += iprot->readString(this->multisig_wallets[_i383]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size384;
            ::apache::thrift::protocol::TType _etype387;
            xfer += iprot->readListBegin(_etype387, _size384);
            this->multisig_signs.resize(_size384);
            uint32_t _i388;
            for (_i388 = 0; _i388 < _size384; ++_i388)
            {
              xfer += this->multisig_signs[_i388].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_server);
          this->__isset.image_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_download_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_download_image_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter389;
    for (_iter389 = this->peer_nodes_list.begin(); _iter389 != this->peer_nodes_list.end(); ++_iter389)
    {
      xfer += oprot->writeString((*_iter389));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter390;
    for (_iter390 = this->multisig_wallets.begin(); _iter390 != this->multisig_wallets.end(); ++_iter390)
    {
      xfer += oprot->writeString((*_iter390));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter391;
    for (_iter391 = this->multisig_signs.begin(); _iter391 != this->multisig_signs.end(); ++_iter391)
    {
      xfer += (*_iter391).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.image_server) {
    xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->image_server);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_download_image_req_data &a, node_download_image_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.image_server, b.image_server);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_download_image_req_data::node_download_image_req_data(const node_download_image_req_data& other392) {
  peer_nodes_list = other392.peer_nodes_list;
  additional = other392.additional;
  wallet = other392.wallet;
  nonce = other392.nonce;
  sign = other392.sign;
  multisig_wallets = other392.multisig_wallets;
  multisig_threshold = other392.multisig_threshold;
  multisig_signs = other392.multisig_signs;
  session_id = other392.session_id;
  session_id_sign = other392.session_id_sign;
  image_server = other392.image_server;
  rent_order = other392.rent_order;
  __isset = other392.__isset;
}
node_download_image_req_data& node_download_image_req_data::operator=(const node_download_image_req_data& other393) {
  peer_nodes_list = other393.peer_nodes_list;
  additional = other393.additional;
  wallet = other393.wallet;
  nonce = other393.nonce;
  sign = other393.sign;
  multisig_wallets = other393.multisig_wallets;
  multisig_threshold = other393.multisig_threshold;
  multisig_signs = other393.multisig_signs;
  session_id = other393.session_id;
  session_id_sign = other393.session_id_sign;
  image_server = other393.image_server;
  rent_order = other393.rent_order;
  __isset = other393.__isset;
  return *this;
}
void node_download_image_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_download_image_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_download_image_req_body::~node_download_image_req_body() noexcept {
}


void node_download_image_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_download_image_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_download_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_download_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_download_image_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_download_image_req_body &a, node_download_image_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_download_image_req_body::node_download_image_req_body(const node_download_image_req_body& other394) {
  data = other394.data;
}
node_download_image_req_body& node_download_image_req_body::operator=(const node_download_image_req_body& other395) {
  data = other395.data;
  return *this;
}
void node_download_image_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_download_image_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_download_image_req::~node_download_image_req() noexcept {
}


void node_download_image_req::__set_body(const node_download_image_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_download_image_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_download_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_download_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_download_image_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_download_image_req &a, node_download_image_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_download_image_req::node_download_image_req(const node_download_image_req& other396) {
  body = other396.body;
  __isset = other396.__isset;
}
node_download_image_req& node_download_image_req::operator=(const node_download_image_req& other397) {
  body = other397.body;
  __isset = other397.__isset;
  return *this;
}
void node_download_image_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_download_image_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_download_image_rsp_body::~node_download_image_rsp_body() noexcept {
}


void node_download_image_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_download_image_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_download_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_download_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_download_image_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_download_image_rsp_body &a, node_download_image_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_download_image_rsp_body::node_download_image_rsp_body(const node_download_image_rsp_body& other398) {
  data = other398.data;
}
node_download_image_rsp_body& node_download_image_rsp_body::operator=(const node_download_image_rsp_body& other399) {
  data = other399.data;
  return *this;
}
void node_download_image_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_download_image_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_download_image_rsp::~node_download_image_rsp() noexcept {
}


void node_download_image_rsp::__set_body(const node_download_image_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_download_image_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_download_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_download_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_download_image_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_download_image_rsp &a, node_download_image_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_download_image_rsp::node_download_image_rsp(const node_download_image_rsp& other400) {
  body = other400.body;
  __isset = other400.__isset;
}
node_download_image_rsp& node_download_image_rsp::operator=(const node_download_image_rsp& other401) {
  body = other401.body;
  __isset = other401.__isset;
  return *this;
}
void node_download_image_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_download_image_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_download_image_progress_req_data::~node_download_image_progress_req_data() noexcept {
}


void node_download_image_progress_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_download_image_progress_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_download_image_progress_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_download_image_progress_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_download_image_progress_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_download_image_progress_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_download_image_progress_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_download_image_progress_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_download_image_progress_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_download_image_progress_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_download_image_progress_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_download_image_progress_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_download_image_progress_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size402;
            ::apache::thrift::protocol::TType _etype405;
            xfer += iprot->readListBegin(_etype405, _size402);
            this->peer_nodes_list.resize(_size402);
            uint32_t _i406;
            for (_i406 = 0; _i406 < _size402; ++_i406)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i406]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size407;
            ::apache::thrift::protocol::TType _etype410;
            xfer += iprot->readListBegin(_etype410, _size407);
            this->multisig_wallets.resize(_size407);
            uint32_t _i411;
            for (_i411 = 0; _i411 < _size407; ++_i411)
            {
              xfer += iprot->readString(this->multisig_wallets[_i411]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size412;
            ::apache::thrift::protocol::TType _etype415;
            xfer += iprot->readListBegin(_etype415, _size412);
            this->multisig_signs.resize(_size412);
            uint32_t _i416;
            for (_i416 = 0; _i416 < _size412; ++_i416)
            {
              xfer += this->multisig_signs[_i416].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_download_image_progress_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_download_image_progress_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter417;
    for (_iter417 = this->peer_nodes_list.begin(); _iter417 != this->peer_nodes_list.end(); ++_iter417)
    {
      xfer += oprot->writeString((*_iter417));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter418;
    for (_iter418 = this->multisig_wallets.begin(); _iter418 != this->multisig_wallets.end(); ++_iter418)
    {
      xfer += oprot->writeString((*_iter418));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter419;
    for (_iter419 = this->multisig_signs.begin(); _iter419 != this->multisig_signs.end(); ++_iter419)
    {
      xfer += (*_iter419).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_download_image_progress_req_data &a, node_download_image_progress_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_download_image_progress_req_data::node_download_image_progress_req_data(const node_download_image_progress_req_data& other420) {
  peer_nodes_list = other420.peer_nodes_list;
  additional = other420.additional;
  wallet = other420.wallet;
  nonce = other420.nonce;
  sign = other420.sign;
  multisig_wallets = other420.multisig_wallets;
  multisig_threshold = other420.multisig_threshold;
  multisig_signs = other420.multisig_signs;
  session_id = other420.session_id;
  session_id_sign = other420.session_id_sign;
  rent_order = other420.rent_order;
  __isset = other420.__isset;
}
node_download_image_progress_req_data& node_download_image_progress_req_data::operator=(const node_download_image_progress_req_data& other421) {
  peer_nodes_list = other421.peer_nodes_list;
  additional = other421.additional;
  wallet = other421.wallet;
  nonce = other421.nonce;
  sign = other421.sign;
  multisig_wallets = other421.multisig_wallets;
  multisig_threshold = other421.multisig_threshold;
  multisig_signs = other421.multisig_signs;
  session_id = other421.session_id;
  session_id_sign = other421.session_id_sign;
  rent_order = other421.rent_order;
  __isset = other421.__isset;
  return *this;
}
void node_download_image_progress_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_download_image_progress_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_download_image_progress_req_body::~node_download_image_progress_req_body() noexcept {
}


void node_download_image_progress_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_download_image_progress_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_download_image_progress_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_download_image_progress_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_download_image_progress_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_download_image_progress_req_body &a, node_download_image_progress_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_download_image_progress_req_body::node_download_image_progress_req_body(const node_download_image_progress_req_body& other422) {
  data = other422.data;
}
node_download_image_progress_req_body& node_download_image_progress_req_body::operator=(const node_download_image_progress_req_body& other423) {
  data = other423.data;
  return *this;
}
void node_download_image_progress_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_download_image_progress_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_download_image_progress_req::~node_download_image_progress_req() noexcept {
}


void node_download_image_progress_req::__set_body(const node_download_image_progress_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_download_image_progress_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_download_image_progress_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_download_image_progress_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_download_image_progress_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_download_image_progress_req &a, node_download_image_progress_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_download_image_progress_req::node_download_image_progress_req(const node_download_image_progress_req& other424) {
  body = other424.body;
  __isset = other424.__isset;
}
node_download_image_progress_req& node_download_image_progress_req::operator=(const node_download_image_progress_req& other425) {
  body = other425.body;
  __isset = other425.__isset;
  return *this;
}
void node_download_image_progress_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_download_image_progress_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_download_image_progress_rsp_body::~node_download_image_progress_rsp_body() noexcept {
}


void node_download_image_progress_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_download_image_progress_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_download_image_progress_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_download_image_progress_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_download_image_progress_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_download_image_progress_rsp_body &a, node_download_image_progress_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_download_image_progress_rsp_body::node_download_image_progress_rsp_body(const node_download_image_progress_rsp_body& other426) {
  data = other426.data;
}
node_download_image_progress_rsp_body& node_download_image_progress_rsp_body::operator=(const node_download_image_progress_rsp_body& other427) {
  data = other427.data;
  return *this;
}
void node_download_image_progress_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_download_image_progress_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_download_image_progress_rsp::~node_download_image_progress_rsp() noexcept {
}


void node_download_image_progress_rsp::__set_body(const node_download_image_progress_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_download_image_progress_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_download_image_progress_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_download_image_progress_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_download_image_progress_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_download_image_progress_rsp &a, node_download_image_progress_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_download_image_progress_rsp::node_download_image_progress_rsp(const node_download_image_progress_rsp& other428) {
  body = other428.body;
  __isset = other428.__isset;
}
node_download_image_progress_rsp& node_download_image_progress_rsp::operator=(const node_download_image_progress_rsp& other429) {
  body = other429.body;
  __isset = other429.__isset;
  return *this;
}
void node_download_image_progress_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_download_image_progress_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_stop_download_image_req_data::~node_stop_download_image_req_data() noexcept {
}


void node_stop_download_image_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_stop_download_image_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_stop_download_image_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_stop_download_image_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_stop_download_image_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_stop_download_image_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_stop_download_image_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_stop_download_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_stop_download_image_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_stop_download_image_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_stop_download_image_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_stop_download_image_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_download_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size430;
            ::apache::thrift::protocol::TType _etype433;
            xfer += iprot->readListBegin(_etype433, _size430);
            this->peer_nodes_list.resize(_size430);
            uint32_t _i434;
            for (_i434 = 0; _i434 < _size430; ++_i434)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i434]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size435;
            ::apache::thrift::protocol::TType _etype438;
            xfer += iprot->readListBegin(_etype438, _size435);
            this->multisig_wallets.resize(_size435);
            uint32_t _i439;
            for (_i439 = 0; _i439 < _size435; ++_i439)
            {
              xfer += iprot->readString(this->multisig_wallets[_i439]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size440;
            ::apache::thrift::protocol::TType _etype443;
            xfer += iprot->readListBegin(_etype443, _size440);
            this->multisig_signs.resize(_size440);
            uint32_t _i444;
            for (_i444 = 0; _i444 < _size440; ++_i444)
            {
              xfer += this->multisig_signs[_i444].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_stop_download_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_download_image_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter445;
    for (_iter445 = this->peer_nodes_list.begin(); _iter445 != this->peer_nodes_list.end(); ++_iter445)
    {
      xfer += oprot->writeString((*_iter445));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter446;
    for (_iter446 = this->multisig_wallets.begin(); _iter446 != this->multisig_wallets.end(); ++_iter446)
    {
      xfer += oprot->writeString((*_iter446));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter447;
    for (_iter447 = this->multisig_signs.begin(); _iter447 != this->multisig_signs.end(); ++_iter447)
    {
      xfer += (*_iter447).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_download_image_req_data &a, node_stop_download_image_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_stop_download_image_req_data::node_stop_download_image_req_data(const node_stop_download_image_req_data& other448) {
  peer_nodes_list = other448.peer_nodes_list;
  additional = other448.additional;
  wallet = other448.wallet;
  nonce = other448.nonce;
  sign = other448.sign;
  multisig_wallets = other448.multisig_wallets;
  multisig_threshold = other448.multisig_threshold;
  multisig_signs = other448.multisig_signs;
  session_id = other448.session_id;
  session_id_sign = other448.session_id_sign;
  rent_order = other448.rent_order;
  __isset = other448.__isset;
}
node_stop_download_image_req_data& node_stop_download_image_req_data::operator=(const node_stop_download_image_req_data& other449) {
  peer_nodes_list = other449.peer_nodes_list;
  additional = other449.additional;
  wallet = other449.wallet;
  nonce = other449.nonce;
  sign = other449.sign;
  multisig_wallets = other449.multisig_wallets;
  multisig_threshold = other449.multisig_threshold;
  multisig_signs = other449.multisig_signs;
  session_id = other449.session_id;
  session_id_sign = other449.session_id_sign;
  rent_order = other449.rent_order;
  __isset = other449.__isset;
  return *this;
}
void node_stop_download_image_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_download_image_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_stop_download_image_req_body::~node_stop_download_image_req_body() noexcept {
}


void node_stop_download_image_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_download_image_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_download_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_stop_download_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_download_image_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_download_image_req_body &a, node_stop_download_image_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_stop_download_image_req_body::node_stop_download_image_req_body(const node_stop_download_image_req_body& other450) {
  data = other450.data;
}
node_stop_download_image_req_body& node_stop_download_image_req_body::operator=(const node_stop_download_image_req_body& other451) {
  data = other451.data;
  return *this;
}
void node_stop_download_image_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_download_image_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_stop_download_image_req::~node_stop_download_image_req() noexcept {
}


void node_stop_download_image_req::__set_body(const node_stop_download_image_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_download_image_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_download_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_stop_download_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_download_image_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_download_image_req &a, node_stop_download_image_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_stop_download_image_req::node_stop_download_image_req(const node_stop_download_image_req& other452) {
  body = other452.body;
  __isset = other452.__isset;
}
node_stop_download_image_req& node_stop_download_image_req::operator=(const node_stop_download_image_req& other453) {
  body = other453.body;
  __isset = other453.__isset;
  return *this;
}
void node_stop_download_image_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_download_image_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_stop_download_image_rsp_body::~node_stop_download_image_rsp_body() noexcept {
}


void node_stop_download_image_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_download_image_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_download_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_stop_download_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_download_image_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_download_image_rsp_body &a, node_stop_download_image_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_stop_download_image_rsp_body::node_stop_download_image_rsp_body(const node_stop_download_image_rsp_body& other454) {
  data = other454.data;
}
node_stop_download_image_rsp_body& node_stop_download_image_rsp_body::operator=(const node_stop_download_image_rsp_body& other455) {
  data = other455.data;
  return *this;
}
void node_stop_download_image_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_download_image_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_stop_download_image_rsp::~node_stop_download_image_rsp() noexcept {
}


void node_stop_download_image_rsp::__set_body(const node_stop_download_image_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_download_image_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_download_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_stop_download_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_download_image_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_download_image_rsp &a, node_stop_download_image_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_stop_download_image_rsp::node_stop_download_image_rsp(const node_stop_download_image_rsp& other456) {
  body = other456.body;
  __isset = other456.__isset;
}
node_stop_download_image_rsp& node_stop_download_image_rsp::operator=(const node_stop_download_image_rsp& other457) {
  body = other457.body;
  __isset = other457.__isset;
  return *this;
}
void node_stop_download_image_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_download_image_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_upload_image_req_data::~node_upload_image_req_data() noexcept {
}


void node_upload_image_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_upload_image_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_upload_image_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_upload_image_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_upload_image_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_upload_image_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_upload_image_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_upload_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_upload_image_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_upload_image_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_upload_image_req_data::__set_image_server(const std::string& val) {
  this->image_server = val;
__isset.image_server = true;
}

void node_upload_image_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_upload_image_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_upload_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size458;
            ::apache::thrift::protocol::TType _etype461;
            xfer += iprot->readListBegin(_etype461, _size458);
            this->peer_nodes_list.resize(_size458);
            uint32_t _i462;
            for (_i462 = 0; _i462 < _size458; ++_i462)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i462]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size463;
            ::apache::thrift::protocol::TType _etype466;
            xfer += iprot->readListBegin(_etype466, _size463);
            this->multisig_wallets.resize(_size463);
            uint32_t _i467;
            for (_i467 = 0; _i467 < _size463; ++_i467)
            {
              xfer += iprot->readString(this->multisig_wallets[_i467]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size468;
            ::apache::thrift::protocol::TType _etype471;
            xfer += iprot->readListBegin(_etype471, _size468);
            this->multisig_signs.resize(_size468);
            uint32_t _i472;
            for (_i472 = 0; _i472 < _size468; ++_i472)
            {
              xfer += this->multisig_signs[_i472].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_server);
          this->__isset.image_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_upload_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_upload_image_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter473;
    for (_iter473 = this->peer_nodes_list.begin(); _iter473 != this->peer_nodes_list.end(); ++_iter473)
    {
      xfer += oprot->writeString((*_iter473));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter474;
    for (_iter474 = this->multisig_wallets.begin(); _iter474 != this->multisig_wallets.end(); ++_iter474)
    {
      xfer += oprot->writeString((*_iter474));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter475;
    for (_iter475 = this->multisig_signs.begin(); _iter475 != this->multisig_signs.end(); ++_iter475)
    {
      xfer += (*_iter475).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.image_server) {
    xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->image_server);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_upload_image_req_data &a, node_upload_image_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.image_server, b.image_server);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_upload_image_req_data::node_upload_image_req_data(const node_upload_image_req_data& other476) {
  peer_nodes_list = other476.peer_nodes_list;
  additional = other476.additional;
  wallet = other476.wallet;
  nonce = other476.nonce;
  sign = other476.sign;
  multisig_wallets = other476.multisig_wallets;
  multisig_threshold = other476.multisig_threshold;
  multisig_signs = other476.multisig_signs;
  session_id = other476.session_id;
  session_id_sign = other476.session_id_sign;
  image_server = other476.image_server;
  rent_order = other476.rent_order;
  __isset = other476.__isset;
}
node_upload_image_req_data& node_upload_image_req_data::operator=(const node_upload_image_req_data& other477) {
  peer_nodes_list = other477.peer_nodes_list;
  additional = other477.additional;
  wallet = other477.wallet;
  nonce = other477.nonce;
  sign = other477.sign;
  multisig_wallets = other477.multisig_wallets;
  multisig_threshold = other477.multisig_threshold;
  multisig_signs = other477.multisig_signs;
  session_id = other477.session_id;
  session_id_sign = other477.session_id_sign;
  image_server = other477.image_server;
  rent_order = other477.rent_order;
  __isset = other477.__isset;
  return *this;
}
void node_upload_image_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_upload_image_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_upload_image_req_body::~node_upload_image_req_body() noexcept {
}


void node_upload_image_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_upload_image_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_upload_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_upload_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_upload_image_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_upload_image_req_body &a, node_upload_image_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_upload_image_req_body::node_upload_image_req_body(const node_upload_image_req_body& other478) {
  data = other478.data;
}
node_upload_image_req_body& node_upload_image_req_body::operator=(const node_upload_image_req_body& other479) {
  data = other479.data;
  return *this;
}
void node_upload_image_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_upload_image_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_upload_image_req::~node_upload_image_req() noexcept {
}


void node_upload_image_req::__set_body(const node_upload_image_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_upload_image_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_upload_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_upload_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_upload_image_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_upload_image_req &a, node_upload_image_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_upload_image_req::node_upload_image_req(const node_upload_image_req& other480) {
  body = other480.body;
  __isset = other480.__isset;
}
node_upload_image_req& node_upload_image_req::operator=(const node_upload_image_req& other481) {
  body = other481.body;
  __isset = other481.__isset;
  return *this;
}
void node_upload_image_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_upload_image_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_upload_image_rsp_body::~node_upload_image_rsp_body() noexcept {
}


void node_upload_image_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_upload_image_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_upload_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_upload_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_upload_image_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_upload_image_rsp_body &a, node_upload_image_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_upload_image_rsp_body::node_upload_image_rsp_body(const node_upload_image_rsp_body& other482) {
  data = other482.data;
}
node_upload_image_rsp_body& node_upload_image_rsp_body::operator=(const node_upload_image_rsp_body& other483) {
  data = other483.data;
  return *this;
}
void node_upload_image_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_upload_image_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_upload_image_rsp::~node_upload_image_rsp() noexcept {
}


void node_upload_image_rsp::__set_body(const node_upload_image_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_upload_image_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_upload_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_upload_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_upload_image_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_upload_image_rsp &a, node_upload_image_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_upload_image_rsp::node_upload_image_rsp(const node_upload_image_rsp& other484) {
  body = other484.body;
  __isset = other484.__isset;
}
node_upload_image_rsp& node_upload_image_rsp::operator=(const node_upload_image_rsp& other485) {
  body = other485.body;
  __isset = other485.__isset;
  return *this;
}
void node_upload_image_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_upload_image_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_upload_image_progress_req_data::~node_upload_image_progress_req_data() noexcept {
}


void node_upload_image_progress_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_upload_image_progress_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_upload_image_progress_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_upload_image_progress_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_upload_image_progress_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_upload_image_progress_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_upload_image_progress_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_upload_image_progress_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_upload_image_progress_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_upload_image_progress_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_upload_image_progress_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_upload_image_progress_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_upload_image_progress_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size486;
            ::apache::thrift::protocol::TType _etype489;
            xfer += iprot->readListBegin(_etype489, _size486);
            this->peer_nodes_list.resize(_size486);
            uint32_t _i490;
            for (_i490 = 0; _i490 < _size486; ++_i490)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i490]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size491;
            ::apache::thrift::protocol::TType _etype494;
            xfer += iprot->readListBegin(_etype494, _size491);
            this->multisig_wallets.resize(_size491);
            uint32_t _i495;
            for (_i495 = 0; _i495 < _size491; ++_i495)
            {
              xfer += iprot->readString(this->multisig_wallets[_i495]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size496;
            ::apache::thrift::protocol::TType _etype499;
            xfer += iprot->readListBegin(_etype499, _size496);
            this->multisig_signs.resize(_size496);
            uint32_t _i500;
            for (_i500 = 0; _i500 < _size496; ++_i500)
            {
              xfer += this->multisig_signs[_i500].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_upload_image_progress_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_upload_image_progress_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter501;
    for (_iter501 = this->peer_nodes_list.begin(); _iter501 != this->peer_nodes_list.end(); ++_iter501)
    {
      xfer += oprot->writeString((*_iter501));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter502;
    for (_iter502 = this->multisig_wallets.begin(); _iter502 != this->multisig_wallets.end(); ++_iter502)
    {
      xfer += oprot->writeString((*_iter502));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter503;
    for (_iter503 = this->multisig_signs.begin(); _iter503 != this->multisig_signs.end(); ++_iter503)
    {
      xfer += (*_iter503).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_upload_image_progress_req_data &a, node_upload_image_progress_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_upload_image_progress_req_data::node_upload_image_progress_req_data(const node_upload_image_progress_req_data& other504) {
  peer_nodes_list = other504.peer_nodes_list;
  additional = other504.additional;
  wallet = other504.wallet;
  nonce = other504.nonce;
  sign = other504.sign;
  multisig_wallets = other504.multisig_wallets;
  multisig_threshold = other504.multisig_threshold;
  multisig_signs = other504.multisig_signs;
  session_id = other504.session_id;
  session_id_sign = other504.session_id_sign;
  rent_order = other504.rent_order;
  __isset = other504.__isset;
}
node_upload_image_progress_req_data& node_upload_image_progress_req_data::operator=(const node_upload_image_progress_req_data& other505) {
  peer_nodes_list = other505.peer_nodes_list;
  additional = other505.additional;
  wallet = other505.wallet;
  nonce = other505.nonce;
  sign = other505.sign;
  multisig_wallets = other505.multisig_wallets;
  multisig_threshold = other505.multisig_threshold;
  multisig_signs = other505.multisig_signs;
  session_id = other505.session_id;
  session_id_sign = other505.session_id_sign;
  rent_order = other505.rent_order;
  __isset = other505.__isset;
  return *this;
}
void node_upload_image_progress_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_upload_image_progress_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_upload_image_progress_req_body::~node_upload_image_progress_req_body() noexcept {
}


void node_upload_image_progress_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_upload_image_progress_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_upload_image_progress_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_upload_image_progress_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_upload_image_progress_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_upload_image_progress_req_body &a, node_upload_image_progress_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_upload_image_progress_req_body::node_upload_image_progress_req_body(const node_upload_image_progress_req_body& other506) {
  data = other506.data;
}
node_upload_image_progress_req_body& node_upload_image_progress_req_body::operator=(const node_upload_image_progress_req_body& other507) {
  data = other507.data;
  return *this;
}
void node_upload_image_progress_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_upload_image_progress_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_upload_image_progress_req::~node_upload_image_progress_req() noexcept {
}


void node_upload_image_progress_req::__set_body(const node_upload_image_progress_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_upload_image_progress_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_upload_image_progress_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_upload_image_progress_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_upload_image_progress_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_upload_image_progress_req &a, node_upload_image_progress_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_upload_image_progress_req::node_upload_image_progress_req(const node_upload_image_progress_req& other508) {
  body = other508.body;
  __isset = other508.__isset;
}
node_upload_image_progress_req& node_upload_image_progress_req::operator=(const node_upload_image_progress_req& other509) {
  body = other509.body;
  __isset = other509.__isset;
  return *this;
}
void node_upload_image_progress_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_upload_image_progress_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_upload_image_progress_rsp_body::~node_upload_image_progress_rsp_body() noexcept {
}


void node_upload_image_progress_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_upload_image_progress_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_upload_image_progress_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_upload_image_progress_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_upload_image_progress_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_upload_image_progress_rsp_body &a, node_upload_image_progress_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_upload_image_progress_rsp_body::node_upload_image_progress_rsp_body(const node_upload_image_progress_rsp_body& other510) {
  data = other510.data;
}
node_upload_image_progress_rsp_body& node_upload_image_progress_rsp_body::operator=(const node_upload_image_progress_rsp_body& other511) {
  data = other511.data;
  return *this;
}
void node_upload_image_progress_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_upload_image_progress_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_upload_image_progress_rsp::~node_upload_image_progress_rsp() noexcept {
}


void node_upload_image_progress_rsp::__set_body(const node_upload_image_progress_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_upload_image_progress_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_upload_image_progress_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_upload_image_progress_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_upload_image_progress_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_upload_image_progress_rsp &a, node_upload_image_progress_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_upload_image_progress_rsp::node_upload_image_progress_rsp(const node_upload_image_progress_rsp& other512) {
  body = other512.body;
  __isset = other512.__isset;
}
node_upload_image_progress_rsp& node_upload_image_progress_rsp::operator=(const node_upload_image_progress_rsp& other513) {
  body = other513.body;
  __isset = other513.__isset;
  return *this;
}
void node_upload_image_progress_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_upload_image_progress_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_stop_upload_image_req_data::~node_stop_upload_image_req_data() noexcept {
}


void node_stop_upload_image_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_stop_upload_image_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_stop_upload_image_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_stop_upload_image_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_stop_upload_image_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_stop_upload_image_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_stop_upload_image_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_stop_upload_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_stop_upload_image_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_stop_upload_image_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_stop_upload_image_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_stop_upload_image_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_upload_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size514;
            ::apache::thrift::protocol::TType _etype517;
            xfer += iprot->readListBegin(_etype517, _size514);
            this->peer_nodes_list.resize(_size514);
            uint32_t _i518;
            for (_i518 = 0; _i518 < _size514; ++_i518)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i518]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size519;
            ::apache::thrift::protocol::TType _etype522;
            xfer += iprot->readListBegin(_etype522, _size519);
            this->multisig_wallets.resize(_size519);
            uint32_t _i523;
            for (_i523 = 0; _i523 < _size519; ++_i523)
            {
              xfer += iprot->readString(this->multisig_wallets[_i523]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size524;
            ::apache::thrift::protocol::TType _etype527;
            xfer += iprot->readListBegin(_etype527, _size524);
            this->multisig_signs.resize(_size524);
            uint32_t _i528;
            for (_i528 = 0; _i528 < _size524; ++_i528)
            {
              xfer += this->multisig_signs[_i528].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_stop_upload_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_upload_image_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter529;
    for (_iter529 = this->peer_nodes_list.begin(); _iter529 != this->peer_nodes_list.end(); ++_iter529)
    {
      xfer += oprot->writeString((*_iter529));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter530;
    for (_iter530 = this->multisig_wallets.begin(); _iter530 != this->multisig_wallets.end(); ++_iter530)
    {
      xfer += oprot->writeString((*_iter530));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter531;
    for (_iter531 = this->multisig_signs.begin(); _iter531 != this->multisig_signs.end(); ++_iter531)
    {
      xfer += (*_iter531).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_upload_image_req_data &a, node_stop_upload_image_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_stop_upload_image_req_data::node_stop_upload_image_req_data(const node_stop_upload_image_req_data& other532) {
  peer_nodes_list = other532.peer_nodes_list;
  additional = other532.additional;
  wallet = other532.wallet;
  nonce = other532.nonce;
  sign = other532.sign;
  multisig_wallets = other532.multisig_wallets;
  multisig_threshold = other532.multisig_threshold;
  multisig_signs = other532.multisig_signs;
  session_id = other532.session_id;
  session_id_sign = other532.session_id_sign;
  rent_order = other532.rent_order;
  __isset = other532.__isset;
}
node_stop_upload_image_req_data& node_stop_upload_image_req_data::operator=(const node_stop_upload_image_req_data& other533) {
  peer_nodes_list = other533.peer_nodes_list;
  additional = other533.additional;
  wallet = other533.wallet;
  nonce = other533.nonce;
  sign = other533.sign;
  multisig_wallets = other533.multisig_wallets;
  multisig_threshold = other533.multisig_threshold;
  multisig_signs = other533.multisig_signs;
  session_id = other533.session_id;
  session_id_sign = other533.session_id_sign;
  rent_order = other533.rent_order;
  __isset = other533.__isset;
  return *this;
}
void node_stop_upload_image_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_upload_image_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_stop_upload_image_req_body::~node_stop_upload_image_req_body() noexcept {
}


void node_stop_upload_image_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_upload_image_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_upload_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_stop_upload_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_upload_image_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_upload_image_req_body &a, node_stop_upload_image_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_stop_upload_image_req_body::node_stop_upload_image_req_body(const node_stop_upload_image_req_body& other534) {
  data = other534.data;
}
node_stop_upload_image_req_body& node_stop_upload_image_req_body::operator=(const node_stop_upload_image_req_body& other535) {
  data = other535.data;
  return *this;
}
void node_stop_upload_image_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_upload_image_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_stop_upload_image_req::~node_stop_upload_image_req() noexcept {
}


void node_stop_upload_image_req::__set_body(const node_stop_upload_image_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_upload_image_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_upload_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_stop_upload_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_upload_image_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_upload_image_req &a, node_stop_upload_image_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_stop_upload_image_req::node_stop_upload_image_req(const node_stop_upload_image_req& other536) {
  body = other536.body;
  __isset = other536.__isset;
}
node_stop_upload_image_req& node_stop_upload_image_req::operator=(const node_stop_upload_image_req& other537) {
  body = other537.body;
  __isset = other537.__isset;
  return *this;
}
void node_stop_upload_image_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_upload_image_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_stop_upload_image_rsp_body::~node_stop_upload_image_rsp_body() noexcept {
}


void node_stop_upload_image_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_upload_image_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_upload_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_stop_upload_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_upload_image_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_upload_image_rsp_body &a, node_stop_upload_image_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_stop_upload_image_rsp_body::node_stop_upload_image_rsp_body(const node_stop_upload_image_rsp_body& other538) {
  data = other538.data;
}
node_stop_upload_image_rsp_body& node_stop_upload_image_rsp_body::operator=(const node_stop_upload_image_rsp_body& other539) {
  data = other539.data;
  return *this;
}
void node_stop_upload_image_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_upload_image_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_stop_upload_image_rsp::~node_stop_upload_image_rsp() noexcept {
}


void node_stop_upload_image_rsp::__set_body(const node_stop_upload_image_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_stop_upload_image_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_stop_upload_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_stop_upload_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_stop_upload_image_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_stop_upload_image_rsp &a, node_stop_upload_image_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_stop_upload_image_rsp::node_stop_upload_image_rsp(const node_stop_upload_image_rsp& other540) {
  body = other540.body;
  __isset = other540.__isset;
}
node_stop_upload_image_rsp& node_stop_upload_image_rsp::operator=(const node_stop_upload_image_rsp& other541) {
  body = other541.body;
  __isset = other541.__isset;
  return *this;
}
void node_stop_upload_image_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_stop_upload_image_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_delete_image_req_data::~node_delete_image_req_data() noexcept {
}


void node_delete_image_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_delete_image_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_delete_image_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_delete_image_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_delete_image_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_delete_image_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_delete_image_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_delete_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_delete_image_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_delete_image_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_delete_image_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_delete_image_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size542;
            ::apache::thrift::protocol::TType _etype545;
            xfer += iprot->readListBegin(_etype545, _size542);
            this->peer_nodes_list.resize(_size542);
            uint32_t _i546;
            for (_i546 = 0; _i546 < _size542; ++_i546)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i546]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size547;
            ::apache::thrift::protocol::TType _etype550;
            xfer += iprot->readListBegin(_etype550, _size547);
            this->multisig_wallets.resize(_size547);
            uint32_t _i551;
            for (_i551 = 0; _i551 < _size547; ++_i551)
            {
              xfer += iprot->readString(this->multisig_wallets[_i551]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size552;
            ::apache::thrift::protocol::TType _etype555;
            xfer += iprot->readListBegin(_etype555, _size552);
            this->multisig_signs.resize(_size552);
            uint32_t _i556;
            for (_i556 = 0; _i556 < _size552; ++_i556)
            {
              xfer += this->multisig_signs[_i556].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_image_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter557;
    for (_iter557 = this->peer_nodes_list.begin(); _iter557 != this->peer_nodes_list.end(); ++_iter557)
    {
      xfer += oprot->writeString((*_iter557));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter558;
    for (_iter558 = this->multisig_wallets.begin(); _iter558 != this->multisig_wallets.end(); ++_iter558)
    {
      xfer += oprot->writeString((*_iter558));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter559;
    for (_iter559 = this->multisig_signs.begin(); _iter559 != this->multisig_signs.end(); ++_iter559)
    {
      xfer += (*_iter559).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_image_req_data &a, node_delete_image_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_delete_image_req_data::node_delete_image_req_data(const node_delete_image_req_data& other560) {
  peer_nodes_list = other560.peer_nodes_list;
  additional = other560.additional;
  wallet = other560.wallet;
  nonce = other560.nonce;
  sign = other560.sign;
  multisig_wallets = other560.multisig_wallets;
  multisig_threshold = other560.multisig_threshold;
  multisig_signs = other560.multisig_signs;
  session_id = other560.session_id;
  session_id_sign = other560.session_id_sign;
  rent_order = other560.rent_order;
  __isset = other560.__isset;
}
node_delete_image_req_data& node_delete_image_req_data::operator=(const node_delete_image_req_data& other561) {
  peer_nodes_list = other561.peer_nodes_list;
  additional = other561.additional;
  wallet = other561.wallet;
  nonce = other561.nonce;
  sign = other561.sign;
  multisig_wallets = other561.multisig_wallets;
  multisig_threshold = other561.multisig_threshold;
  multisig_signs = other561.multisig_signs;
  session_id = other561.session_id;
  session_id_sign = other561.session_id_sign;
  rent_order = other561.rent_order;
  __isset = other561.__isset;
  return *this;
}
void node_delete_image_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_image_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_delete_image_req_body::~node_delete_image_req_body() noexcept {
}


void node_delete_image_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_image_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_image_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_image_req_body &a, node_delete_image_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_delete_image_req_body::node_delete_image_req_body(const node_delete_image_req_body& other562) {
  data = other562.data;
}
node_delete_image_req_body& node_delete_image_req_body::operator=(const node_delete_image_req_body& other563) {
  data = other563.data;
  return *this;
}
void node_delete_image_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_image_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_delete_image_req::~node_delete_image_req() noexcept {
}


void node_delete_image_req::__set_body(const node_delete_image_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_image_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_delete_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_image_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_image_req &a, node_delete_image_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_delete_image_req::node_delete_image_req(const node_delete_image_req& other564) {
  body = other564.body;
  __isset = other564.__isset;
}
node_delete_image_req& node_delete_image_req::operator=(const node_delete_image_req& other565) {
  body = other565.body;
  __isset = other565.__isset;
  return *this;
}
void node_delete_image_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_image_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_delete_image_rsp_body::~node_delete_image_rsp_body() noexcept {
}


void node_delete_image_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_image_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_image_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_image_rsp_body &a, node_delete_image_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_delete_image_rsp_body::node_delete_image_rsp_body(const node_delete_image_rsp_body& other566) {
  data = other566.data;
}
node_delete_image_rsp_body& node_delete_image_rsp_body::operator=(const node_delete_image_rsp_body& other567) {
  data = other567.data;
  return *this;
}
void node_delete_image_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_image_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_delete_image_rsp::~node_delete_image_rsp() noexcept {
}


void node_delete_image_rsp::__set_body(const node_delete_image_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_image_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_delete_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_image_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_image_rsp &a, node_delete_image_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_delete_image_rsp::node_delete_image_rsp(const node_delete_image_rsp& other568) {
  body = other568.body;
  __isset = other568.__isset;
}
node_delete_image_rsp& node_delete_image_rsp::operator=(const node_delete_image_rsp& other569) {
  body = other569.body;
  __isset = other569.__isset;
  return *this;
}
void node_delete_image_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_image_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_snapshot_req_data::~node_list_snapshot_req_data() noexcept {
}


void node_list_snapshot_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_list_snapshot_req_data::__set_snapshot_name(const std::string& val) {
  this->snapshot_name = val;
}

void node_list_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_list_snapshot_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_list_snapshot_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_list_snapshot_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_list_snapshot_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_list_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_list_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_list_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_list_snapshot_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_list_snapshot_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_list_snapshot_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_snapshot_name = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_name);
          isset_snapshot_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size570;
            ::apache::thrift::protocol::TType _etype573;
            xfer += iprot->readListBegin(_etype573, _size570);
            this->peer_nodes_list.resize(_size570);
            uint32_t _i574;
            for (_i574 = 0; _i574 < _size570; ++_i574)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i574]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size575;
            ::apache::thrift::protocol::TType _etype578;
            xfer += iprot->readListBegin(_etype578, _size575);
            this->multisig_wallets.resize(_size575);
            uint32_t _i579;
            for (_i579 = 0; _i579 < _size575; ++_i579)
            {
              xfer += iprot->readString(this->multisig_wallets[_i579]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size580;
            ::apache::thrift::protocol::TType _etype583;
            xfer += iprot->readListBegin(_etype583, _size580);
            this->multisig_signs.resize(_size580);
            uint32_t _i584;
            for (_i584 = 0; _i584 < _size580; ++_i584)
            {
              xfer += this->multisig_signs[_i584].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_snapshot_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_snapshot_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->snapshot_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter585;
    for (_iter585 = this->peer_nodes_list.begin(); _iter585 != this->peer_nodes_list.end(); ++_iter585)
    {
      xfer += oprot->writeString((*_iter585));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter586;
    for (_iter586 = this->multisig_wallets.begin(); _iter586 != this->multisig_wallets.end(); ++_iter586)
    {
      xfer += oprot->writeString((*_iter586));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter587;
    for (_iter587 = this->multisig_signs.begin(); _iter587 != this->multisig_signs.end(); ++_iter587)
    {
      xfer += (*_iter587).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_snapshot_req_data &a, node_list_snapshot_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.snapshot_name, b.snapshot_name);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_list_snapshot_req_data::node_list_snapshot_req_data(const node_list_snapshot_req_data& other588) {
  task_id = other588.task_id;
  snapshot_name = other588.snapshot_name;
  peer_nodes_list = other588.peer_nodes_list;
  additional = other588.additional;
  wallet = other588.wallet;
  nonce = other588.nonce;
  sign = other588.sign;
  multisig_wallets = other588.multisig_wallets;
  multisig_threshold = other588.multisig_threshold;
  multisig_signs = other588.multisig_signs;
  session_id = other588.session_id;
  session_id_sign = other588.session_id_sign;
  rent_order = other588.rent_order;
  __isset = other588.__isset;
}
node_list_snapshot_req_data& node_list_snapshot_req_data::operator=(const node_list_snapshot_req_data& other589) {
  task_id = other589.task_id;
  snapshot_name = other589.snapshot_name;
  peer_nodes_list = other589.peer_nodes_list;
  additional = other589.additional;
  wallet = other589.wallet;
  nonce = other589.nonce;
  sign = other589.sign;
  multisig_wallets = other589.multisig_wallets;
  multisig_threshold = other589.multisig_threshold;
  multisig_signs = other589.multisig_signs;
  session_id = other589.session_id;
  session_id_sign = other589.session_id_sign;
  rent_order = other589.rent_order;
  __isset = other589.__isset;
  return *this;
}
void node_list_snapshot_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_snapshot_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "snapshot_name=" << to_string(snapshot_name);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_list_snapshot_req_body::~node_list_snapshot_req_body() noexcept {
}


void node_list_snapshot_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_snapshot_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_snapshot_req_body &a, node_list_snapshot_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_snapshot_req_body::node_list_snapshot_req_body(const node_list_snapshot_req_body& other590) {
  data = other590.data;
}
node_list_snapshot_req_body& node_list_snapshot_req_body::operator=(const node_list_snapshot_req_body& other591) {
  data = other591.data;
  return *this;
}
void node_list_snapshot_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_snapshot_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_snapshot_req::~node_list_snapshot_req() noexcept {
}


void node_list_snapshot_req::__set_body(const node_list_snapshot_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_snapshot_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_snapshot_req &a, node_list_snapshot_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_snapshot_req::node_list_snapshot_req(const node_list_snapshot_req& other592) {
  body = other592.body;
  __isset = other592.__isset;
}
node_list_snapshot_req& node_list_snapshot_req::operator=(const node_list_snapshot_req& other593) {
  body = other593.body;
  __isset = other593.__isset;
  return *this;
}
void node_list_snapshot_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_snapshot_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_snapshot_rsp_body::~node_list_snapshot_rsp_body() noexcept {
}


void node_list_snapshot_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_snapshot_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_snapshot_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_snapshot_rsp_body &a, node_list_snapshot_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_snapshot_rsp_body::node_list_snapshot_rsp_body(const node_list_snapshot_rsp_body& other594) {
  data = other594.data;
}
node_list_snapshot_rsp_body& node_list_snapshot_rsp_body::operator=(const node_list_snapshot_rsp_body& other595) {
  data = other595.data;
  return *this;
}
void node_list_snapshot_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_snapshot_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_snapshot_rsp::~node_list_snapshot_rsp() noexcept {
}


void node_list_snapshot_rsp::__set_body(const node_list_snapshot_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_snapshot_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_snapshot_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_snapshot_rsp &a, node_list_snapshot_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_snapshot_rsp::node_list_snapshot_rsp(const node_list_snapshot_rsp& other596) {
  body = other596.body;
  __isset = other596.__isset;
}
node_list_snapshot_rsp& node_list_snapshot_rsp::operator=(const node_list_snapshot_rsp& other597) {
  body = other597.body;
  __isset = other597.__isset;
  return *this;
}
void node_list_snapshot_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_snapshot_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_create_snapshot_req_data::~node_create_snapshot_req_data() noexcept {
}


void node_create_snapshot_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_create_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_create_snapshot_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_create_snapshot_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_create_snapshot_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_create_snapshot_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_create_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_create_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_create_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_create_snapshot_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_create_snapshot_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_create_snapshot_req_data::__set_image_server(const std::string& val) {
  this->image_server = val;
__isset.image_server = true;
}

void node_create_snapshot_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_create_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size598;
            ::apache::thrift::protocol::TType _etype601;
            xfer += iprot->readListBegin(_etype601, _size598);
            this->peer_nodes_list.resize(_size598);
            uint32_t _i602;
            for (_i602 = 0; _i602 < _size598; ++_i602)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i602]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size603;
            ::apache::thrift::protocol::TType _etype606;
            xfer += iprot->readListBegin(_etype606, _size603);
            this->multisig_wallets.resize(_size603);
            uint32_t _i607;
            for (_i607 = 0; _i607 < _size603; ++_i607)
            {
              xfer += iprot->readString(this->multisig_wallets[_i607]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size608;
            ::apache::thrift::protocol::TType _etype611;
            xfer += iprot->readListBegin(_etype611, _size608);
            this->multisig_signs.resize(_size608);
            uint32_t _i612;
            for (_i612 = 0; _i612 < _size608; ++_i612)
            {
              xfer += this->multisig_signs[_i612].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_server);
          this->__isset.image_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_create_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_create_snapshot_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter613;
    for (_iter613 = this->peer_nodes_list.begin(); _iter613 != this->peer_nodes_list.end(); ++_iter613)
    {
      xfer += oprot->writeString((*_iter613));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter614;
    for (_iter614 = this->multisig_wallets.begin(); _iter614 != this->multisig_wallets.end(); ++_iter614)
    {
      xfer += oprot->writeString((*_iter614));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter615;
    for (_iter615 = this->multisig_signs.begin(); _iter615 != this->multisig_signs.end(); ++_iter615)
    {
      xfer += (*_iter615).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.image_server) {
    xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->image_server);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_create_snapshot_req_data &a, node_create_snapshot_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.image_server, b.image_server);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_create_snapshot_req_data::node_create_snapshot_req_data(const node_create_snapshot_req_data& other616) {
  task_id = other616.task_id;
  peer_nodes_list = other616.peer_nodes_list;
  additional = other616.additional;
  wallet = other616.wallet;
  nonce = other616.nonce;
  sign = other616.sign;
  multisig_wallets = other616.multisig_wallets;
  multisig_threshold = other616.multisig_threshold;
  multisig_signs = other616.multisig_signs;
  session_id = other616.session_id;
  session_id_sign = other616.session_id_sign;
  image_server = other616.image_server;
  rent_order = other616.rent_order;
  __isset = other616.__isset;
}
node_create_snapshot_req_data& node_create_snapshot_req_data::operator=(const node_create_snapshot_req_data& other617) {
  task_id = other617.task_id;
  peer_nodes_list = other617.peer_nodes_list;
  additional = other617.additional;
  wallet = other617.wallet;
  nonce = other617.nonce;
  sign = other617.sign;
  multisig_wallets = other617.multisig_wallets;
  multisig_threshold = other617.multisig_threshold;
  multisig_signs = other617.multisig_signs;
  session_id = other617.session_id;
  session_id_sign = other617.session_id_sign;
  image_server = other617.image_server;
  rent_order = other617.rent_order;
  __isset = other617.__isset;
  return *this;
}
void node_create_snapshot_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_create_snapshot_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_create_snapshot_req_body::~node_create_snapshot_req_body() noexcept {
}


void node_create_snapshot_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_create_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_create_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_create_snapshot_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_create_snapshot_req_body &a, node_create_snapshot_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_create_snapshot_req_body::node_create_snapshot_req_body(const node_create_snapshot_req_body& other618) {
  data = other618.data;
}
node_create_snapshot_req_body& node_create_snapshot_req_body::operator=(const node_create_snapshot_req_body& other619) {
  data = other619.data;
  return *this;
}
void node_create_snapshot_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_create_snapshot_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_create_snapshot_req::~node_create_snapshot_req() noexcept {
}


void node_create_snapshot_req::__set_body(const node_create_snapshot_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_create_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_create_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_create_snapshot_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_create_snapshot_req &a, node_create_snapshot_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_create_snapshot_req::node_create_snapshot_req(const node_create_snapshot_req& other620) {
  body = other620.body;
  __isset = other620.__isset;
}
node_create_snapshot_req& node_create_snapshot_req::operator=(const node_create_snapshot_req& other621) {
  body = other621.body;
  __isset = other621.__isset;
  return *this;
}
void node_create_snapshot_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_create_snapshot_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_create_snapshot_rsp_body::~node_create_snapshot_rsp_body() noexcept {
}


void node_create_snapshot_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_create_snapshot_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_create_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_create_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_create_snapshot_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_create_snapshot_rsp_body &a, node_create_snapshot_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_create_snapshot_rsp_body::node_create_snapshot_rsp_body(const node_create_snapshot_rsp_body& other622) {
  data = other622.data;
}
node_create_snapshot_rsp_body& node_create_snapshot_rsp_body::operator=(const node_create_snapshot_rsp_body& other623) {
  data = other623.data;
  return *this;
}
void node_create_snapshot_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_create_snapshot_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_create_snapshot_rsp::~node_create_snapshot_rsp() noexcept {
}


void node_create_snapshot_rsp::__set_body(const node_create_snapshot_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_create_snapshot_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_create_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_create_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_create_snapshot_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_create_snapshot_rsp &a, node_create_snapshot_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_create_snapshot_rsp::node_create_snapshot_rsp(const node_create_snapshot_rsp& other624) {
  body = other624.body;
  __isset = other624.__isset;
}
node_create_snapshot_rsp& node_create_snapshot_rsp::operator=(const node_create_snapshot_rsp& other625) {
  body = other625.body;
  __isset = other625.__isset;
  return *this;
}
void node_create_snapshot_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_create_snapshot_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_delete_snapshot_req_data::~node_delete_snapshot_req_data() noexcept {
}


void node_delete_snapshot_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_delete_snapshot_req_data::__set_snapshot_name(const std::string& val) {
  this->snapshot_name = val;
}

void node_delete_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_delete_snapshot_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_delete_snapshot_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_delete_snapshot_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_delete_snapshot_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_delete_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_delete_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_delete_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_delete_snapshot_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_delete_snapshot_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_delete_snapshot_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_snapshot_name = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_name);
          isset_snapshot_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size626;
            ::apache::thrift::protocol::TType _etype629;
            xfer += iprot->readListBegin(_etype629, _size626);
            this->peer_nodes_list.resize(_size626);
            uint32_t _i630;
            for (_i630 = 0; _i630 < _size626; ++_i630)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i630]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size631;
            ::apache::thrift::protocol::TType _etype634;
            xfer += iprot->readListBegin(_etype634, _size631);
            this->multisig_wallets.resize(_size631);
            uint32_t _i635;
            for (_i635 = 0; _i635 < _size631; ++_i635)
            {
              xfer += iprot->readString(this->multisig_wallets[_i635]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size636;
            ::apache::thrift::protocol::TType _etype639;
            xfer += iprot->readListBegin(_etype639, _size636);
            this->multisig_signs.resize(_size636);
            uint32_t _i640;
            for (_i640 = 0; _i640 < _size636; ++_i640)
            {
              xfer += this->multisig_signs[_i640].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_snapshot_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_snapshot_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->snapshot_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter641;
    for (_iter641 = this->peer_nodes_list.begin(); _iter641 != this->peer_nodes_list.end(); ++_iter641)
    {
      xfer += oprot->writeString((*_iter641));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter642;
    for (_iter642 = this->multisig_wallets.begin(); _iter642 != this->multisig_wallets.end(); ++_iter642)
    {
      xfer += oprot->writeString((*_iter642));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter643;
    for (_iter643 = this->multisig_signs.begin(); _iter643 != this->multisig_signs.end(); ++_iter643)
    {
      xfer += (*_iter643).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_snapshot_req_data &a, node_delete_snapshot_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.snapshot_name, b.snapshot_name);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_delete_snapshot_req_data::node_delete_snapshot_req_data(const node_delete_snapshot_req_data& other644) {
  task_id = other644.task_id;
  snapshot_name = other644.snapshot_name;
  peer_nodes_list = other644.peer_nodes_list;
  additional = other644.additional;
  wallet = other644.wallet;
  nonce = other644.nonce;
  sign = other644.sign;
  multisig_wallets = other644.multisig_wallets;
  multisig_threshold = other644.multisig_threshold;
  multisig_signs = other644.multisig_signs;
  session_id = other644.session_id;
  session_id_sign = other644.session_id_sign;
  rent_order = other644.rent_order;
  __isset = other644.__isset;
}
node_delete_snapshot_req_data& node_delete_snapshot_req_data::operator=(const node_delete_snapshot_req_data& other645) {
  task_id = other645.task_id;
  snapshot_name = other645.snapshot_name;
  peer_nodes_list = other645.peer_nodes_list;
  additional = other645.additional;
  wallet = other645.wallet;
  nonce = other645.nonce;
  sign = other645.sign;
  multisig_wallets = other645.multisig_wallets;
  multisig_threshold = other645.multisig_threshold;
  multisig_signs = other645.multisig_signs;
  session_id = other645.session_id;
  session_id_sign = other645.session_id_sign;
  rent_order = other645.rent_order;
  __isset = other645.__isset;
  return *this;
}
void node_delete_snapshot_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_snapshot_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "snapshot_name=" << to_string(snapshot_name);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_delete_snapshot_req_body::~node_delete_snapshot_req_body() noexcept {
}


void node_delete_snapshot_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_snapshot_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_snapshot_req_body &a, node_delete_snapshot_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_delete_snapshot_req_body::node_delete_snapshot_req_body(const node_delete_snapshot_req_body& other646) {
  data = other646.data;
}
node_delete_snapshot_req_body& node_delete_snapshot_req_body::operator=(const node_delete_snapshot_req_body& other647) {
  data = other647.data;
  return *this;
}
void node_delete_snapshot_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_snapshot_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_delete_snapshot_req::~node_delete_snapshot_req() noexcept {
}


void node_delete_snapshot_req::__set_body(const node_delete_snapshot_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_delete_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_snapshot_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_snapshot_req &a, node_delete_snapshot_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_delete_snapshot_req::node_delete_snapshot_req(const node_delete_snapshot_req& other648) {
  body = other648.body;
  __isset = other648.__isset;
}
node_delete_snapshot_req& node_delete_snapshot_req::operator=(const node_delete_snapshot_req& other649) {
  body = other649.body;
  __isset = other649.__isset;
  return *this;
}
void node_delete_snapshot_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_snapshot_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_delete_snapshot_rsp_body::~node_delete_snapshot_rsp_body() noexcept {
}


void node_delete_snapshot_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_snapshot_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_snapshot_rsp_body &a, node_delete_snapshot_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_delete_snapshot_rsp_body::node_delete_snapshot_rsp_body(const node_delete_snapshot_rsp_body& other650) {
  data = other650.data;
}
node_delete_snapshot_rsp_body& node_delete_snapshot_rsp_body::operator=(const node_delete_snapshot_rsp_body& other651) {
  data = other651.data;
  return *this;
}
void node_delete_snapshot_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_snapshot_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_delete_snapshot_rsp::~node_delete_snapshot_rsp() noexcept {
}


void node_delete_snapshot_rsp::__set_body(const node_delete_snapshot_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_delete_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_snapshot_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_snapshot_rsp &a, node_delete_snapshot_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_delete_snapshot_rsp::node_delete_snapshot_rsp(const node_delete_snapshot_rsp& other652) {
  body = other652.body;
  __isset = other652.__isset;
}
node_delete_snapshot_rsp& node_delete_snapshot_rsp::operator=(const node_delete_snapshot_rsp& other653) {
  body = other653.body;
  __isset = other653.__isset;
  return *this;
}
void node_delete_snapshot_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_snapshot_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_disk_req_data::~node_list_disk_req_data() noexcept {
}


void node_list_disk_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_list_disk_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_list_disk_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_list_disk_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_list_disk_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_list_disk_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_list_disk_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_list_disk_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_list_disk_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_list_disk_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_list_disk_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_list_disk_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_list_disk_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_disk_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size654;
            ::apache::thrift::protocol::TType _etype657;
            xfer += iprot->readListBegin(_etype657, _size654);
            this->peer_nodes_list.resize(_size654);
            uint32_t _i658;
            for (_i658 = 0; _i658 < _size654; ++_i658)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i658]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size659;
            ::apache::thrift::protocol::TType _etype662;
            xfer += iprot->readListBegin(_etype662, _size659);
            this->multisig_wallets.resize(_size659);
            uint32_t _i663;
            for (_i663 = 0; _i663 < _size659; ++_i663)
            {
              xfer += iprot->readString(this->multisig_wallets[_i663]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size664;
            ::apache::thrift::protocol::TType _etype667;
            xfer += iprot->readListBegin(_etype667, _size664);
            this->multisig_signs.resize(_size664);
            uint32_t _i668;
            for (_i668 = 0; _i668 < _size664; ++_i668)
            {
              xfer += this->multisig_signs[_i668].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_disk_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_disk_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter669;
    for (_iter669 = this->peer_nodes_list.begin(); _iter669 != this->peer_nodes_list.end(); ++_iter669)
    {
      xfer += oprot->writeString((*_iter669));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter670;
    for (_iter670 = this->multisig_wallets.begin(); _iter670 != this->multisig_wallets.end(); ++_iter670)
    {
      xfer += oprot->writeString((*_iter670));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter671;
    for (_iter671 = this->multisig_signs.begin(); _iter671 != this->multisig_signs.end(); ++_iter671)
    {
      xfer += (*_iter671).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_disk_req_data &a, node_list_disk_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_list_disk_req_data::node_list_disk_req_data(const node_list_disk_req_data& other672) {
  task_id = other672.task_id;
  peer_nodes_list = other672.peer_nodes_list;
  additional = other672.additional;
  wallet = other672.wallet;
  nonce = other672.nonce;
  sign = other672.sign;
  multisig_wallets = other672.multisig_wallets;
  multisig_threshold = other672.multisig_threshold;
  multisig_signs = other672.multisig_signs;
  session_id = other672.session_id;
  session_id_sign = other672.session_id_sign;
  rent_order = other672.rent_order;
  __isset = other672.__isset;
}
node_list_disk_req_data& node_list_disk_req_data::operator=(const node_list_disk_req_data& other673) {
  task_id = other673.task_id;
  peer_nodes_list = other673.peer_nodes_list;
  additional = other673.additional;
  wallet = other673.wallet;
  nonce = other673.nonce;
  sign = other673.sign;
  multisig_wallets = other673.multisig_wallets;
  multisig_threshold = other673.multisig_threshold;
  multisig_signs = other673.multisig_signs;
  session_id = other673.session_id;
  session_id_sign = other673.session_id_sign;
  rent_order = other673.rent_order;
  __isset = other673.__isset;
  return *this;
}
void node_list_disk_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_disk_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_list_disk_req_body::~node_list_disk_req_body() noexcept {
}


void node_list_disk_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_disk_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_disk_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_disk_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_disk_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_disk_req_body &a, node_list_disk_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_disk_req_body::node_list_disk_req_body(const node_list_disk_req_body& other674) {
  data = other674.data;
}
node_list_disk_req_body& node_list_disk_req_body::operator=(const node_list_disk_req_body& other675) {
  data = other675.data;
  return *this;
}
void node_list_disk_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_disk_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_disk_req::~node_list_disk_req() noexcept {
}


void node_list_disk_req::__set_body(const node_list_disk_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_disk_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_disk_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_disk_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_disk_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_disk_req &a, node_list_disk_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_disk_req::node_list_disk_req(const node_list_disk_req& other676) {
  body = other676.body;
  __isset = other676.__isset;
}
node_list_disk_req& node_list_disk_req::operator=(const node_list_disk_req& other677) {
  body = other677.body;
  __isset = other677.__isset;
  return *this;
}
void node_list_disk_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_disk_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_disk_rsp_body::~node_list_disk_rsp_body() noexcept {
}


void node_list_disk_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_disk_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_disk_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_disk_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_disk_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_disk_rsp_body &a, node_list_disk_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_disk_rsp_body::node_list_disk_rsp_body(const node_list_disk_rsp_body& other678) {
  data = other678.data;
}
node_list_disk_rsp_body& node_list_disk_rsp_body::operator=(const node_list_disk_rsp_body& other679) {
  data = other679.data;
  return *this;
}
void node_list_disk_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_disk_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_disk_rsp::~node_list_disk_rsp() noexcept {
}


void node_list_disk_rsp::__set_body(const node_list_disk_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_disk_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_disk_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_disk_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_disk_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_disk_rsp &a, node_list_disk_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_disk_rsp::node_list_disk_rsp(const node_list_disk_rsp& other680) {
  body = other680.body;
  __isset = other680.__isset;
}
node_list_disk_rsp& node_list_disk_rsp::operator=(const node_list_disk_rsp& other681) {
  body = other681.body;
  __isset = other681.__isset;
  return *this;
}
void node_list_disk_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_disk_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_resize_disk_req_data::~node_resize_disk_req_data() noexcept {
}


void node_resize_disk_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_resize_disk_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_resize_disk_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_resize_disk_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_resize_disk_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_resize_disk_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_resize_disk_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_resize_disk_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_resize_disk_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_resize_disk_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_resize_disk_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_resize_disk_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_resize_disk_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_resize_disk_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size682;
            ::apache::thrift::protocol::TType _etype685;
            xfer += iprot->readListBegin(_etype685, _size682);
            this->peer_nodes_list.resize(_size682);
            uint32_t _i686;
            for (_i686 = 0; _i686 < _size682; ++_i686)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i686]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size687;
            ::apache::thrift::protocol::TType _etype690;
            xfer += iprot->readListBegin(_etype690, _size687);
            this->multisig_wallets.resize(_size687);
            uint32_t _i691;
            for (_i691 = 0; _i691 < _size687; ++_i691)
            {
              xfer += iprot->readString(this->multisig_wallets[_i691]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size692;
            ::apache::thrift::protocol::TType _etype695;
            xfer += iprot->readListBegin(_etype695, _size692);
            this->multisig_signs.resize(_size692);
            uint32_t _i696;
            for (_i696 = 0; _i696 < _size692; ++_i696)
            {
              xfer += this->multisig_signs[_i696].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_resize_disk_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_resize_disk_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter697;
    for (_iter697 = this->peer_nodes_list.begin(); _iter697 != this->peer_nodes_list.end(); ++_iter697)
    {
      xfer += oprot->writeString((*_iter697));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter698;
    for (_iter698 = this->multisig_wallets.begin(); _iter698 != this->multisig_wallets.end(); ++_iter698)
    {
      xfer += oprot->writeString((*_iter698));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter699;
    for (_iter699 = this->multisig_signs.begin(); _iter699 != this->multisig_signs.end(); ++_iter699)
    {
      xfer += (*_iter699).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_resize_disk_req_data &a, node_resize_disk_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_resize_disk_req_data::node_resize_disk_req_data(const node_resize_disk_req_data& other700) {
  task_id = other700.task_id;
  peer_nodes_list = other700.peer_nodes_list;
  additional = other700.additional;
  wallet = other700.wallet;
  nonce = other700.nonce;
  sign = other700.sign;
  multisig_wallets = other700.multisig_wallets;
  multisig_threshold = other700.multisig_threshold;
  multisig_signs = other700.multisig_signs;
  session_id = other700.session_id;
  session_id_sign = other700.session_id_sign;
  rent_order = other700.rent_order;
  __isset = other700.__isset;
}
node_resize_disk_req_data& node_resize_disk_req_data::operator=(const node_resize_disk_req_data& other701) {
  task_id = other701.task_id;
  peer_nodes_list = other701.peer_nodes_list;
  additional = other701.additional;
  wallet = other701.wallet;
  nonce = other701.nonce;
  sign = other701.sign;
  multisig_wallets = other701.multisig_wallets;
  multisig_threshold = other701.multisig_threshold;
  multisig_signs = other701.multisig_signs;
  session_id = other701.session_id;
  session_id_sign = other701.session_id_sign;
  rent_order = other701.rent_order;
  __isset = other701.__isset;
  return *this;
}
void node_resize_disk_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_resize_disk_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_resize_disk_req_body::~node_resize_disk_req_body() noexcept {
}


void node_resize_disk_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_resize_disk_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_resize_disk_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_resize_disk_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_resize_disk_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_resize_disk_req_body &a, node_resize_disk_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_resize_disk_req_body::node_resize_disk_req_body(const node_resize_disk_req_body& other702) {
  data = other702.data;
}
node_resize_disk_req_body& node_resize_disk_req_body::operator=(const node_resize_disk_req_body& other703) {
  data = other703.data;
  return *this;
}
void node_resize_disk_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_resize_disk_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_resize_disk_req::~node_resize_disk_req() noexcept {
}


void node_resize_disk_req::__set_body(const node_resize_disk_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_resize_disk_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_resize_disk_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_resize_disk_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_resize_disk_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_resize_disk_req &a, node_resize_disk_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_resize_disk_req::node_resize_disk_req(const node_resize_disk_req& other704) {
  body = other704.body;
  __isset = other704.__isset;
}
node_resize_disk_req& node_resize_disk_req::operator=(const node_resize_disk_req& other705) {
  body = other705.body;
  __isset = other705.__isset;
  return *this;
}
void node_resize_disk_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_resize_disk_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_resize_disk_rsp_body::~node_resize_disk_rsp_body() noexcept {
}


void node_resize_disk_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_resize_disk_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_resize_disk_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_resize_disk_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_resize_disk_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_resize_disk_rsp_body &a, node_resize_disk_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_resize_disk_rsp_body::node_resize_disk_rsp_body(const node_resize_disk_rsp_body& other706) {
  data = other706.data;
}
node_resize_disk_rsp_body& node_resize_disk_rsp_body::operator=(const node_resize_disk_rsp_body& other707) {
  data = other707.data;
  return *this;
}
void node_resize_disk_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_resize_disk_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_resize_disk_rsp::~node_resize_disk_rsp() noexcept {
}


void node_resize_disk_rsp::__set_body(const node_resize_disk_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_resize_disk_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_resize_disk_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_resize_disk_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_resize_disk_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_resize_disk_rsp &a, node_resize_disk_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_resize_disk_rsp::node_resize_disk_rsp(const node_resize_disk_rsp& other708) {
  body = other708.body;
  __isset = other708.__isset;
}
node_resize_disk_rsp& node_resize_disk_rsp::operator=(const node_resize_disk_rsp& other709) {
  body = other709.body;
  __isset = other709.__isset;
  return *this;
}
void node_resize_disk_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_resize_disk_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_add_disk_req_data::~node_add_disk_req_data() noexcept {
}


void node_add_disk_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_add_disk_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_add_disk_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_add_disk_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_add_disk_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_add_disk_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_add_disk_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_add_disk_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_add_disk_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_add_disk_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_add_disk_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_add_disk_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_add_disk_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_add_disk_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size710;
            ::apache::thrift::protocol::TType _etype713;
            xfer += iprot->readListBegin(_etype713, _size710);
            this->peer_nodes_list.resize(_size710);
            uint32_t _i714;
            for (_i714 = 0; _i714 < _size710; ++_i714)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i714]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size715;
            ::apache::thrift::protocol::TType _etype718;
            xfer += iprot->readListBegin(_etype718, _size715);
            this->multisig_wallets.resize(_size715);
            uint32_t _i719;
            for (_i719 = 0; _i719 < _size715; ++_i719)
            {
              xfer += iprot->readString(this->multisig_wallets[_i719]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size720;
            ::apache::thrift::protocol::TType _etype723;
            xfer += iprot->readListBegin(_etype723, _size720);
            this->multisig_signs.resize(_size720);
            uint32_t _i724;
            for (_i724 = 0; _i724 < _size720; ++_i724)
            {
              xfer += this->multisig_signs[_i724].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_add_disk_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_add_disk_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter725;
    for (_iter725 = this->peer_nodes_list.begin(); _iter725 != this->peer_nodes_list.end(); ++_iter725)
    {
      xfer += oprot->writeString((*_iter725));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter726;
    for (_iter726 = this->multisig_wallets.begin(); _iter726 != this->multisig_wallets.end(); ++_iter726)
    {
      xfer += oprot->writeString((*_iter726));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter727;
    for (_iter727 = this->multisig_signs.begin(); _iter727 != this->multisig_signs.end(); ++_iter727)
    {
      xfer += (*_iter727).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_add_disk_req_data &a, node_add_disk_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_add_disk_req_data::node_add_disk_req_data(const node_add_disk_req_data& other728) {
  task_id = other728.task_id;
  peer_nodes_list = other728.peer_nodes_list;
  additional = other728.additional;
  wallet = other728.wallet;
  nonce = other728.nonce;
  sign = other728.sign;
  multisig_wallets = other728.multisig_wallets;
  multisig_threshold = other728.multisig_threshold;
  multisig_signs = other728.multisig_signs;
  session_id = other728.session_id;
  session_id_sign = other728.session_id_sign;
  rent_order = other728.rent_order;
  __isset = other728.__isset;
}
node_add_disk_req_data& node_add_disk_req_data::operator=(const node_add_disk_req_data& other729) {
  task_id = other729.task_id;
  peer_nodes_list = other729.peer_nodes_list;
  additional = other729.additional;
  wallet = other729.wallet;
  nonce = other729.nonce;
  sign = other729.sign;
  multisig_wallets = other729.multisig_wallets;
  multisig_threshold = other729.multisig_threshold;
  multisig_signs = other729.multisig_signs;
  session_id = other729.session_id;
  session_id_sign = other729.session_id_sign;
  rent_order = other729.rent_order;
  __isset = other729.__isset;
  return *this;
}
void node_add_disk_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_add_disk_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_add_disk_req_body::~node_add_disk_req_body() noexcept {
}


void node_add_disk_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_add_disk_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_add_disk_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_add_disk_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_add_disk_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_add_disk_req_body &a, node_add_disk_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_add_disk_req_body::node_add_disk_req_body(const node_add_disk_req_body& other730) {
  data = other730.data;
}
node_add_disk_req_body& node_add_disk_req_body::operator=(const node_add_disk_req_body& other731) {
  data = other731.data;
  return *this;
}
void node_add_disk_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_add_disk_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_add_disk_req::~node_add_disk_req() noexcept {
}


void node_add_disk_req::__set_body(const node_add_disk_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_add_disk_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_add_disk_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_add_disk_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_add_disk_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_add_disk_req &a, node_add_disk_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_add_disk_req::node_add_disk_req(const node_add_disk_req& other732) {
  body = other732.body;
  __isset = other732.__isset;
}
node_add_disk_req& node_add_disk_req::operator=(const node_add_disk_req& other733) {
  body = other733.body;
  __isset = other733.__isset;
  return *this;
}
void node_add_disk_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_add_disk_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_add_disk_rsp_body::~node_add_disk_rsp_body() noexcept {
}


void node_add_disk_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_add_disk_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_add_disk_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_add_disk_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_add_disk_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_add_disk_rsp_body &a, node_add_disk_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_add_disk_rsp_body::node_add_disk_rsp_body(const node_add_disk_rsp_body& other734) {
  data = other734.data;
}
node_add_disk_rsp_body& node_add_disk_rsp_body::operator=(const node_add_disk_rsp_body& other735) {
  data = other735.data;
  return *this;
}
void node_add_disk_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_add_disk_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_add_disk_rsp::~node_add_disk_rsp() noexcept {
}


void node_add_disk_rsp::__set_body(const node_add_disk_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_add_disk_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_add_disk_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_add_disk_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_add_disk_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_add_disk_rsp &a, node_add_disk_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_add_disk_rsp::node_add_disk_rsp(const node_add_disk_rsp& other736) {
  body = other736.body;
  __isset = other736.__isset;
}
node_add_disk_rsp& node_add_disk_rsp::operator=(const node_add_disk_rsp& other737) {
  body = other737.body;
  __isset = other737.__isset;
  return *this;
}
void node_add_disk_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_add_disk_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_delete_disk_req_data::~node_delete_disk_req_data() noexcept {
}


void node_delete_disk_req_data::__set_task_id(const std::string& val) {
  this->task_id = val;
}

void node_delete_disk_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_delete_disk_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_delete_disk_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_delete_disk_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_delete_disk_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_delete_disk_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_delete_disk_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_delete_disk_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_delete_disk_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_delete_disk_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_delete_disk_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_delete_disk_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_disk_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_task_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->task_id);
          isset_task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size738;
            ::apache::thrift::protocol::TType _etype741;
            xfer += iprot->readListBegin(_etype741, _size738);
            this->peer_nodes_list.resize(_size738);
            uint32_t _i742;
            for (_i742 = 0; _i742 < _size738; ++_i742)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i742]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size743;
            ::apache::thrift::protocol::TType _etype746;
            xfer += iprot->readListBegin(_etype746, _size743);
            this->multisig_wallets.resize(_size743);
            uint32_t _i747;
            for (_i747 = 0; _i747 < _size743; ++_i747)
            {
              xfer += iprot->readString(this->multisig_wallets[_i747]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size748;
            ::apache::thrift::protocol::TType _etype751;
            xfer += iprot->readListBegin(_etype751, _size748);
            this->multisig_signs.resize(_size748);
            uint32_t _i752;
            for (_i752 = 0; _i752 < _size748; ++_i752)
            {
              xfer += this->multisig_signs[_i752].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_task_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_disk_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_disk_req_data");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter753;
    for (_iter753 = this->peer_nodes_list.begin(); _iter753 != this->peer_nodes_list.end(); ++_iter753)
    {
      xfer += oprot->writeString((*_iter753));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter754;
    for (_iter754 = this->multisig_wallets.begin(); _iter754 != this->multisig_wallets.end(); ++_iter754)
    {
      xfer += oprot->writeString((*_iter754));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter755;
    for (_iter755 = this->multisig_signs.begin(); _iter755 != this->multisig_signs.end(); ++_iter755)
    {
      xfer += (*_iter755).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_disk_req_data &a, node_delete_disk_req_data &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_delete_disk_req_data::node_delete_disk_req_data(const node_delete_disk_req_data& other756) {
  task_id = other756.task_id;
  peer_nodes_list = other756.peer_nodes_list;
  additional = other756.additional;
  wallet = other756.wallet;
  nonce = other756.nonce;
  sign = other756.sign;
  multisig_wallets = other756.multisig_wallets;
  multisig_threshold = other756.multisig_threshold;
  multisig_signs = other756.multisig_signs;
  session_id = other756.session_id;
  session_id_sign = other756.session_id_sign;
  rent_order = other756.rent_order;
  __isset = other756.__isset;
}
node_delete_disk_req_data& node_delete_disk_req_data::operator=(const node_delete_disk_req_data& other757) {
  task_id = other757.task_id;
  peer_nodes_list = other757.peer_nodes_list;
  additional = other757.additional;
  wallet = other757.wallet;
  nonce = other757.nonce;
  sign = other757.sign;
  multisig_wallets = other757.multisig_wallets;
  multisig_threshold = other757.multisig_threshold;
  multisig_signs = other757.multisig_signs;
  session_id = other757.session_id;
  session_id_sign = other757.session_id_sign;
  rent_order = other757.rent_order;
  __isset = other757.__isset;
  return *this;
}
void node_delete_disk_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_disk_req_data(";
  out << "task_id=" << to_string(task_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_delete_disk_req_body::~node_delete_disk_req_body() noexcept {
}


void node_delete_disk_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_disk_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_disk_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_disk_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_disk_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_disk_req_body &a, node_delete_disk_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_delete_disk_req_body::node_delete_disk_req_body(const node_delete_disk_req_body& other758) {
  data = other758.data;
}
node_delete_disk_req_body& node_delete_disk_req_body::operator=(const node_delete_disk_req_body& other759) {
  data = other759.data;
  return *this;
}
void node_delete_disk_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_disk_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_delete_disk_req::~node_delete_disk_req() noexcept {
}


void node_delete_disk_req::__set_body(const node_delete_disk_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_disk_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_disk_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_delete_disk_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_disk_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_disk_req &a, node_delete_disk_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_delete_disk_req::node_delete_disk_req(const node_delete_disk_req& other760) {
  body = other760.body;
  __isset = other760.__isset;
}
node_delete_disk_req& node_delete_disk_req::operator=(const node_delete_disk_req& other761) {
  body = other761.body;
  __isset = other761.__isset;
  return *this;
}
void node_delete_disk_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_disk_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_delete_disk_rsp_body::~node_delete_disk_rsp_body() noexcept {
}


void node_delete_disk_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_disk_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_disk_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_disk_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_disk_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_disk_rsp_body &a, node_delete_disk_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_delete_disk_rsp_body::node_delete_disk_rsp_body(const node_delete_disk_rsp_body& other762) {
  data = other762.data;
}
node_delete_disk_rsp_body& node_delete_disk_rsp_body::operator=(const node_delete_disk_rsp_body& other763) {
  data = other763.data;
  return *this;
}
void node_delete_disk_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_disk_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_delete_disk_rsp::~node_delete_disk_rsp() noexcept {
}


void node_delete_disk_rsp::__set_body(const node_delete_disk_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_disk_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_disk_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_delete_disk_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_disk_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_disk_rsp &a, node_delete_disk_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_delete_disk_rsp::node_delete_disk_rsp(const node_delete_disk_rsp& other764) {
  body = other764.body;
  __isset = other764.__isset;
}
node_delete_disk_rsp& node_delete_disk_rsp::operator=(const node_delete_disk_rsp& other765) {
  body = other765.body;
  __isset = other765.__isset;
  return *this;
}
void node_delete_disk_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_disk_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_session_id_req_data::~node_session_id_req_data() noexcept {
}


void node_session_id_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_session_id_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_session_id_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_session_id_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_session_id_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_session_id_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_session_id_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_session_id_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_session_id_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_session_id_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_session_id_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size766;
            ::apache::thrift::protocol::TType _etype769;
            xfer += iprot->readListBegin(_etype769, _size766);
            this->peer_nodes_list.resize(_size766);
            uint32_t _i770;
            for (_i770 = 0; _i770 < _size766; ++_i770)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i770]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size771;
            ::apache::thrift::protocol::TType _etype774;
            xfer += iprot->readListBegin(_etype774, _size771);
            this->multisig_wallets.resize(_size771);
            uint32_t _i775;
            for (_i775 = 0; _i775 < _size771; ++_i775)
            {
              xfer += iprot->readString(this->multisig_wallets[_i775]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size776;
            ::apache::thrift::protocol::TType _etype779;
            xfer += iprot->readListBegin(_etype779, _size776);
            this->multisig_signs.resize(_size776);
            uint32_t _i780;
            for (_i780 = 0; _i780 < _size776; ++_i780)
            {
              xfer += this->multisig_signs[_i780].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_session_id_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_session_id_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter781;
    for (_iter781 = this->peer_nodes_list.begin(); _iter781 != this->peer_nodes_list.end(); ++_iter781)
    {
      xfer += oprot->writeString((*_iter781));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter782;
    for (_iter782 = this->multisig_wallets.begin(); _iter782 != this->multisig_wallets.end(); ++_iter782)
    {
      xfer += oprot->writeString((*_iter782));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter783;
    for (_iter783 = this->multisig_signs.begin(); _iter783 != this->multisig_signs.end(); ++_iter783)
    {
      xfer += (*_iter783).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_session_id_req_data &a, node_session_id_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_session_id_req_data::node_session_id_req_data(const node_session_id_req_data& other784) {
  peer_nodes_list = other784.peer_nodes_list;
  additional = other784.additional;
  wallet = other784.wallet;
  nonce = other784.nonce;
  sign = other784.sign;
  multisig_wallets = other784.multisig_wallets;
  multisig_threshold = other784.multisig_threshold;
  multisig_signs = other784.multisig_signs;
  rent_order = other784.rent_order;
  __isset = other784.__isset;
}
node_session_id_req_data& node_session_id_req_data::operator=(const node_session_id_req_data& other785) {
  peer_nodes_list = other785.peer_nodes_list;
  additional = other785.additional;
  wallet = other785.wallet;
  nonce = other785.nonce;
  sign = other785.sign;
  multisig_wallets = other785.multisig_wallets;
  multisig_threshold = other785.multisig_threshold;
  multisig_signs = other785.multisig_signs;
  rent_order = other785.rent_order;
  __isset = other785.__isset;
  return *this;
}
void node_session_id_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_session_id_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_session_id_req_body::~node_session_id_req_body() noexcept {
}


void node_session_id_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_session_id_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_session_id_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_session_id_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_session_id_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_session_id_req_body &a, node_session_id_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_session_id_req_body::node_session_id_req_body(const node_session_id_req_body& other786) {
  data = other786.data;
}
node_session_id_req_body& node_session_id_req_body::operator=(const node_session_id_req_body& other787) {
  data = other787.data;
  return *this;
}
void node_session_id_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_session_id_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_session_id_req::~node_session_id_req() noexcept {
}


void node_session_id_req::__set_body(const node_session_id_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_session_id_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_session_id_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_session_id_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_session_id_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_session_id_req &a, node_session_id_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_session_id_req::node_session_id_req(const node_session_id_req& other788) {
  body = other788.body;
  __isset = other788.__isset;
}
node_session_id_req& node_session_id_req::operator=(const node_session_id_req& other789) {
  body = other789.body;
  __isset = other789.__isset;
  return *this;
}
void node_session_id_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_session_id_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_session_id_rsp_body::~node_session_id_rsp_body() noexcept {
}


void node_session_id_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_session_id_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_session_id_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_session_id_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_session_id_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_session_id_rsp_body &a, node_session_id_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_session_id_rsp_body::node_session_id_rsp_body(const node_session_id_rsp_body& other790) {
  data = other790.data;
}
node_session_id_rsp_body& node_session_id_rsp_body::operator=(const node_session_id_rsp_body& other791) {
  data = other791.data;
  return *this;
}
void node_session_id_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_session_id_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_session_id_rsp::~node_session_id_rsp() noexcept {
}


void node_session_id_rsp::__set_body(const node_session_id_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_session_id_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_session_id_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_session_id_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_session_id_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_session_id_rsp &a, node_session_id_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_session_id_rsp::node_session_id_rsp(const node_session_id_rsp& other792) {
  body = other792.body;
  __isset = other792.__isset;
}
node_session_id_rsp& node_session_id_rsp::operator=(const node_session_id_rsp& other793) {
  body = other793.body;
  __isset = other793.__isset;
  return *this;
}
void node_session_id_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_session_id_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_query_node_info_req_data::~node_query_node_info_req_data() noexcept {
}


void node_query_node_info_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_query_node_info_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_query_node_info_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_query_node_info_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_query_node_info_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_query_node_info_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_query_node_info_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_query_node_info_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_query_node_info_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_query_node_info_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_query_node_info_req_data::__set_image_server(const std::string& val) {
  this->image_server = val;
__isset.image_server = true;
}

void node_query_node_info_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_query_node_info_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_query_node_info_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size794;
            ::apache::thrift::protocol::TType _etype797;
            xfer += iprot->readListBegin(_etype797, _size794);
            this->peer_nodes_list.resize(_size794);
            uint32_t _i798;
            for (_i798 = 0; _i798 < _size794; ++_i798)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i798]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size799;
            ::apache::thrift::protocol::TType _etype802;
            xfer += iprot->readListBegin(_etype802, _size799);
            this->multisig_wallets.resize(_size799);
            uint32_t _i803;
            for (_i803 = 0; _i803 < _size799; ++_i803)
            {
              xfer += iprot->readString(this->multisig_wallets[_i803]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size804;
            ::apache::thrift::protocol::TType _etype807;
            xfer += iprot->readListBegin(_etype807, _size804);
            this->multisig_signs.resize(_size804);
            uint32_t _i808;
            for (_i808 = 0; _i808 < _size804; ++_i808)
            {
              xfer += this->multisig_signs[_i808].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_server);
          this->__isset.image_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_query_node_info_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_query_node_info_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter809;
    for (_iter809 = this->peer_nodes_list.begin(); _iter809 != this->peer_nodes_list.end(); ++_iter809)
    {
      xfer += oprot->writeString((*_iter809));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter810;
    for (_iter810 = this->multisig_wallets.begin(); _iter810 != this->multisig_wallets.end(); ++_iter810)
    {
      xfer += oprot->writeString((*_iter810));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter811;
    for (_iter811 = this->multisig_signs.begin(); _iter811 != this->multisig_signs.end(); ++_iter811)
    {
      xfer += (*_iter811).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.image_server) {
    xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->image_server);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_query_node_info_req_data &a, node_query_node_info_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.image_server, b.image_server);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_query_node_info_req_data::node_query_node_info_req_data(const node_query_node_info_req_data& other812) {
  peer_nodes_list = other812.peer_nodes_list;
  additional = other812.additional;
  wallet = other812.wallet;
  nonce = other812.nonce;
  sign = other812.sign;
  multisig_wallets = other812.multisig_wallets;
  multisig_threshold = other812.multisig_threshold;
  multisig_signs = other812.multisig_signs;
  session_id = other812.session_id;
  session_id_sign = other812.session_id_sign;
  image_server = other812.image_server;
  rent_order = other812.rent_order;
  __isset = other812.__isset;
}
node_query_node_info_req_data& node_query_node_info_req_data::operator=(const node_query_node_info_req_data& other813) {
  peer_nodes_list = other813.peer_nodes_list;
  additional = other813.additional;
  wallet = other813.wallet;
  nonce = other813.nonce;
  sign = other813.sign;
  multisig_wallets = other813.multisig_wallets;
  multisig_threshold = other813.multisig_threshold;
  multisig_signs = other813.multisig_signs;
  session_id = other813.session_id;
  session_id_sign = other813.session_id_sign;
  image_server = other813.image_server;
  rent_order = other813.rent_order;
  __isset = other813.__isset;
  return *this;
}
void node_query_node_info_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_query_node_info_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_query_node_info_req_body::~node_query_node_info_req_body() noexcept {
}


void node_query_node_info_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_query_node_info_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_query_node_info_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_query_node_info_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_query_node_info_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_query_node_info_req_body &a, node_query_node_info_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_query_node_info_req_body::node_query_node_info_req_body(const node_query_node_info_req_body& other814) {
  data = other814.data;
}
node_query_node_info_req_body& node_query_node_info_req_body::operator=(const node_query_node_info_req_body& other815) {
  data = other815.data;
  return *this;
}
void node_query_node_info_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_query_node_info_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_query_node_info_req::~node_query_node_info_req() noexcept {
}


void node_query_node_info_req::__set_body(const node_query_node_info_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_query_node_info_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_query_node_info_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_query_node_info_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_query_node_info_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_query_node_info_req &a, node_query_node_info_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_query_node_info_req::node_query_node_info_req(const node_query_node_info_req& other816) {
  body = other816.body;
  __isset = other816.__isset;
}
node_query_node_info_req& node_query_node_info_req::operator=(const node_query_node_info_req& other817) {
  body = other817.body;
  __isset = other817.__isset;
  return *this;
}
void node_query_node_info_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_query_node_info_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_query_node_info_rsp_body::~node_query_node_info_rsp_body() noexcept {
}


void node_query_node_info_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_query_node_info_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_query_node_info_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_query_node_info_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_query_node_info_rsp_body &a, node_query_node_info_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_query_node_info_rsp_body::node_query_node_info_rsp_body(const node_query_node_info_rsp_body& other818) {
  data = other818.data;
}
node_query_node_info_rsp_body& node_query_node_info_rsp_body::operator=(const node_query_node_info_rsp_body& other819) {
  data = other819.data;
  return *this;
}
void node_query_node_info_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_query_node_info_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_query_node_info_rsp::~node_query_node_info_rsp() noexcept {
}


void node_query_node_info_rsp::__set_body(const node_query_node_info_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_query_node_info_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_query_node_info_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_query_node_info_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_query_node_info_rsp &a, node_query_node_info_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_query_node_info_rsp::node_query_node_info_rsp(const node_query_node_info_rsp& other820) {
  body = other820.body;
  __isset = other820.__isset;
}
node_query_node_info_rsp& node_query_node_info_rsp::operator=(const node_query_node_info_rsp& other821) {
  body = other821.body;
  __isset = other821.__isset;
  return *this;
}
void node_query_node_info_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_query_node_info_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


query_node_rent_orders_req_data::~query_node_rent_orders_req_data() noexcept {
}


void query_node_rent_orders_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void query_node_rent_orders_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void query_node_rent_orders_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void query_node_rent_orders_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void query_node_rent_orders_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void query_node_rent_orders_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void query_node_rent_orders_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void query_node_rent_orders_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void query_node_rent_orders_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void query_node_rent_orders_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void query_node_rent_orders_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const query_node_rent_orders_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t query_node_rent_orders_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size822;
            ::apache::thrift::protocol::TType _etype825;
            xfer += iprot->readListBegin(_etype825, _size822);
            this->peer_nodes_list.resize(_size822);
            uint32_t _i826;
            for (_i826 = 0; _i826 < _size822; ++_i826)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i826]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size827;
            ::apache::thrift::protocol::TType _etype830;
            xfer += iprot->readListBegin(_etype830, _size827);
            this->multisig_wallets.resize(_size827);
            uint32_t _i831;
            for (_i831 = 0; _i831 < _size827; ++_i831)
            {
              xfer += iprot->readString(this->multisig_wallets[_i831]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size832;
            ::apache::thrift::protocol::TType _etype835;
            xfer += iprot->readListBegin(_etype835, _size832);
            this->multisig_signs.resize(_size832);
            uint32_t _i836;
            for (_i836 = 0; _i836 < _size832; ++_i836)
            {
              xfer += this->multisig_signs[_i836].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t query_node_rent_orders_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_node_rent_orders_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter837;
    for (_iter837 = this->peer_nodes_list.begin(); _iter837 != this->peer_nodes_list.end(); ++_iter837)
    {
      xfer += oprot->writeString((*_iter837));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter838;
    for (_iter838 = this->multisig_wallets.begin(); _iter838 != this->multisig_wallets.end(); ++_iter838)
    {
      xfer += oprot->writeString((*_iter838));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter839;
    for (_iter839 = this->multisig_signs.begin(); _iter839 != this->multisig_signs.end(); ++_iter839)
    {
      xfer += (*_iter839).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_node_rent_orders_req_data &a, query_node_rent_orders_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

query_node_rent_orders_req_data::query_node_rent_orders_req_data(const query_node_rent_orders_req_data& other840) {
  peer_nodes_list = other840.peer_nodes_list;
  additional = other840.additional;
  wallet = other840.wallet;
  nonce = other840.nonce;
  sign = other840.sign;
  multisig_wallets = other840.multisig_wallets;
  multisig_threshold = other840.multisig_threshold;
  multisig_signs = other840.multisig_signs;
  session_id = other840.session_id;
  session_id_sign = other840.session_id_sign;
  rent_order = other840.rent_order;
  __isset = other840.__isset;
}
query_node_rent_orders_req_data& query_node_rent_orders_req_data::operator=(const query_node_rent_orders_req_data& other841) {
  peer_nodes_list = other841.peer_nodes_list;
  additional = other841.additional;
  wallet = other841.wallet;
  nonce = other841.nonce;
  sign = other841.sign;
  multisig_wallets = other841.multisig_wallets;
  multisig_threshold = other841.multisig_threshold;
  multisig_signs = other841.multisig_signs;
  session_id = other841.session_id;
  session_id_sign = other841.session_id_sign;
  rent_order = other841.rent_order;
  __isset = other841.__isset;
  return *this;
}
void query_node_rent_orders_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_node_rent_orders_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


query_node_rent_orders_req_body::~query_node_rent_orders_req_body() noexcept {
}


void query_node_rent_orders_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const query_node_rent_orders_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t query_node_rent_orders_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t query_node_rent_orders_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_node_rent_orders_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_node_rent_orders_req_body &a, query_node_rent_orders_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

query_node_rent_orders_req_body::query_node_rent_orders_req_body(const query_node_rent_orders_req_body& other842) {
  data = other842.data;
}
query_node_rent_orders_req_body& query_node_rent_orders_req_body::operator=(const query_node_rent_orders_req_body& other843) {
  data = other843.data;
  return *this;
}
void query_node_rent_orders_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_node_rent_orders_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


query_node_rent_orders_req::~query_node_rent_orders_req() noexcept {
}


void query_node_rent_orders_req::__set_body(const query_node_rent_orders_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const query_node_rent_orders_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t query_node_rent_orders_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_node_rent_orders_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_node_rent_orders_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_node_rent_orders_req &a, query_node_rent_orders_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

query_node_rent_orders_req::query_node_rent_orders_req(const query_node_rent_orders_req& other844) {
  body = other844.body;
  __isset = other844.__isset;
}
query_node_rent_orders_req& query_node_rent_orders_req::operator=(const query_node_rent_orders_req& other845) {
  body = other845.body;
  __isset = other845.__isset;
  return *this;
}
void query_node_rent_orders_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_node_rent_orders_req(";
  out << "body=" << to_string(body);
  out << ")";
}


query_node_rent_orders_rsp_body::~query_node_rent_orders_rsp_body() noexcept {
}


void query_node_rent_orders_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const query_node_rent_orders_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t query_node_rent_orders_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t query_node_rent_orders_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_node_rent_orders_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_node_rent_orders_rsp_body &a, query_node_rent_orders_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

query_node_rent_orders_rsp_body::query_node_rent_orders_rsp_body(const query_node_rent_orders_rsp_body& other846) {
  data = other846.data;
}
query_node_rent_orders_rsp_body& query_node_rent_orders_rsp_body::operator=(const query_node_rent_orders_rsp_body& other847) {
  data = other847.data;
  return *this;
}
void query_node_rent_orders_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_node_rent_orders_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


query_node_rent_orders_rsp::~query_node_rent_orders_rsp() noexcept {
}


void query_node_rent_orders_rsp::__set_body(const query_node_rent_orders_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const query_node_rent_orders_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t query_node_rent_orders_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_node_rent_orders_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_node_rent_orders_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_node_rent_orders_rsp &a, query_node_rent_orders_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

query_node_rent_orders_rsp::query_node_rent_orders_rsp(const query_node_rent_orders_rsp& other848) {
  body = other848.body;
  __isset = other848.__isset;
}
query_node_rent_orders_rsp& query_node_rent_orders_rsp::operator=(const query_node_rent_orders_rsp& other849) {
  body = other849.body;
  __isset = other849.__isset;
  return *this;
}
void query_node_rent_orders_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_node_rent_orders_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_free_memory_req_data::~node_free_memory_req_data() noexcept {
}


void node_free_memory_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_free_memory_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_free_memory_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_free_memory_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_free_memory_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_free_memory_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_free_memory_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_free_memory_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_free_memory_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_free_memory_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_free_memory_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_free_memory_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_free_memory_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size850;
            ::apache::thrift::protocol::TType _etype853;
            xfer += iprot->readListBegin(_etype853, _size850);
            this->peer_nodes_list.resize(_size850);
            uint32_t _i854;
            for (_i854 = 0; _i854 < _size850; ++_i854)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i854]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size855;
            ::apache::thrift::protocol::TType _etype858;
            xfer += iprot->readListBegin(_etype858, _size855);
            this->multisig_wallets.resize(_size855);
            uint32_t _i859;
            for (_i859 = 0; _i859 < _size855; ++_i859)
            {
              xfer += iprot->readString(this->multisig_wallets[_i859]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size860;
            ::apache::thrift::protocol::TType _etype863;
            xfer += iprot->readListBegin(_etype863, _size860);
            this->multisig_signs.resize(_size860);
            uint32_t _i864;
            for (_i864 = 0; _i864 < _size860; ++_i864)
            {
              xfer += this->multisig_signs[_i864].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_free_memory_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_free_memory_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter865;
    for (_iter865 = this->peer_nodes_list.begin(); _iter865 != this->peer_nodes_list.end(); ++_iter865)
    {
      xfer += oprot->writeString((*_iter865));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter866;
    for (_iter866 = this->multisig_wallets.begin(); _iter866 != this->multisig_wallets.end(); ++_iter866)
    {
      xfer += oprot->writeString((*_iter866));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter867;
    for (_iter867 = this->multisig_signs.begin(); _iter867 != this->multisig_signs.end(); ++_iter867)
    {
      xfer += (*_iter867).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_free_memory_req_data &a, node_free_memory_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_free_memory_req_data::node_free_memory_req_data(const node_free_memory_req_data& other868) {
  peer_nodes_list = other868.peer_nodes_list;
  additional = other868.additional;
  wallet = other868.wallet;
  nonce = other868.nonce;
  sign = other868.sign;
  multisig_wallets = other868.multisig_wallets;
  multisig_threshold = other868.multisig_threshold;
  multisig_signs = other868.multisig_signs;
  session_id = other868.session_id;
  session_id_sign = other868.session_id_sign;
  rent_order = other868.rent_order;
  __isset = other868.__isset;
}
node_free_memory_req_data& node_free_memory_req_data::operator=(const node_free_memory_req_data& other869) {
  peer_nodes_list = other869.peer_nodes_list;
  additional = other869.additional;
  wallet = other869.wallet;
  nonce = other869.nonce;
  sign = other869.sign;
  multisig_wallets = other869.multisig_wallets;
  multisig_threshold = other869.multisig_threshold;
  multisig_signs = other869.multisig_signs;
  session_id = other869.session_id;
  session_id_sign = other869.session_id_sign;
  rent_order = other869.rent_order;
  __isset = other869.__isset;
  return *this;
}
void node_free_memory_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_free_memory_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_free_memory_req_body::~node_free_memory_req_body() noexcept {
}


void node_free_memory_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_free_memory_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_free_memory_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_free_memory_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_free_memory_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_free_memory_req_body &a, node_free_memory_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_free_memory_req_body::node_free_memory_req_body(const node_free_memory_req_body& other870) {
  data = other870.data;
}
node_free_memory_req_body& node_free_memory_req_body::operator=(const node_free_memory_req_body& other871) {
  data = other871.data;
  return *this;
}
void node_free_memory_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_free_memory_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_free_memory_req::~node_free_memory_req() noexcept {
}


void node_free_memory_req::__set_body(const node_free_memory_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_free_memory_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_free_memory_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_free_memory_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_free_memory_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_free_memory_req &a, node_free_memory_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_free_memory_req::node_free_memory_req(const node_free_memory_req& other872) {
  body = other872.body;
  __isset = other872.__isset;
}
node_free_memory_req& node_free_memory_req::operator=(const node_free_memory_req& other873) {
  body = other873.body;
  __isset = other873.__isset;
  return *this;
}
void node_free_memory_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_free_memory_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_free_memory_rsp_body::~node_free_memory_rsp_body() noexcept {
}


void node_free_memory_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_free_memory_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_free_memory_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_free_memory_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_free_memory_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_free_memory_rsp_body &a, node_free_memory_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_free_memory_rsp_body::node_free_memory_rsp_body(const node_free_memory_rsp_body& other874) {
  data = other874.data;
}
node_free_memory_rsp_body& node_free_memory_rsp_body::operator=(const node_free_memory_rsp_body& other875) {
  data = other875.data;
  return *this;
}
void node_free_memory_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_free_memory_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_free_memory_rsp::~node_free_memory_rsp() noexcept {
}


void node_free_memory_rsp::__set_body(const node_free_memory_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_free_memory_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_free_memory_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_free_memory_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_free_memory_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_free_memory_rsp &a, node_free_memory_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_free_memory_rsp::node_free_memory_rsp(const node_free_memory_rsp& other876) {
  body = other876.body;
  __isset = other876.__isset;
}
node_free_memory_rsp& node_free_memory_rsp::operator=(const node_free_memory_rsp& other877) {
  body = other877.body;
  __isset = other877.__isset;
  return *this;
}
void node_free_memory_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_free_memory_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_service_info::~node_service_info() noexcept {
}


void node_service_info::__set_service_list(const std::vector<std::string> & val) {
  this->service_list = val;
}

void node_service_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void node_service_info::__set_time_stamp(const int64_t val) {
  this->time_stamp = val;
__isset.time_stamp = true;
}

void node_service_info::__set_kvs(const std::map<std::string, std::string> & val) {
  this->kvs = val;
__isset.kvs = true;
}
std::ostream& operator<<(std::ostream& out, const node_service_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_service_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->service_list.clear();
            uint32_t _size878;
            ::apache::thrift::protocol::TType _etype881;
            xfer += iprot->readListBegin(_etype881, _size878);
            this->service_list.resize(_size878);
            uint32_t _i882;
            for (_i882 = 0; _i882 < _size878; ++_i882)
            {
              xfer += iprot->readString(this->service_list[_i882]);
            }
            xfer += iprot->readListEnd();
          }
          isset_service_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time_stamp);
          this->__isset.time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->kvs.clear();
            uint32_t _size883;
            ::apache::thrift::protocol::TType _ktype884;
            ::apache::thrift::protocol::TType _vtype885;
            xfer += iprot->readMapBegin(_ktype884, _vtype885, _size883);
            uint32_t _i887;
            for (_i887 = 0; _i887 < _size883; ++_i887)
            {
              std::string _key888;
              xfer += iprot->readString(_key888);
              std::string& _val889 = this->kvs[_key888];
              xfer += iprot->readString(_val889);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.kvs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_service_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_service_info");

  xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
    std::vector<std::string> ::const_iterator _iter890;
    for (_iter890 = this->service_list.begin(); _iter890 != this->service_list.end(); ++_iter890)
    {
      xfer += oprot->writeString((*_iter890));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.time_stamp) {
    xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->time_stamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kvs) {
    xfer += oprot->writeFieldBegin("kvs", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kvs.size()));
      std::map<std::string, std::string> ::const_iterator _iter891;
      for (_iter891 = this->kvs.begin(); _iter891 != this->kvs.end(); ++_iter891)
      {
        xfer += oprot->writeString(_iter891->first);
        xfer += oprot->writeString(_iter891->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_service_info &a, node_service_info &b) {
  using ::std::swap;
  swap(a.service_list, b.service_list);
  swap(a.name, b.name);
  swap(a.time_stamp, b.time_stamp);
  swap(a.kvs, b.kvs);
  swap(a.__isset, b.__isset);
}

node_service_info::node_service_info(const node_service_info& other892) {
  service_list = other892.service_list;
  name = other892.name;
  time_stamp = other892.time_stamp;
  kvs = other892.kvs;
  __isset = other892.__isset;
}
node_service_info& node_service_info::operator=(const node_service_info& other893) {
  service_list = other893.service_list;
  name = other893.name;
  time_stamp = other893.time_stamp;
  kvs = other893.kvs;
  __isset = other893.__isset;
  return *this;
}
void node_service_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_service_info(";
  out << "service_list=" << to_string(service_list);
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "time_stamp="; (__isset.time_stamp ? (out << to_string(time_stamp)) : (out << "<null>"));
  out << ", " << "kvs="; (__isset.kvs ? (out << to_string(kvs)) : (out << "<null>"));
  out << ")";
}


service_broadcast_req_body::~service_broadcast_req_body() noexcept {
}


void service_broadcast_req_body::__set_node_service_info_map(const std::map<std::string, node_service_info> & val) {
  this->node_service_info_map = val;
}
std::ostream& operator<<(std::ostream& out, const service_broadcast_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t service_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_service_info_map = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->node_service_info_map.clear();
            uint32_t _size894;
            ::apache::thrift::protocol::TType _ktype895;
            ::apache::thrift::protocol::TType _vtype896;
            xfer += iprot->readMapBegin(_ktype895, _vtype896, _size894);
            uint32_t _i898;
            for (_i898 = 0; _i898 < _size894; ++_i898)
            {
              std::string _key899;
              xfer += iprot->readString(_key899);
              node_service_info& _val900 = this->node_service_info_map[_key899];
              xfer += _val900.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_node_service_info_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_service_info_map)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t service_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("service_broadcast_req_body");

  xfer += oprot->writeFieldBegin("node_service_info_map", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_service_info_map.size()));
    std::map<std::string, node_service_info> ::const_iterator _iter901;
    for (_iter901 = this->node_service_info_map.begin(); _iter901 != this->node_service_info_map.end(); ++_iter901)
    {
      xfer += oprot->writeString(_iter901->first);
      xfer += _iter901->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(service_broadcast_req_body &a, service_broadcast_req_body &b) {
  using ::std::swap;
  swap(a.node_service_info_map, b.node_service_info_map);
}

service_broadcast_req_body::service_broadcast_req_body(const service_broadcast_req_body& other902) {
  node_service_info_map = other902.node_service_info_map;
}
service_broadcast_req_body& service_broadcast_req_body::operator=(const service_broadcast_req_body& other903) {
  node_service_info_map = other903.node_service_info_map;
  return *this;
}
void service_broadcast_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "service_broadcast_req_body(";
  out << "node_service_info_map=" << to_string(node_service_info_map);
  out << ")";
}


service_broadcast_req::~service_broadcast_req() noexcept {
}


void service_broadcast_req::__set_body(const service_broadcast_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const service_broadcast_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t service_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t service_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("service_broadcast_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(service_broadcast_req &a, service_broadcast_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

service_broadcast_req::service_broadcast_req(const service_broadcast_req& other904) {
  body = other904.body;
  __isset = other904.__isset;
}
service_broadcast_req& service_broadcast_req::operator=(const service_broadcast_req& other905) {
  body = other905.body;
  __isset = other905.__isset;
  return *this;
}
void service_broadcast_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "service_broadcast_req(";
  out << "body=" << to_string(body);
  out << ")";
}


ver_req_body::~ver_req_body() noexcept {
}


void ver_req_body::__set_node_id(const std::string& val) {
  this->node_id = val;
}

void ver_req_body::__set_core_version(const int32_t val) {
  this->core_version = val;
}

void ver_req_body::__set_protocol_version(const int32_t val) {
  this->protocol_version = val;
}

void ver_req_body::__set_time_stamp(const int64_t val) {
  this->time_stamp = val;
}

void ver_req_body::__set_addr_me(const network_address& val) {
  this->addr_me = val;
}

void ver_req_body::__set_addr_you(const network_address& val) {
  this->addr_you = val;
}

void ver_req_body::__set_start_height(const int64_t val) {
  this->start_height = val;
}
std::ostream& operator<<(std::ostream& out, const ver_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ver_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_id = false;
  bool isset_core_version = false;
  bool isset_protocol_version = false;
  bool isset_time_stamp = false;
  bool isset_addr_me = false;
  bool isset_addr_you = false;
  bool isset_start_height = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          isset_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->core_version);
          isset_core_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->protocol_version);
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time_stamp);
          isset_time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->addr_me.read(iprot);
          isset_addr_me = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->addr_you.read(iprot);
          isset_addr_you = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_height);
          isset_start_height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_core_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_time_stamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_addr_me)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_addr_you)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_start_height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ver_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ver_req_body");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->core_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->time_stamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr_me", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->addr_me.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr_you", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->addr_you.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_height", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->start_height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ver_req_body &a, ver_req_body &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.core_version, b.core_version);
  swap(a.protocol_version, b.protocol_version);
  swap(a.time_stamp, b.time_stamp);
  swap(a.addr_me, b.addr_me);
  swap(a.addr_you, b.addr_you);
  swap(a.start_height, b.start_height);
}

ver_req_body::ver_req_body(const ver_req_body& other906) {
  node_id = other906.node_id;
  core_version = other906.core_version;
  protocol_version = other906.protocol_version;
  time_stamp = other906.time_stamp;
  addr_me = other906.addr_me;
  addr_you = other906.addr_you;
  start_height = other906.start_height;
}
ver_req_body& ver_req_body::operator=(const ver_req_body& other907) {
  node_id = other907.node_id;
  core_version = other907.core_version;
  protocol_version = other907.protocol_version;
  time_stamp = other907.time_stamp;
  addr_me = other907.addr_me;
  addr_you = other907.addr_you;
  start_height = other907.start_height;
  return *this;
}
void ver_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ver_req_body(";
  out << "node_id=" << to_string(node_id);
  out << ", " << "core_version=" << to_string(core_version);
  out << ", " << "protocol_version=" << to_string(protocol_version);
  out << ", " << "time_stamp=" << to_string(time_stamp);
  out << ", " << "addr_me=" << to_string(addr_me);
  out << ", " << "addr_you=" << to_string(addr_you);
  out << ", " << "start_height=" << to_string(start_height);
  out << ")";
}


ver_req::~ver_req() noexcept {
}


void ver_req::__set_body(const ver_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const ver_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ver_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ver_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ver_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ver_req &a, ver_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

ver_req::ver_req(const ver_req& other908) {
  body = other908.body;
  __isset = other908.__isset;
}
ver_req& ver_req::operator=(const ver_req& other909) {
  body = other909.body;
  __isset = other909.__isset;
  return *this;
}
void ver_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ver_req(";
  out << "body=" << to_string(body);
  out << ")";
}


ver_resp_body::~ver_resp_body() noexcept {
}


void ver_resp_body::__set_node_id(const std::string& val) {
  this->node_id = val;
}

void ver_resp_body::__set_core_version(const int32_t val) {
  this->core_version = val;
}

void ver_resp_body::__set_protocol_version(const int32_t val) {
  this->protocol_version = val;
}
std::ostream& operator<<(std::ostream& out, const ver_resp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ver_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_id = false;
  bool isset_core_version = false;
  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          isset_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->core_version);
          isset_core_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->protocol_version);
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_core_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ver_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ver_resp_body");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->core_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ver_resp_body &a, ver_resp_body &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.core_version, b.core_version);
  swap(a.protocol_version, b.protocol_version);
}

ver_resp_body::ver_resp_body(const ver_resp_body& other910) {
  node_id = other910.node_id;
  core_version = other910.core_version;
  protocol_version = other910.protocol_version;
}
ver_resp_body& ver_resp_body::operator=(const ver_resp_body& other911) {
  node_id = other911.node_id;
  core_version = other911.core_version;
  protocol_version = other911.protocol_version;
  return *this;
}
void ver_resp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ver_resp_body(";
  out << "node_id=" << to_string(node_id);
  out << ", " << "core_version=" << to_string(core_version);
  out << ", " << "protocol_version=" << to_string(protocol_version);
  out << ")";
}


ver_resp::~ver_resp() noexcept {
}


void ver_resp::__set_body(const ver_resp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const ver_resp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ver_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ver_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ver_resp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ver_resp &a, ver_resp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

ver_resp::ver_resp(const ver_resp& other912) {
  body = other912.body;
  __isset = other912.__isset;
}
ver_resp& ver_resp::operator=(const ver_resp& other913) {
  body = other913.body;
  __isset = other913.__isset;
  return *this;
}
void ver_resp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ver_resp(";
  out << "body=" << to_string(body);
  out << ")";
}


peer_node_info::~peer_node_info() noexcept {
}


void peer_node_info::__set_peer_node_id(const std::string& val) {
  this->peer_node_id = val;
}

void peer_node_info::__set_core_version(const int32_t val) {
  this->core_version = val;
}

void peer_node_info::__set_protocol_version(const int32_t val) {
  this->protocol_version = val;
}

void peer_node_info::__set_live_time_stamp(const int32_t val) {
  this->live_time_stamp = val;
}

void peer_node_info::__set_addr(const network_address& val) {
  this->addr = val;
}

void peer_node_info::__set_service_list(const std::vector<std::string> & val) {
  this->service_list = val;
__isset.service_list = true;
}
std::ostream& operator<<(std::ostream& out, const peer_node_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t peer_node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_node_id = false;
  bool isset_core_version = false;
  bool isset_protocol_version = false;
  bool isset_live_time_stamp = false;
  bool isset_addr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->peer_node_id);
          isset_peer_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->core_version);
          isset_core_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->protocol_version);
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->live_time_stamp);
          isset_live_time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->addr.read(iprot);
          isset_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->service_list.clear();
            uint32_t _size914;
            ::apache::thrift::protocol::TType _etype917;
            xfer += iprot->readListBegin(_etype917, _size914);
            this->service_list.resize(_size914);
            uint32_t _i918;
            for (_i918 = 0; _i918 < _size914; ++_i918)
            {
              xfer += iprot->readString(this->service_list[_i918]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.service_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_core_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_live_time_stamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_addr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t peer_node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("peer_node_info");

  xfer += oprot->writeFieldBegin("peer_node_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->peer_node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->core_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("live_time_stamp", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->live_time_stamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->addr.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.service_list) {
    xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
      std::vector<std::string> ::const_iterator _iter919;
      for (_iter919 = this->service_list.begin(); _iter919 != this->service_list.end(); ++_iter919)
      {
        xfer += oprot->writeString((*_iter919));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(peer_node_info &a, peer_node_info &b) {
  using ::std::swap;
  swap(a.peer_node_id, b.peer_node_id);
  swap(a.core_version, b.core_version);
  swap(a.protocol_version, b.protocol_version);
  swap(a.live_time_stamp, b.live_time_stamp);
  swap(a.addr, b.addr);
  swap(a.service_list, b.service_list);
  swap(a.__isset, b.__isset);
}

peer_node_info::peer_node_info(const peer_node_info& other920) {
  peer_node_id = other920.peer_node_id;
  core_version = other920.core_version;
  protocol_version = other920.protocol_version;
  live_time_stamp = other920.live_time_stamp;
  addr = other920.addr;
  service_list = other920.service_list;
  __isset = other920.__isset;
}
peer_node_info& peer_node_info::operator=(const peer_node_info& other921) {
  peer_node_id = other921.peer_node_id;
  core_version = other921.core_version;
  protocol_version = other921.protocol_version;
  live_time_stamp = other921.live_time_stamp;
  addr = other921.addr;
  service_list = other921.service_list;
  __isset = other921.__isset;
  return *this;
}
void peer_node_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "peer_node_info(";
  out << "peer_node_id=" << to_string(peer_node_id);
  out << ", " << "core_version=" << to_string(core_version);
  out << ", " << "protocol_version=" << to_string(protocol_version);
  out << ", " << "live_time_stamp=" << to_string(live_time_stamp);
  out << ", " << "addr=" << to_string(addr);
  out << ", " << "service_list="; (__isset.service_list ? (out << to_string(service_list)) : (out << "<null>"));
  out << ")";
}


get_peer_nodes_req::~get_peer_nodes_req() noexcept {
}


void get_peer_nodes_req::__set_body(const empty& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const get_peer_nodes_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t get_peer_nodes_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t get_peer_nodes_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("get_peer_nodes_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(get_peer_nodes_req &a, get_peer_nodes_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

get_peer_nodes_req::get_peer_nodes_req(const get_peer_nodes_req& other922) {
  body = other922.body;
  __isset = other922.__isset;
}
get_peer_nodes_req& get_peer_nodes_req::operator=(const get_peer_nodes_req& other923) {
  body = other923.body;
  __isset = other923.__isset;
  return *this;
}
void get_peer_nodes_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "get_peer_nodes_req(";
  out << "body=" << to_string(body);
  out << ")";
}


get_peer_nodes_resp_body::~get_peer_nodes_resp_body() noexcept {
}


void get_peer_nodes_resp_body::__set_peer_nodes_list(const std::vector<peer_node_info> & val) {
  this->peer_nodes_list = val;
}
std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t get_peer_nodes_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size924;
            ::apache::thrift::protocol::TType _etype927;
            xfer += iprot->readListBegin(_etype927, _size924);
            this->peer_nodes_list.resize(_size924);
            uint32_t _i928;
            for (_i928 = 0; _i928 < _size924; ++_i928)
            {
              xfer += this->peer_nodes_list[_i928].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t get_peer_nodes_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("get_peer_nodes_resp_body");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<peer_node_info> ::const_iterator _iter929;
    for (_iter929 = this->peer_nodes_list.begin(); _iter929 != this->peer_nodes_list.end(); ++_iter929)
    {
      xfer += (*_iter929).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(get_peer_nodes_resp_body &a, get_peer_nodes_resp_body &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
}

get_peer_nodes_resp_body::get_peer_nodes_resp_body(const get_peer_nodes_resp_body& other930) {
  peer_nodes_list = other930.peer_nodes_list;
}
get_peer_nodes_resp_body& get_peer_nodes_resp_body::operator=(const get_peer_nodes_resp_body& other931) {
  peer_nodes_list = other931.peer_nodes_list;
  return *this;
}
void get_peer_nodes_resp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "get_peer_nodes_resp_body(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ")";
}


get_peer_nodes_resp::~get_peer_nodes_resp() noexcept {
}


void get_peer_nodes_resp::__set_body(const get_peer_nodes_resp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t get_peer_nodes_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t get_peer_nodes_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("get_peer_nodes_resp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(get_peer_nodes_resp &a, get_peer_nodes_resp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

get_peer_nodes_resp::get_peer_nodes_resp(const get_peer_nodes_resp& other932) {
  body = other932.body;
  __isset = other932.__isset;
}
get_peer_nodes_resp& get_peer_nodes_resp::operator=(const get_peer_nodes_resp& other933) {
  body = other933.body;
  __isset = other933.__isset;
  return *this;
}
void get_peer_nodes_resp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "get_peer_nodes_resp(";
  out << "body=" << to_string(body);
  out << ")";
}


peer_nodes_broadcast_req_body::~peer_nodes_broadcast_req_body() noexcept {
}


void peer_nodes_broadcast_req_body::__set_peer_nodes_list(const std::vector<peer_node_info> & val) {
  this->peer_nodes_list = val;
}
std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t peer_nodes_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size934;
            ::apache::thrift::protocol::TType _etype937;
            xfer += iprot->readListBegin(_etype937, _size934);
            this->peer_nodes_list.resize(_size934);
            uint32_t _i938;
            for (_i938 = 0; _i938 < _size934; ++_i938)
            {
              xfer += this->peer_nodes_list[_i938].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t peer_nodes_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("peer_nodes_broadcast_req_body");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<peer_node_info> ::const_iterator _iter939;
    for (_iter939 = this->peer_nodes_list.begin(); _iter939 != this->peer_nodes_list.end(); ++_iter939)
    {
      xfer += (*_iter939).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(peer_nodes_broadcast_req_body &a, peer_nodes_broadcast_req_body &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
}

peer_nodes_broadcast_req_body::peer_nodes_broadcast_req_body(const peer_nodes_broadcast_req_body& other940) {
  peer_nodes_list = other940.peer_nodes_list;
}
peer_nodes_broadcast_req_body& peer_nodes_broadcast_req_body::operator=(const peer_nodes_broadcast_req_body& other941) {
  peer_nodes_list = other941.peer_nodes_list;
  return *this;
}
void peer_nodes_broadcast_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "peer_nodes_broadcast_req_body(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ")";
}


peer_nodes_broadcast_req::~peer_nodes_broadcast_req() noexcept {
}


void peer_nodes_broadcast_req::__set_body(const peer_nodes_broadcast_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t peer_nodes_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t peer_nodes_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("peer_nodes_broadcast_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(peer_nodes_broadcast_req &a, peer_nodes_broadcast_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

peer_nodes_broadcast_req::peer_nodes_broadcast_req(const peer_nodes_broadcast_req& other942) {
  body = other942.body;
  __isset = other942.__isset;
}
peer_nodes_broadcast_req& peer_nodes_broadcast_req::operator=(const peer_nodes_broadcast_req& other943) {
  body = other943.body;
  __isset = other943.__isset;
  return *this;
}
void peer_nodes_broadcast_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "peer_nodes_broadcast_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_monitor_server_req_data::~node_list_monitor_server_req_data() noexcept {
}


void node_list_monitor_server_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_list_monitor_server_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_list_monitor_server_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_list_monitor_server_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_list_monitor_server_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_list_monitor_server_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_list_monitor_server_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_list_monitor_server_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_list_monitor_server_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_list_monitor_server_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_list_monitor_server_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_list_monitor_server_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_monitor_server_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size944;
            ::apache::thrift::protocol::TType _etype947;
            xfer += iprot->readListBegin(_etype947, _size944);
            this->peer_nodes_list.resize(_size944);
            uint32_t _i948;
            for (_i948 = 0; _i948 < _size944; ++_i948)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i948]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size949;
            ::apache::thrift::protocol::TType _etype952;
            xfer += iprot->readListBegin(_etype952, _size949);
            this->multisig_wallets.resize(_size949);
            uint32_t _i953;
            for (_i953 = 0; _i953 < _size949; ++_i953)
            {
              xfer += iprot->readString(this->multisig_wallets[_i953]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size954;
            ::apache::thrift::protocol::TType _etype957;
            xfer += iprot->readListBegin(_etype957, _size954);
            this->multisig_signs.resize(_size954);
            uint32_t _i958;
            for (_i958 = 0; _i958 < _size954; ++_i958)
            {
              xfer += this->multisig_signs[_i958].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_monitor_server_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_monitor_server_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter959;
    for (_iter959 = this->peer_nodes_list.begin(); _iter959 != this->peer_nodes_list.end(); ++_iter959)
    {
      xfer += oprot->writeString((*_iter959));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter960;
    for (_iter960 = this->multisig_wallets.begin(); _iter960 != this->multisig_wallets.end(); ++_iter960)
    {
      xfer += oprot->writeString((*_iter960));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter961;
    for (_iter961 = this->multisig_signs.begin(); _iter961 != this->multisig_signs.end(); ++_iter961)
    {
      xfer += (*_iter961).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_monitor_server_req_data &a, node_list_monitor_server_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_list_monitor_server_req_data::node_list_monitor_server_req_data(const node_list_monitor_server_req_data& other962) {
  peer_nodes_list = other962.peer_nodes_list;
  additional = other962.additional;
  wallet = other962.wallet;
  nonce = other962.nonce;
  sign = other962.sign;
  multisig_wallets = other962.multisig_wallets;
  multisig_threshold = other962.multisig_threshold;
  multisig_signs = other962.multisig_signs;
  session_id = other962.session_id;
  session_id_sign = other962.session_id_sign;
  rent_order = other962.rent_order;
  __isset = other962.__isset;
}
node_list_monitor_server_req_data& node_list_monitor_server_req_data::operator=(const node_list_monitor_server_req_data& other963) {
  peer_nodes_list = other963.peer_nodes_list;
  additional = other963.additional;
  wallet = other963.wallet;
  nonce = other963.nonce;
  sign = other963.sign;
  multisig_wallets = other963.multisig_wallets;
  multisig_threshold = other963.multisig_threshold;
  multisig_signs = other963.multisig_signs;
  session_id = other963.session_id;
  session_id_sign = other963.session_id_sign;
  rent_order = other963.rent_order;
  __isset = other963.__isset;
  return *this;
}
void node_list_monitor_server_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_monitor_server_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_list_monitor_server_req_body::~node_list_monitor_server_req_body() noexcept {
}


void node_list_monitor_server_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_monitor_server_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_monitor_server_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_monitor_server_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_monitor_server_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_monitor_server_req_body &a, node_list_monitor_server_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_monitor_server_req_body::node_list_monitor_server_req_body(const node_list_monitor_server_req_body& other964) {
  data = other964.data;
}
node_list_monitor_server_req_body& node_list_monitor_server_req_body::operator=(const node_list_monitor_server_req_body& other965) {
  data = other965.data;
  return *this;
}
void node_list_monitor_server_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_monitor_server_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_monitor_server_req::~node_list_monitor_server_req() noexcept {
}


void node_list_monitor_server_req::__set_body(const node_list_monitor_server_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_monitor_server_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_monitor_server_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_monitor_server_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_monitor_server_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_monitor_server_req &a, node_list_monitor_server_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_monitor_server_req::node_list_monitor_server_req(const node_list_monitor_server_req& other966) {
  body = other966.body;
  __isset = other966.__isset;
}
node_list_monitor_server_req& node_list_monitor_server_req::operator=(const node_list_monitor_server_req& other967) {
  body = other967.body;
  __isset = other967.__isset;
  return *this;
}
void node_list_monitor_server_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_monitor_server_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_monitor_server_rsp_body::~node_list_monitor_server_rsp_body() noexcept {
}


void node_list_monitor_server_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_monitor_server_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_monitor_server_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_monitor_server_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_monitor_server_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_monitor_server_rsp_body &a, node_list_monitor_server_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_monitor_server_rsp_body::node_list_monitor_server_rsp_body(const node_list_monitor_server_rsp_body& other968) {
  data = other968.data;
}
node_list_monitor_server_rsp_body& node_list_monitor_server_rsp_body::operator=(const node_list_monitor_server_rsp_body& other969) {
  data = other969.data;
  return *this;
}
void node_list_monitor_server_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_monitor_server_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_monitor_server_rsp::~node_list_monitor_server_rsp() noexcept {
}


void node_list_monitor_server_rsp::__set_body(const node_list_monitor_server_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_monitor_server_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_monitor_server_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_monitor_server_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_monitor_server_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_monitor_server_rsp &a, node_list_monitor_server_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_monitor_server_rsp::node_list_monitor_server_rsp(const node_list_monitor_server_rsp& other970) {
  body = other970.body;
  __isset = other970.__isset;
}
node_list_monitor_server_rsp& node_list_monitor_server_rsp::operator=(const node_list_monitor_server_rsp& other971) {
  body = other971.body;
  __isset = other971.__isset;
  return *this;
}
void node_list_monitor_server_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_monitor_server_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_set_monitor_server_req_data::~node_set_monitor_server_req_data() noexcept {
}


void node_set_monitor_server_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_set_monitor_server_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_set_monitor_server_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_set_monitor_server_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_set_monitor_server_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_set_monitor_server_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_set_monitor_server_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_set_monitor_server_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_set_monitor_server_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_set_monitor_server_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_set_monitor_server_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_set_monitor_server_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_set_monitor_server_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size972;
            ::apache::thrift::protocol::TType _etype975;
            xfer += iprot->readListBegin(_etype975, _size972);
            this->peer_nodes_list.resize(_size972);
            uint32_t _i976;
            for (_i976 = 0; _i976 < _size972; ++_i976)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i976]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size977;
            ::apache::thrift::protocol::TType _etype980;
            xfer += iprot->readListBegin(_etype980, _size977);
            this->multisig_wallets.resize(_size977);
            uint32_t _i981;
            for (_i981 = 0; _i981 < _size977; ++_i981)
            {
              xfer += iprot->readString(this->multisig_wallets[_i981]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size982;
            ::apache::thrift::protocol::TType _etype985;
            xfer += iprot->readListBegin(_etype985, _size982);
            this->multisig_signs.resize(_size982);
            uint32_t _i986;
            for (_i986 = 0; _i986 < _size982; ++_i986)
            {
              xfer += this->multisig_signs[_i986].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_set_monitor_server_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_set_monitor_server_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter987;
    for (_iter987 = this->peer_nodes_list.begin(); _iter987 != this->peer_nodes_list.end(); ++_iter987)
    {
      xfer += oprot->writeString((*_iter987));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter988;
    for (_iter988 = this->multisig_wallets.begin(); _iter988 != this->multisig_wallets.end(); ++_iter988)
    {
      xfer += oprot->writeString((*_iter988));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter989;
    for (_iter989 = this->multisig_signs.begin(); _iter989 != this->multisig_signs.end(); ++_iter989)
    {
      xfer += (*_iter989).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_set_monitor_server_req_data &a, node_set_monitor_server_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_set_monitor_server_req_data::node_set_monitor_server_req_data(const node_set_monitor_server_req_data& other990) {
  peer_nodes_list = other990.peer_nodes_list;
  additional = other990.additional;
  wallet = other990.wallet;
  nonce = other990.nonce;
  sign = other990.sign;
  multisig_wallets = other990.multisig_wallets;
  multisig_threshold = other990.multisig_threshold;
  multisig_signs = other990.multisig_signs;
  session_id = other990.session_id;
  session_id_sign = other990.session_id_sign;
  rent_order = other990.rent_order;
  __isset = other990.__isset;
}
node_set_monitor_server_req_data& node_set_monitor_server_req_data::operator=(const node_set_monitor_server_req_data& other991) {
  peer_nodes_list = other991.peer_nodes_list;
  additional = other991.additional;
  wallet = other991.wallet;
  nonce = other991.nonce;
  sign = other991.sign;
  multisig_wallets = other991.multisig_wallets;
  multisig_threshold = other991.multisig_threshold;
  multisig_signs = other991.multisig_signs;
  session_id = other991.session_id;
  session_id_sign = other991.session_id_sign;
  rent_order = other991.rent_order;
  __isset = other991.__isset;
  return *this;
}
void node_set_monitor_server_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_set_monitor_server_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_set_monitor_server_req_body::~node_set_monitor_server_req_body() noexcept {
}


void node_set_monitor_server_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_set_monitor_server_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_set_monitor_server_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_set_monitor_server_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_set_monitor_server_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_set_monitor_server_req_body &a, node_set_monitor_server_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_set_monitor_server_req_body::node_set_monitor_server_req_body(const node_set_monitor_server_req_body& other992) {
  data = other992.data;
}
node_set_monitor_server_req_body& node_set_monitor_server_req_body::operator=(const node_set_monitor_server_req_body& other993) {
  data = other993.data;
  return *this;
}
void node_set_monitor_server_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_set_monitor_server_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_set_monitor_server_req::~node_set_monitor_server_req() noexcept {
}


void node_set_monitor_server_req::__set_body(const node_set_monitor_server_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_set_monitor_server_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_set_monitor_server_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_set_monitor_server_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_set_monitor_server_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_set_monitor_server_req &a, node_set_monitor_server_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_set_monitor_server_req::node_set_monitor_server_req(const node_set_monitor_server_req& other994) {
  body = other994.body;
  __isset = other994.__isset;
}
node_set_monitor_server_req& node_set_monitor_server_req::operator=(const node_set_monitor_server_req& other995) {
  body = other995.body;
  __isset = other995.__isset;
  return *this;
}
void node_set_monitor_server_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_set_monitor_server_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_set_monitor_server_rsp_body::~node_set_monitor_server_rsp_body() noexcept {
}


void node_set_monitor_server_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_set_monitor_server_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_set_monitor_server_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_set_monitor_server_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_set_monitor_server_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_set_monitor_server_rsp_body &a, node_set_monitor_server_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_set_monitor_server_rsp_body::node_set_monitor_server_rsp_body(const node_set_monitor_server_rsp_body& other996) {
  data = other996.data;
}
node_set_monitor_server_rsp_body& node_set_monitor_server_rsp_body::operator=(const node_set_monitor_server_rsp_body& other997) {
  data = other997.data;
  return *this;
}
void node_set_monitor_server_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_set_monitor_server_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_set_monitor_server_rsp::~node_set_monitor_server_rsp() noexcept {
}


void node_set_monitor_server_rsp::__set_body(const node_set_monitor_server_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_set_monitor_server_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_set_monitor_server_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_set_monitor_server_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_set_monitor_server_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_set_monitor_server_rsp &a, node_set_monitor_server_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_set_monitor_server_rsp::node_set_monitor_server_rsp(const node_set_monitor_server_rsp& other998) {
  body = other998.body;
  __isset = other998.__isset;
}
node_set_monitor_server_rsp& node_set_monitor_server_rsp::operator=(const node_set_monitor_server_rsp& other999) {
  body = other999.body;
  __isset = other999.__isset;
  return *this;
}
void node_set_monitor_server_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_set_monitor_server_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_bare_metal_req_data::~node_list_bare_metal_req_data() noexcept {
}


void node_list_bare_metal_req_data::__set_node_id(const std::string& val) {
  this->node_id = val;
}

void node_list_bare_metal_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_list_bare_metal_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_list_bare_metal_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_list_bare_metal_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_list_bare_metal_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_list_bare_metal_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_list_bare_metal_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_list_bare_metal_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_list_bare_metal_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_list_bare_metal_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_list_bare_metal_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_list_bare_metal_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_bare_metal_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_id = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          isset_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size1000;
            ::apache::thrift::protocol::TType _etype1003;
            xfer += iprot->readListBegin(_etype1003, _size1000);
            this->peer_nodes_list.resize(_size1000);
            uint32_t _i1004;
            for (_i1004 = 0; _i1004 < _size1000; ++_i1004)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i1004]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size1005;
            ::apache::thrift::protocol::TType _etype1008;
            xfer += iprot->readListBegin(_etype1008, _size1005);
            this->multisig_wallets.resize(_size1005);
            uint32_t _i1009;
            for (_i1009 = 0; _i1009 < _size1005; ++_i1009)
            {
              xfer += iprot->readString(this->multisig_wallets[_i1009]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size1010;
            ::apache::thrift::protocol::TType _etype1013;
            xfer += iprot->readListBegin(_etype1013, _size1010);
            this->multisig_signs.resize(_size1010);
            uint32_t _i1014;
            for (_i1014 = 0; _i1014 < _size1010; ++_i1014)
            {
              xfer += this->multisig_signs[_i1014].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_bare_metal_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_bare_metal_req_data");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter1015;
    for (_iter1015 = this->peer_nodes_list.begin(); _iter1015 != this->peer_nodes_list.end(); ++_iter1015)
    {
      xfer += oprot->writeString((*_iter1015));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter1016;
    for (_iter1016 = this->multisig_wallets.begin(); _iter1016 != this->multisig_wallets.end(); ++_iter1016)
    {
      xfer += oprot->writeString((*_iter1016));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter1017;
    for (_iter1017 = this->multisig_signs.begin(); _iter1017 != this->multisig_signs.end(); ++_iter1017)
    {
      xfer += (*_iter1017).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_bare_metal_req_data &a, node_list_bare_metal_req_data &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_list_bare_metal_req_data::node_list_bare_metal_req_data(const node_list_bare_metal_req_data& other1018) {
  node_id = other1018.node_id;
  peer_nodes_list = other1018.peer_nodes_list;
  additional = other1018.additional;
  wallet = other1018.wallet;
  nonce = other1018.nonce;
  sign = other1018.sign;
  multisig_wallets = other1018.multisig_wallets;
  multisig_threshold = other1018.multisig_threshold;
  multisig_signs = other1018.multisig_signs;
  session_id = other1018.session_id;
  session_id_sign = other1018.session_id_sign;
  rent_order = other1018.rent_order;
  __isset = other1018.__isset;
}
node_list_bare_metal_req_data& node_list_bare_metal_req_data::operator=(const node_list_bare_metal_req_data& other1019) {
  node_id = other1019.node_id;
  peer_nodes_list = other1019.peer_nodes_list;
  additional = other1019.additional;
  wallet = other1019.wallet;
  nonce = other1019.nonce;
  sign = other1019.sign;
  multisig_wallets = other1019.multisig_wallets;
  multisig_threshold = other1019.multisig_threshold;
  multisig_signs = other1019.multisig_signs;
  session_id = other1019.session_id;
  session_id_sign = other1019.session_id_sign;
  rent_order = other1019.rent_order;
  __isset = other1019.__isset;
  return *this;
}
void node_list_bare_metal_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_bare_metal_req_data(";
  out << "node_id=" << to_string(node_id);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_list_bare_metal_req_body::~node_list_bare_metal_req_body() noexcept {
}


void node_list_bare_metal_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_bare_metal_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_bare_metal_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_bare_metal_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_bare_metal_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_bare_metal_req_body &a, node_list_bare_metal_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_bare_metal_req_body::node_list_bare_metal_req_body(const node_list_bare_metal_req_body& other1020) {
  data = other1020.data;
}
node_list_bare_metal_req_body& node_list_bare_metal_req_body::operator=(const node_list_bare_metal_req_body& other1021) {
  data = other1021.data;
  return *this;
}
void node_list_bare_metal_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_bare_metal_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_bare_metal_req::~node_list_bare_metal_req() noexcept {
}


void node_list_bare_metal_req::__set_body(const node_list_bare_metal_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_bare_metal_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_bare_metal_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_bare_metal_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_bare_metal_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_bare_metal_req &a, node_list_bare_metal_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_bare_metal_req::node_list_bare_metal_req(const node_list_bare_metal_req& other1022) {
  body = other1022.body;
  __isset = other1022.__isset;
}
node_list_bare_metal_req& node_list_bare_metal_req::operator=(const node_list_bare_metal_req& other1023) {
  body = other1023.body;
  __isset = other1023.__isset;
  return *this;
}
void node_list_bare_metal_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_bare_metal_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_bare_metal_rsp_body::~node_list_bare_metal_rsp_body() noexcept {
}


void node_list_bare_metal_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_bare_metal_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_bare_metal_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_bare_metal_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_bare_metal_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_bare_metal_rsp_body &a, node_list_bare_metal_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_bare_metal_rsp_body::node_list_bare_metal_rsp_body(const node_list_bare_metal_rsp_body& other1024) {
  data = other1024.data;
}
node_list_bare_metal_rsp_body& node_list_bare_metal_rsp_body::operator=(const node_list_bare_metal_rsp_body& other1025) {
  data = other1025.data;
  return *this;
}
void node_list_bare_metal_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_bare_metal_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_bare_metal_rsp::~node_list_bare_metal_rsp() noexcept {
}


void node_list_bare_metal_rsp::__set_body(const node_list_bare_metal_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_bare_metal_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_bare_metal_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_bare_metal_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_bare_metal_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_bare_metal_rsp &a, node_list_bare_metal_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_bare_metal_rsp::node_list_bare_metal_rsp(const node_list_bare_metal_rsp& other1026) {
  body = other1026.body;
  __isset = other1026.__isset;
}
node_list_bare_metal_rsp& node_list_bare_metal_rsp::operator=(const node_list_bare_metal_rsp& other1027) {
  body = other1027.body;
  __isset = other1027.__isset;
  return *this;
}
void node_list_bare_metal_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_bare_metal_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_add_bare_metal_req_data::~node_add_bare_metal_req_data() noexcept {
}


void node_add_bare_metal_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_add_bare_metal_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_add_bare_metal_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_add_bare_metal_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_add_bare_metal_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_add_bare_metal_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_add_bare_metal_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_add_bare_metal_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_add_bare_metal_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_add_bare_metal_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_add_bare_metal_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_add_bare_metal_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_add_bare_metal_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size1028;
            ::apache::thrift::protocol::TType _etype1031;
            xfer += iprot->readListBegin(_etype1031, _size1028);
            this->peer_nodes_list.resize(_size1028);
            uint32_t _i1032;
            for (_i1032 = 0; _i1032 < _size1028; ++_i1032)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i1032]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size1033;
            ::apache::thrift::protocol::TType _etype1036;
            xfer += iprot->readListBegin(_etype1036, _size1033);
            this->multisig_wallets.resize(_size1033);
            uint32_t _i1037;
            for (_i1037 = 0; _i1037 < _size1033; ++_i1037)
            {
              xfer += iprot->readString(this->multisig_wallets[_i1037]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size1038;
            ::apache::thrift::protocol::TType _etype1041;
            xfer += iprot->readListBegin(_etype1041, _size1038);
            this->multisig_signs.resize(_size1038);
            uint32_t _i1042;
            for (_i1042 = 0; _i1042 < _size1038; ++_i1042)
            {
              xfer += this->multisig_signs[_i1042].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_add_bare_metal_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_add_bare_metal_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter1043;
    for (_iter1043 = this->peer_nodes_list.begin(); _iter1043 != this->peer_nodes_list.end(); ++_iter1043)
    {
      xfer += oprot->writeString((*_iter1043));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter1044;
    for (_iter1044 = this->multisig_wallets.begin(); _iter1044 != this->multisig_wallets.end(); ++_iter1044)
    {
      xfer += oprot->writeString((*_iter1044));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter1045;
    for (_iter1045 = this->multisig_signs.begin(); _iter1045 != this->multisig_signs.end(); ++_iter1045)
    {
      xfer += (*_iter1045).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_add_bare_metal_req_data &a, node_add_bare_metal_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_add_bare_metal_req_data::node_add_bare_metal_req_data(const node_add_bare_metal_req_data& other1046) {
  peer_nodes_list = other1046.peer_nodes_list;
  additional = other1046.additional;
  wallet = other1046.wallet;
  nonce = other1046.nonce;
  sign = other1046.sign;
  multisig_wallets = other1046.multisig_wallets;
  multisig_threshold = other1046.multisig_threshold;
  multisig_signs = other1046.multisig_signs;
  session_id = other1046.session_id;
  session_id_sign = other1046.session_id_sign;
  rent_order = other1046.rent_order;
  __isset = other1046.__isset;
}
node_add_bare_metal_req_data& node_add_bare_metal_req_data::operator=(const node_add_bare_metal_req_data& other1047) {
  peer_nodes_list = other1047.peer_nodes_list;
  additional = other1047.additional;
  wallet = other1047.wallet;
  nonce = other1047.nonce;
  sign = other1047.sign;
  multisig_wallets = other1047.multisig_wallets;
  multisig_threshold = other1047.multisig_threshold;
  multisig_signs = other1047.multisig_signs;
  session_id = other1047.session_id;
  session_id_sign = other1047.session_id_sign;
  rent_order = other1047.rent_order;
  __isset = other1047.__isset;
  return *this;
}
void node_add_bare_metal_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_add_bare_metal_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_add_bare_metal_req_body::~node_add_bare_metal_req_body() noexcept {
}


void node_add_bare_metal_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_add_bare_metal_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_add_bare_metal_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_add_bare_metal_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_add_bare_metal_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_add_bare_metal_req_body &a, node_add_bare_metal_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_add_bare_metal_req_body::node_add_bare_metal_req_body(const node_add_bare_metal_req_body& other1048) {
  data = other1048.data;
}
node_add_bare_metal_req_body& node_add_bare_metal_req_body::operator=(const node_add_bare_metal_req_body& other1049) {
  data = other1049.data;
  return *this;
}
void node_add_bare_metal_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_add_bare_metal_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_add_bare_metal_req::~node_add_bare_metal_req() noexcept {
}


void node_add_bare_metal_req::__set_body(const node_add_bare_metal_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_add_bare_metal_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_add_bare_metal_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_add_bare_metal_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_add_bare_metal_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_add_bare_metal_req &a, node_add_bare_metal_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_add_bare_metal_req::node_add_bare_metal_req(const node_add_bare_metal_req& other1050) {
  body = other1050.body;
  __isset = other1050.__isset;
}
node_add_bare_metal_req& node_add_bare_metal_req::operator=(const node_add_bare_metal_req& other1051) {
  body = other1051.body;
  __isset = other1051.__isset;
  return *this;
}
void node_add_bare_metal_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_add_bare_metal_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_add_bare_metal_rsp_body::~node_add_bare_metal_rsp_body() noexcept {
}


void node_add_bare_metal_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_add_bare_metal_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_add_bare_metal_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_add_bare_metal_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_add_bare_metal_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_add_bare_metal_rsp_body &a, node_add_bare_metal_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_add_bare_metal_rsp_body::node_add_bare_metal_rsp_body(const node_add_bare_metal_rsp_body& other1052) {
  data = other1052.data;
}
node_add_bare_metal_rsp_body& node_add_bare_metal_rsp_body::operator=(const node_add_bare_metal_rsp_body& other1053) {
  data = other1053.data;
  return *this;
}
void node_add_bare_metal_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_add_bare_metal_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_add_bare_metal_rsp::~node_add_bare_metal_rsp() noexcept {
}


void node_add_bare_metal_rsp::__set_body(const node_add_bare_metal_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_add_bare_metal_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_add_bare_metal_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_add_bare_metal_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_add_bare_metal_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_add_bare_metal_rsp &a, node_add_bare_metal_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_add_bare_metal_rsp::node_add_bare_metal_rsp(const node_add_bare_metal_rsp& other1054) {
  body = other1054.body;
  __isset = other1054.__isset;
}
node_add_bare_metal_rsp& node_add_bare_metal_rsp::operator=(const node_add_bare_metal_rsp& other1055) {
  body = other1055.body;
  __isset = other1055.__isset;
  return *this;
}
void node_add_bare_metal_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_add_bare_metal_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_delete_bare_metal_req_data::~node_delete_bare_metal_req_data() noexcept {
}


void node_delete_bare_metal_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_delete_bare_metal_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_delete_bare_metal_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_delete_bare_metal_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_delete_bare_metal_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_delete_bare_metal_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_delete_bare_metal_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_delete_bare_metal_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_delete_bare_metal_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_delete_bare_metal_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_delete_bare_metal_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_delete_bare_metal_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_bare_metal_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size1056;
            ::apache::thrift::protocol::TType _etype1059;
            xfer += iprot->readListBegin(_etype1059, _size1056);
            this->peer_nodes_list.resize(_size1056);
            uint32_t _i1060;
            for (_i1060 = 0; _i1060 < _size1056; ++_i1060)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i1060]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size1061;
            ::apache::thrift::protocol::TType _etype1064;
            xfer += iprot->readListBegin(_etype1064, _size1061);
            this->multisig_wallets.resize(_size1061);
            uint32_t _i1065;
            for (_i1065 = 0; _i1065 < _size1061; ++_i1065)
            {
              xfer += iprot->readString(this->multisig_wallets[_i1065]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size1066;
            ::apache::thrift::protocol::TType _etype1069;
            xfer += iprot->readListBegin(_etype1069, _size1066);
            this->multisig_signs.resize(_size1066);
            uint32_t _i1070;
            for (_i1070 = 0; _i1070 < _size1066; ++_i1070)
            {
              xfer += this->multisig_signs[_i1070].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_bare_metal_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_bare_metal_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter1071;
    for (_iter1071 = this->peer_nodes_list.begin(); _iter1071 != this->peer_nodes_list.end(); ++_iter1071)
    {
      xfer += oprot->writeString((*_iter1071));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter1072;
    for (_iter1072 = this->multisig_wallets.begin(); _iter1072 != this->multisig_wallets.end(); ++_iter1072)
    {
      xfer += oprot->writeString((*_iter1072));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter1073;
    for (_iter1073 = this->multisig_signs.begin(); _iter1073 != this->multisig_signs.end(); ++_iter1073)
    {
      xfer += (*_iter1073).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_bare_metal_req_data &a, node_delete_bare_metal_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_delete_bare_metal_req_data::node_delete_bare_metal_req_data(const node_delete_bare_metal_req_data& other1074) {
  peer_nodes_list = other1074.peer_nodes_list;
  additional = other1074.additional;
  wallet = other1074.wallet;
  nonce = other1074.nonce;
  sign = other1074.sign;
  multisig_wallets = other1074.multisig_wallets;
  multisig_threshold = other1074.multisig_threshold;
  multisig_signs = other1074.multisig_signs;
  session_id = other1074.session_id;
  session_id_sign = other1074.session_id_sign;
  rent_order = other1074.rent_order;
  __isset = other1074.__isset;
}
node_delete_bare_metal_req_data& node_delete_bare_metal_req_data::operator=(const node_delete_bare_metal_req_data& other1075) {
  peer_nodes_list = other1075.peer_nodes_list;
  additional = other1075.additional;
  wallet = other1075.wallet;
  nonce = other1075.nonce;
  sign = other1075.sign;
  multisig_wallets = other1075.multisig_wallets;
  multisig_threshold = other1075.multisig_threshold;
  multisig_signs = other1075.multisig_signs;
  session_id = other1075.session_id;
  session_id_sign = other1075.session_id_sign;
  rent_order = other1075.rent_order;
  __isset = other1075.__isset;
  return *this;
}
void node_delete_bare_metal_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_bare_metal_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_delete_bare_metal_req_body::~node_delete_bare_metal_req_body() noexcept {
}


void node_delete_bare_metal_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_bare_metal_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_bare_metal_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_bare_metal_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_bare_metal_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_bare_metal_req_body &a, node_delete_bare_metal_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_delete_bare_metal_req_body::node_delete_bare_metal_req_body(const node_delete_bare_metal_req_body& other1076) {
  data = other1076.data;
}
node_delete_bare_metal_req_body& node_delete_bare_metal_req_body::operator=(const node_delete_bare_metal_req_body& other1077) {
  data = other1077.data;
  return *this;
}
void node_delete_bare_metal_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_bare_metal_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_delete_bare_metal_req::~node_delete_bare_metal_req() noexcept {
}


void node_delete_bare_metal_req::__set_body(const node_delete_bare_metal_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_bare_metal_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_bare_metal_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_delete_bare_metal_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_bare_metal_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_bare_metal_req &a, node_delete_bare_metal_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_delete_bare_metal_req::node_delete_bare_metal_req(const node_delete_bare_metal_req& other1078) {
  body = other1078.body;
  __isset = other1078.__isset;
}
node_delete_bare_metal_req& node_delete_bare_metal_req::operator=(const node_delete_bare_metal_req& other1079) {
  body = other1079.body;
  __isset = other1079.__isset;
  return *this;
}
void node_delete_bare_metal_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_bare_metal_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_delete_bare_metal_rsp_body::~node_delete_bare_metal_rsp_body() noexcept {
}


void node_delete_bare_metal_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_bare_metal_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_bare_metal_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_delete_bare_metal_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_bare_metal_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_bare_metal_rsp_body &a, node_delete_bare_metal_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_delete_bare_metal_rsp_body::node_delete_bare_metal_rsp_body(const node_delete_bare_metal_rsp_body& other1080) {
  data = other1080.data;
}
node_delete_bare_metal_rsp_body& node_delete_bare_metal_rsp_body::operator=(const node_delete_bare_metal_rsp_body& other1081) {
  data = other1081.data;
  return *this;
}
void node_delete_bare_metal_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_bare_metal_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_delete_bare_metal_rsp::~node_delete_bare_metal_rsp() noexcept {
}


void node_delete_bare_metal_rsp::__set_body(const node_delete_bare_metal_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_delete_bare_metal_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_delete_bare_metal_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_delete_bare_metal_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_delete_bare_metal_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_delete_bare_metal_rsp &a, node_delete_bare_metal_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_delete_bare_metal_rsp::node_delete_bare_metal_rsp(const node_delete_bare_metal_rsp& other1082) {
  body = other1082.body;
  __isset = other1082.__isset;
}
node_delete_bare_metal_rsp& node_delete_bare_metal_rsp::operator=(const node_delete_bare_metal_rsp& other1083) {
  body = other1083.body;
  __isset = other1083.__isset;
  return *this;
}
void node_delete_bare_metal_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_delete_bare_metal_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_bare_metal_power_req_data::~node_bare_metal_power_req_data() noexcept {
}


void node_bare_metal_power_req_data::__set_command(const std::string& val) {
  this->command = val;
}

void node_bare_metal_power_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_bare_metal_power_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_bare_metal_power_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_bare_metal_power_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_bare_metal_power_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_bare_metal_power_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_bare_metal_power_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_bare_metal_power_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_bare_metal_power_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_bare_metal_power_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_bare_metal_power_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_bare_metal_power_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_bare_metal_power_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_command = false;
  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->command);
          isset_command = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size1084;
            ::apache::thrift::protocol::TType _etype1087;
            xfer += iprot->readListBegin(_etype1087, _size1084);
            this->peer_nodes_list.resize(_size1084);
            uint32_t _i1088;
            for (_i1088 = 0; _i1088 < _size1084; ++_i1088)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i1088]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size1089;
            ::apache::thrift::protocol::TType _etype1092;
            xfer += iprot->readListBegin(_etype1092, _size1089);
            this->multisig_wallets.resize(_size1089);
            uint32_t _i1093;
            for (_i1093 = 0; _i1093 < _size1089; ++_i1093)
            {
              xfer += iprot->readString(this->multisig_wallets[_i1093]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size1094;
            ::apache::thrift::protocol::TType _etype1097;
            xfer += iprot->readListBegin(_etype1097, _size1094);
            this->multisig_signs.resize(_size1094);
            uint32_t _i1098;
            for (_i1098 = 0; _i1098 < _size1094; ++_i1098)
            {
              xfer += this->multisig_signs[_i1098].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_command)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_bare_metal_power_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_bare_metal_power_req_data");

  xfer += oprot->writeFieldBegin("command", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->command);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter1099;
    for (_iter1099 = this->peer_nodes_list.begin(); _iter1099 != this->peer_nodes_list.end(); ++_iter1099)
    {
      xfer += oprot->writeString((*_iter1099));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter1100;
    for (_iter1100 = this->multisig_wallets.begin(); _iter1100 != this->multisig_wallets.end(); ++_iter1100)
    {
      xfer += oprot->writeString((*_iter1100));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter1101;
    for (_iter1101 = this->multisig_signs.begin(); _iter1101 != this->multisig_signs.end(); ++_iter1101)
    {
      xfer += (*_iter1101).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_bare_metal_power_req_data &a, node_bare_metal_power_req_data &b) {
  using ::std::swap;
  swap(a.command, b.command);
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_bare_metal_power_req_data::node_bare_metal_power_req_data(const node_bare_metal_power_req_data& other1102) {
  command = other1102.command;
  peer_nodes_list = other1102.peer_nodes_list;
  additional = other1102.additional;
  wallet = other1102.wallet;
  nonce = other1102.nonce;
  sign = other1102.sign;
  multisig_wallets = other1102.multisig_wallets;
  multisig_threshold = other1102.multisig_threshold;
  multisig_signs = other1102.multisig_signs;
  session_id = other1102.session_id;
  session_id_sign = other1102.session_id_sign;
  rent_order = other1102.rent_order;
  __isset = other1102.__isset;
}
node_bare_metal_power_req_data& node_bare_metal_power_req_data::operator=(const node_bare_metal_power_req_data& other1103) {
  command = other1103.command;
  peer_nodes_list = other1103.peer_nodes_list;
  additional = other1103.additional;
  wallet = other1103.wallet;
  nonce = other1103.nonce;
  sign = other1103.sign;
  multisig_wallets = other1103.multisig_wallets;
  multisig_threshold = other1103.multisig_threshold;
  multisig_signs = other1103.multisig_signs;
  session_id = other1103.session_id;
  session_id_sign = other1103.session_id_sign;
  rent_order = other1103.rent_order;
  __isset = other1103.__isset;
  return *this;
}
void node_bare_metal_power_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_bare_metal_power_req_data(";
  out << "command=" << to_string(command);
  out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_bare_metal_power_req_body::~node_bare_metal_power_req_body() noexcept {
}


void node_bare_metal_power_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_bare_metal_power_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_bare_metal_power_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_bare_metal_power_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_bare_metal_power_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_bare_metal_power_req_body &a, node_bare_metal_power_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_bare_metal_power_req_body::node_bare_metal_power_req_body(const node_bare_metal_power_req_body& other1104) {
  data = other1104.data;
}
node_bare_metal_power_req_body& node_bare_metal_power_req_body::operator=(const node_bare_metal_power_req_body& other1105) {
  data = other1105.data;
  return *this;
}
void node_bare_metal_power_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_bare_metal_power_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_bare_metal_power_req::~node_bare_metal_power_req() noexcept {
}


void node_bare_metal_power_req::__set_body(const node_bare_metal_power_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_bare_metal_power_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_bare_metal_power_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_bare_metal_power_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_bare_metal_power_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_bare_metal_power_req &a, node_bare_metal_power_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_bare_metal_power_req::node_bare_metal_power_req(const node_bare_metal_power_req& other1106) {
  body = other1106.body;
  __isset = other1106.__isset;
}
node_bare_metal_power_req& node_bare_metal_power_req::operator=(const node_bare_metal_power_req& other1107) {
  body = other1107.body;
  __isset = other1107.__isset;
  return *this;
}
void node_bare_metal_power_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_bare_metal_power_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_bare_metal_power_rsp_body::~node_bare_metal_power_rsp_body() noexcept {
}


void node_bare_metal_power_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_bare_metal_power_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_bare_metal_power_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_bare_metal_power_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_bare_metal_power_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_bare_metal_power_rsp_body &a, node_bare_metal_power_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_bare_metal_power_rsp_body::node_bare_metal_power_rsp_body(const node_bare_metal_power_rsp_body& other1108) {
  data = other1108.data;
}
node_bare_metal_power_rsp_body& node_bare_metal_power_rsp_body::operator=(const node_bare_metal_power_rsp_body& other1109) {
  data = other1109.data;
  return *this;
}
void node_bare_metal_power_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_bare_metal_power_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_bare_metal_power_rsp::~node_bare_metal_power_rsp() noexcept {
}


void node_bare_metal_power_rsp::__set_body(const node_bare_metal_power_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_bare_metal_power_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_bare_metal_power_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_bare_metal_power_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_bare_metal_power_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_bare_metal_power_rsp &a, node_bare_metal_power_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_bare_metal_power_rsp::node_bare_metal_power_rsp(const node_bare_metal_power_rsp& other1110) {
  body = other1110.body;
  __isset = other1110.__isset;
}
node_bare_metal_power_rsp& node_bare_metal_power_rsp::operator=(const node_bare_metal_power_rsp& other1111) {
  body = other1111.body;
  __isset = other1111.__isset;
  return *this;
}
void node_bare_metal_power_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_bare_metal_power_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_bare_metal_bootdev_req_data::~node_bare_metal_bootdev_req_data() noexcept {
}


void node_bare_metal_bootdev_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_bare_metal_bootdev_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_bare_metal_bootdev_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_bare_metal_bootdev_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_bare_metal_bootdev_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_bare_metal_bootdev_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_bare_metal_bootdev_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_bare_metal_bootdev_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_bare_metal_bootdev_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_bare_metal_bootdev_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_bare_metal_bootdev_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_bare_metal_bootdev_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_bare_metal_bootdev_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size1112;
            ::apache::thrift::protocol::TType _etype1115;
            xfer += iprot->readListBegin(_etype1115, _size1112);
            this->peer_nodes_list.resize(_size1112);
            uint32_t _i1116;
            for (_i1116 = 0; _i1116 < _size1112; ++_i1116)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i1116]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size1117;
            ::apache::thrift::protocol::TType _etype1120;
            xfer += iprot->readListBegin(_etype1120, _size1117);
            this->multisig_wallets.resize(_size1117);
            uint32_t _i1121;
            for (_i1121 = 0; _i1121 < _size1117; ++_i1121)
            {
              xfer += iprot->readString(this->multisig_wallets[_i1121]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size1122;
            ::apache::thrift::protocol::TType _etype1125;
            xfer += iprot->readListBegin(_etype1125, _size1122);
            this->multisig_signs.resize(_size1122);
            uint32_t _i1126;
            for (_i1126 = 0; _i1126 < _size1122; ++_i1126)
            {
              xfer += this->multisig_signs[_i1126].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_bare_metal_bootdev_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_bare_metal_bootdev_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter1127;
    for (_iter1127 = this->peer_nodes_list.begin(); _iter1127 != this->peer_nodes_list.end(); ++_iter1127)
    {
      xfer += oprot->writeString((*_iter1127));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter1128;
    for (_iter1128 = this->multisig_wallets.begin(); _iter1128 != this->multisig_wallets.end(); ++_iter1128)
    {
      xfer += oprot->writeString((*_iter1128));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter1129;
    for (_iter1129 = this->multisig_signs.begin(); _iter1129 != this->multisig_signs.end(); ++_iter1129)
    {
      xfer += (*_iter1129).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_bare_metal_bootdev_req_data &a, node_bare_metal_bootdev_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_bare_metal_bootdev_req_data::node_bare_metal_bootdev_req_data(const node_bare_metal_bootdev_req_data& other1130) {
  peer_nodes_list = other1130.peer_nodes_list;
  additional = other1130.additional;
  wallet = other1130.wallet;
  nonce = other1130.nonce;
  sign = other1130.sign;
  multisig_wallets = other1130.multisig_wallets;
  multisig_threshold = other1130.multisig_threshold;
  multisig_signs = other1130.multisig_signs;
  session_id = other1130.session_id;
  session_id_sign = other1130.session_id_sign;
  rent_order = other1130.rent_order;
  __isset = other1130.__isset;
}
node_bare_metal_bootdev_req_data& node_bare_metal_bootdev_req_data::operator=(const node_bare_metal_bootdev_req_data& other1131) {
  peer_nodes_list = other1131.peer_nodes_list;
  additional = other1131.additional;
  wallet = other1131.wallet;
  nonce = other1131.nonce;
  sign = other1131.sign;
  multisig_wallets = other1131.multisig_wallets;
  multisig_threshold = other1131.multisig_threshold;
  multisig_signs = other1131.multisig_signs;
  session_id = other1131.session_id;
  session_id_sign = other1131.session_id_sign;
  rent_order = other1131.rent_order;
  __isset = other1131.__isset;
  return *this;
}
void node_bare_metal_bootdev_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_bare_metal_bootdev_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_bare_metal_bootdev_req_body::~node_bare_metal_bootdev_req_body() noexcept {
}


void node_bare_metal_bootdev_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_bare_metal_bootdev_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_bare_metal_bootdev_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_bare_metal_bootdev_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_bare_metal_bootdev_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_bare_metal_bootdev_req_body &a, node_bare_metal_bootdev_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_bare_metal_bootdev_req_body::node_bare_metal_bootdev_req_body(const node_bare_metal_bootdev_req_body& other1132) {
  data = other1132.data;
}
node_bare_metal_bootdev_req_body& node_bare_metal_bootdev_req_body::operator=(const node_bare_metal_bootdev_req_body& other1133) {
  data = other1133.data;
  return *this;
}
void node_bare_metal_bootdev_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_bare_metal_bootdev_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_bare_metal_bootdev_req::~node_bare_metal_bootdev_req() noexcept {
}


void node_bare_metal_bootdev_req::__set_body(const node_bare_metal_bootdev_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_bare_metal_bootdev_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_bare_metal_bootdev_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_bare_metal_bootdev_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_bare_metal_bootdev_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_bare_metal_bootdev_req &a, node_bare_metal_bootdev_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_bare_metal_bootdev_req::node_bare_metal_bootdev_req(const node_bare_metal_bootdev_req& other1134) {
  body = other1134.body;
  __isset = other1134.__isset;
}
node_bare_metal_bootdev_req& node_bare_metal_bootdev_req::operator=(const node_bare_metal_bootdev_req& other1135) {
  body = other1135.body;
  __isset = other1135.__isset;
  return *this;
}
void node_bare_metal_bootdev_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_bare_metal_bootdev_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_bare_metal_bootdev_rsp_body::~node_bare_metal_bootdev_rsp_body() noexcept {
}


void node_bare_metal_bootdev_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_bare_metal_bootdev_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_bare_metal_bootdev_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_bare_metal_bootdev_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_bare_metal_bootdev_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_bare_metal_bootdev_rsp_body &a, node_bare_metal_bootdev_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_bare_metal_bootdev_rsp_body::node_bare_metal_bootdev_rsp_body(const node_bare_metal_bootdev_rsp_body& other1136) {
  data = other1136.data;
}
node_bare_metal_bootdev_rsp_body& node_bare_metal_bootdev_rsp_body::operator=(const node_bare_metal_bootdev_rsp_body& other1137) {
  data = other1137.data;
  return *this;
}
void node_bare_metal_bootdev_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_bare_metal_bootdev_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_bare_metal_bootdev_rsp::~node_bare_metal_bootdev_rsp() noexcept {
}


void node_bare_metal_bootdev_rsp::__set_body(const node_bare_metal_bootdev_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_bare_metal_bootdev_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_bare_metal_bootdev_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_bare_metal_bootdev_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_bare_metal_bootdev_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_bare_metal_bootdev_rsp &a, node_bare_metal_bootdev_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_bare_metal_bootdev_rsp::node_bare_metal_bootdev_rsp(const node_bare_metal_bootdev_rsp& other1138) {
  body = other1138.body;
  __isset = other1138.__isset;
}
node_bare_metal_bootdev_rsp& node_bare_metal_bootdev_rsp::operator=(const node_bare_metal_bootdev_rsp& other1139) {
  body = other1139.body;
  __isset = other1139.__isset;
  return *this;
}
void node_bare_metal_bootdev_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_bare_metal_bootdev_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_deeplink_info_req_data::~node_list_deeplink_info_req_data() throw() {
}


void node_list_deeplink_info_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_list_deeplink_info_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_list_deeplink_info_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_list_deeplink_info_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_list_deeplink_info_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_list_deeplink_info_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_list_deeplink_info_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_list_deeplink_info_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_list_deeplink_info_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_list_deeplink_info_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_list_deeplink_info_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_list_deeplink_info_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_deeplink_info_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size1140;
            ::apache::thrift::protocol::TType _etype1143;
            xfer += iprot->readListBegin(_etype1143, _size1140);
            this->peer_nodes_list.resize(_size1140);
            uint32_t _i1144;
            for (_i1144 = 0; _i1144 < _size1140; ++_i1144)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i1144]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size1145;
            ::apache::thrift::protocol::TType _etype1148;
            xfer += iprot->readListBegin(_etype1148, _size1145);
            this->multisig_wallets.resize(_size1145);
            uint32_t _i1149;
            for (_i1149 = 0; _i1149 < _size1145; ++_i1149)
            {
              xfer += iprot->readString(this->multisig_wallets[_i1149]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size1150;
            ::apache::thrift::protocol::TType _etype1153;
            xfer += iprot->readListBegin(_etype1153, _size1150);
            this->multisig_signs.resize(_size1150);
            uint32_t _i1154;
            for (_i1154 = 0; _i1154 < _size1150; ++_i1154)
            {
              xfer += this->multisig_signs[_i1154].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_deeplink_info_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_deeplink_info_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter1155;
    for (_iter1155 = this->peer_nodes_list.begin(); _iter1155 != this->peer_nodes_list.end(); ++_iter1155)
    {
      xfer += oprot->writeString((*_iter1155));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter1156;
    for (_iter1156 = this->multisig_wallets.begin(); _iter1156 != this->multisig_wallets.end(); ++_iter1156)
    {
      xfer += oprot->writeString((*_iter1156));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter1157;
    for (_iter1157 = this->multisig_signs.begin(); _iter1157 != this->multisig_signs.end(); ++_iter1157)
    {
      xfer += (*_iter1157).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_deeplink_info_req_data &a, node_list_deeplink_info_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_list_deeplink_info_req_data::node_list_deeplink_info_req_data(const node_list_deeplink_info_req_data& other1158) {
  peer_nodes_list = other1158.peer_nodes_list;
  additional = other1158.additional;
  wallet = other1158.wallet;
  nonce = other1158.nonce;
  sign = other1158.sign;
  multisig_wallets = other1158.multisig_wallets;
  multisig_threshold = other1158.multisig_threshold;
  multisig_signs = other1158.multisig_signs;
  session_id = other1158.session_id;
  session_id_sign = other1158.session_id_sign;
  rent_order = other1158.rent_order;
  __isset = other1158.__isset;
}
node_list_deeplink_info_req_data& node_list_deeplink_info_req_data::operator=(const node_list_deeplink_info_req_data& other1159) {
  peer_nodes_list = other1159.peer_nodes_list;
  additional = other1159.additional;
  wallet = other1159.wallet;
  nonce = other1159.nonce;
  sign = other1159.sign;
  multisig_wallets = other1159.multisig_wallets;
  multisig_threshold = other1159.multisig_threshold;
  multisig_signs = other1159.multisig_signs;
  session_id = other1159.session_id;
  session_id_sign = other1159.session_id_sign;
  rent_order = other1159.rent_order;
  __isset = other1159.__isset;
  return *this;
}
void node_list_deeplink_info_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_deeplink_info_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_list_deeplink_info_req_body::~node_list_deeplink_info_req_body() throw() {
}


void node_list_deeplink_info_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_deeplink_info_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_deeplink_info_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_deeplink_info_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_deeplink_info_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_deeplink_info_req_body &a, node_list_deeplink_info_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_deeplink_info_req_body::node_list_deeplink_info_req_body(const node_list_deeplink_info_req_body& other1160) {
  data = other1160.data;
}
node_list_deeplink_info_req_body& node_list_deeplink_info_req_body::operator=(const node_list_deeplink_info_req_body& other1161) {
  data = other1161.data;
  return *this;
}
void node_list_deeplink_info_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_deeplink_info_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_deeplink_info_req::~node_list_deeplink_info_req() throw() {
}


void node_list_deeplink_info_req::__set_body(const node_list_deeplink_info_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_deeplink_info_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_deeplink_info_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_deeplink_info_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_deeplink_info_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_deeplink_info_req &a, node_list_deeplink_info_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_deeplink_info_req::node_list_deeplink_info_req(const node_list_deeplink_info_req& other1162) {
  body = other1162.body;
  __isset = other1162.__isset;
}
node_list_deeplink_info_req& node_list_deeplink_info_req::operator=(const node_list_deeplink_info_req& other1163) {
  body = other1163.body;
  __isset = other1163.__isset;
  return *this;
}
void node_list_deeplink_info_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_deeplink_info_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_list_deeplink_info_rsp_body::~node_list_deeplink_info_rsp_body() throw() {
}


void node_list_deeplink_info_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_deeplink_info_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_deeplink_info_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_list_deeplink_info_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_deeplink_info_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_deeplink_info_rsp_body &a, node_list_deeplink_info_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_list_deeplink_info_rsp_body::node_list_deeplink_info_rsp_body(const node_list_deeplink_info_rsp_body& other1164) {
  data = other1164.data;
}
node_list_deeplink_info_rsp_body& node_list_deeplink_info_rsp_body::operator=(const node_list_deeplink_info_rsp_body& other1165) {
  data = other1165.data;
  return *this;
}
void node_list_deeplink_info_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_deeplink_info_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_list_deeplink_info_rsp::~node_list_deeplink_info_rsp() throw() {
}


void node_list_deeplink_info_rsp::__set_body(const node_list_deeplink_info_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_list_deeplink_info_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_list_deeplink_info_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_list_deeplink_info_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_list_deeplink_info_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_list_deeplink_info_rsp &a, node_list_deeplink_info_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_list_deeplink_info_rsp::node_list_deeplink_info_rsp(const node_list_deeplink_info_rsp& other1166) {
  body = other1166.body;
  __isset = other1166.__isset;
}
node_list_deeplink_info_rsp& node_list_deeplink_info_rsp::operator=(const node_list_deeplink_info_rsp& other1167) {
  body = other1167.body;
  __isset = other1167.__isset;
  return *this;
}
void node_list_deeplink_info_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_list_deeplink_info_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}


node_set_deeplink_info_req_data::~node_set_deeplink_info_req_data() throw() {
}


void node_set_deeplink_info_req_data::__set_peer_nodes_list(const std::vector<std::string> & val) {
  this->peer_nodes_list = val;
}

void node_set_deeplink_info_req_data::__set_additional(const std::string& val) {
  this->additional = val;
}

void node_set_deeplink_info_req_data::__set_wallet(const std::string& val) {
  this->wallet = val;
}

void node_set_deeplink_info_req_data::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void node_set_deeplink_info_req_data::__set_sign(const std::string& val) {
  this->sign = val;
}

void node_set_deeplink_info_req_data::__set_multisig_wallets(const std::vector<std::string> & val) {
  this->multisig_wallets = val;
}

void node_set_deeplink_info_req_data::__set_multisig_threshold(const int32_t val) {
  this->multisig_threshold = val;
}

void node_set_deeplink_info_req_data::__set_multisig_signs(const std::vector<multisig_sign_item> & val) {
  this->multisig_signs = val;
}

void node_set_deeplink_info_req_data::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void node_set_deeplink_info_req_data::__set_session_id_sign(const std::string& val) {
  this->session_id_sign = val;
}

void node_set_deeplink_info_req_data::__set_rent_order(const std::string& val) {
  this->rent_order = val;
__isset.rent_order = true;
}
std::ostream& operator<<(std::ostream& out, const node_set_deeplink_info_req_data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_set_deeplink_info_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_peer_nodes_list = false;
  bool isset_additional = false;
  bool isset_wallet = false;
  bool isset_nonce = false;
  bool isset_sign = false;
  bool isset_multisig_wallets = false;
  bool isset_multisig_threshold = false;
  bool isset_multisig_signs = false;
  bool isset_session_id = false;
  bool isset_session_id_sign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peer_nodes_list.clear();
            uint32_t _size1168;
            ::apache::thrift::protocol::TType _etype1171;
            xfer += iprot->readListBegin(_etype1171, _size1168);
            this->peer_nodes_list.resize(_size1168);
            uint32_t _i1172;
            for (_i1172 = 0; _i1172 < _size1168; ++_i1172)
            {
              xfer += iprot->readString(this->peer_nodes_list[_i1172]);
            }
            xfer += iprot->readListEnd();
          }
          isset_peer_nodes_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->additional);
          isset_additional = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wallet);
          isset_wallet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign);
          isset_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_wallets.clear();
            uint32_t _size1173;
            ::apache::thrift::protocol::TType _etype1176;
            xfer += iprot->readListBegin(_etype1176, _size1173);
            this->multisig_wallets.resize(_size1173);
            uint32_t _i1177;
            for (_i1177 = 0; _i1177 < _size1173; ++_i1177)
            {
              xfer += iprot->readString(this->multisig_wallets[_i1177]);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_wallets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->multisig_threshold);
          isset_multisig_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->multisig_signs.clear();
            uint32_t _size1178;
            ::apache::thrift::protocol::TType _etype1181;
            xfer += iprot->readListBegin(_etype1181, _size1178);
            this->multisig_signs.resize(_size1178);
            uint32_t _i1182;
            for (_i1182 = 0; _i1182 < _size1178; ++_i1182)
            {
              xfer += this->multisig_signs[_i1182].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_multisig_signs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          isset_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id_sign);
          isset_session_id_sign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rent_order);
          this->__isset.rent_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_peer_nodes_list)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_additional)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_wallet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_wallets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_multisig_signs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session_id_sign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_set_deeplink_info_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_set_deeplink_info_req_data");

  xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
    std::vector<std::string> ::const_iterator _iter1183;
    for (_iter1183 = this->peer_nodes_list.begin(); _iter1183 != this->peer_nodes_list.end(); ++_iter1183)
    {
      xfer += oprot->writeString((*_iter1183));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->additional);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->wallet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
    std::vector<std::string> ::const_iterator _iter1184;
    for (_iter1184 = this->multisig_wallets.begin(); _iter1184 != this->multisig_wallets.end(); ++_iter1184)
    {
      xfer += oprot->writeString((*_iter1184));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->multisig_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
    std::vector<multisig_sign_item> ::const_iterator _iter1185;
    for (_iter1185 = this->multisig_signs.begin(); _iter1185 != this->multisig_signs.end(); ++_iter1185)
    {
      xfer += (*_iter1185).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->session_id_sign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rent_order) {
    xfer += oprot->writeFieldBegin("rent_order", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->rent_order);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_set_deeplink_info_req_data &a, node_set_deeplink_info_req_data &b) {
  using ::std::swap;
  swap(a.peer_nodes_list, b.peer_nodes_list);
  swap(a.additional, b.additional);
  swap(a.wallet, b.wallet);
  swap(a.nonce, b.nonce);
  swap(a.sign, b.sign);
  swap(a.multisig_wallets, b.multisig_wallets);
  swap(a.multisig_threshold, b.multisig_threshold);
  swap(a.multisig_signs, b.multisig_signs);
  swap(a.session_id, b.session_id);
  swap(a.session_id_sign, b.session_id_sign);
  swap(a.rent_order, b.rent_order);
  swap(a.__isset, b.__isset);
}

node_set_deeplink_info_req_data::node_set_deeplink_info_req_data(const node_set_deeplink_info_req_data& other1186) {
  peer_nodes_list = other1186.peer_nodes_list;
  additional = other1186.additional;
  wallet = other1186.wallet;
  nonce = other1186.nonce;
  sign = other1186.sign;
  multisig_wallets = other1186.multisig_wallets;
  multisig_threshold = other1186.multisig_threshold;
  multisig_signs = other1186.multisig_signs;
  session_id = other1186.session_id;
  session_id_sign = other1186.session_id_sign;
  rent_order = other1186.rent_order;
  __isset = other1186.__isset;
}
node_set_deeplink_info_req_data& node_set_deeplink_info_req_data::operator=(const node_set_deeplink_info_req_data& other1187) {
  peer_nodes_list = other1187.peer_nodes_list;
  additional = other1187.additional;
  wallet = other1187.wallet;
  nonce = other1187.nonce;
  sign = other1187.sign;
  multisig_wallets = other1187.multisig_wallets;
  multisig_threshold = other1187.multisig_threshold;
  multisig_signs = other1187.multisig_signs;
  session_id = other1187.session_id;
  session_id_sign = other1187.session_id_sign;
  rent_order = other1187.rent_order;
  __isset = other1187.__isset;
  return *this;
}
void node_set_deeplink_info_req_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_set_deeplink_info_req_data(";
  out << "peer_nodes_list=" << to_string(peer_nodes_list);
  out << ", " << "additional=" << to_string(additional);
  out << ", " << "wallet=" << to_string(wallet);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "sign=" << to_string(sign);
  out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
  out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
  out << ", " << "multisig_signs=" << to_string(multisig_signs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "session_id_sign=" << to_string(session_id_sign);
  out << ", " << "rent_order="; (__isset.rent_order ? (out << to_string(rent_order)) : (out << "<null>"));
  out << ")";
}


node_set_deeplink_info_req_body::~node_set_deeplink_info_req_body() throw() {
}


void node_set_deeplink_info_req_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_set_deeplink_info_req_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_set_deeplink_info_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_set_deeplink_info_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_set_deeplink_info_req_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_set_deeplink_info_req_body &a, node_set_deeplink_info_req_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_set_deeplink_info_req_body::node_set_deeplink_info_req_body(const node_set_deeplink_info_req_body& other1188) {
  data = other1188.data;
}
node_set_deeplink_info_req_body& node_set_deeplink_info_req_body::operator=(const node_set_deeplink_info_req_body& other1189) {
  data = other1189.data;
  return *this;
}
void node_set_deeplink_info_req_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_set_deeplink_info_req_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_set_deeplink_info_req::~node_set_deeplink_info_req() throw() {
}


void node_set_deeplink_info_req::__set_body(const node_set_deeplink_info_req_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_set_deeplink_info_req& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_set_deeplink_info_req::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_set_deeplink_info_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_set_deeplink_info_req");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_set_deeplink_info_req &a, node_set_deeplink_info_req &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_set_deeplink_info_req::node_set_deeplink_info_req(const node_set_deeplink_info_req& other1190) {
  body = other1190.body;
  __isset = other1190.__isset;
}
node_set_deeplink_info_req& node_set_deeplink_info_req::operator=(const node_set_deeplink_info_req& other1191) {
  body = other1191.body;
  __isset = other1191.__isset;
  return *this;
}
void node_set_deeplink_info_req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_set_deeplink_info_req(";
  out << "body=" << to_string(body);
  out << ")";
}


node_set_deeplink_info_rsp_body::~node_set_deeplink_info_rsp_body() throw() {
}


void node_set_deeplink_info_rsp_body::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const node_set_deeplink_info_rsp_body& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_set_deeplink_info_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t node_set_deeplink_info_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_set_deeplink_info_rsp_body");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_set_deeplink_info_rsp_body &a, node_set_deeplink_info_rsp_body &b) {
  using ::std::swap;
  swap(a.data, b.data);
}

node_set_deeplink_info_rsp_body::node_set_deeplink_info_rsp_body(const node_set_deeplink_info_rsp_body& other1192) {
  data = other1192.data;
}
node_set_deeplink_info_rsp_body& node_set_deeplink_info_rsp_body::operator=(const node_set_deeplink_info_rsp_body& other1193) {
  data = other1193.data;
  return *this;
}
void node_set_deeplink_info_rsp_body::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_set_deeplink_info_rsp_body(";
  out << "data=" << to_string(data);
  out << ")";
}


node_set_deeplink_info_rsp::~node_set_deeplink_info_rsp() throw() {
}


void node_set_deeplink_info_rsp::__set_body(const node_set_deeplink_info_rsp_body& val) {
  this->body = val;
}
std::ostream& operator<<(std::ostream& out, const node_set_deeplink_info_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t node_set_deeplink_info_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_set_deeplink_info_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_set_deeplink_info_rsp");

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->body.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_set_deeplink_info_rsp &a, node_set_deeplink_info_rsp &b) {
  using ::std::swap;
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

node_set_deeplink_info_rsp::node_set_deeplink_info_rsp(const node_set_deeplink_info_rsp& other1194) {
  body = other1194.body;
  __isset = other1194.__isset;
}
node_set_deeplink_info_rsp& node_set_deeplink_info_rsp::operator=(const node_set_deeplink_info_rsp& other1195) {
  body = other1195.body;
  __isset = other1195.__isset;
  return *this;
}
void node_set_deeplink_info_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_set_deeplink_info_rsp(";
  out << "body=" << to_string(body);
  out << ")";
}

} // namespace
