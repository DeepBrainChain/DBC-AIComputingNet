/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "matrix_types.h"

#include <algorithm>
#include <ostream>

namespace dbc {


    empty::~empty() throw() {
    }

    std::ostream& operator<<(std::ostream& out, const empty& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t empty::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            xfer += iprot->skip(ftype);
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t empty::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("empty");

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(empty& a, empty& b) {
        using ::std::swap;
        (void)a;
        (void)b;
    }

    empty::empty(const empty& other0) {
        (void)other0;
    }
    empty& empty::operator=(const empty& other1) {
        (void)other1;
        return *this;
    }
    void empty::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "empty(";
        out << ")";
    }


    network_address::~network_address() throw() {
    }


    void network_address::__set_ip(const std::string& val) {
        this->ip = val;
    }

    void network_address::__set_port(const int16_t val) {
        this->port = val;
    }
    std::ostream& operator<<(std::ostream& out, const network_address& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t network_address::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_ip = false;
        bool isset_port = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->ip);
                    isset_ip = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_I16) {
                    xfer += iprot->readI16(this->port);
                    isset_port = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_ip)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_port)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t network_address::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("network_address");

        xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->ip);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 2);
        xfer += oprot->writeI16(this->port);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(network_address& a, network_address& b) {
        using ::std::swap;
        swap(a.ip, b.ip);
        swap(a.port, b.port);
    }

    network_address::network_address(const network_address& other2) {
        ip = other2.ip;
        port = other2.port;
    }
    network_address& network_address::operator=(const network_address& other3) {
        ip = other3.ip;
        port = other3.port;
        return *this;
    }
    void network_address::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "network_address(";
        out << "ip=" << to_string(ip);
        out << ", " << "port=" << to_string(port);
        out << ")";
    }


    shake_hand_req::~shake_hand_req() throw() {
    }


    void shake_hand_req::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const shake_hand_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t shake_hand_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t shake_hand_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("shake_hand_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(shake_hand_req& a, shake_hand_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    shake_hand_req::shake_hand_req(const shake_hand_req& other4) {
        body = other4.body;
        __isset = other4.__isset;
    }
    shake_hand_req& shake_hand_req::operator=(const shake_hand_req& other5) {
        body = other5.body;
        __isset = other5.__isset;
        return *this;
    }
    void shake_hand_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "shake_hand_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    shake_hand_resp::~shake_hand_resp() throw() {
    }


    void shake_hand_resp::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const shake_hand_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t shake_hand_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t shake_hand_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("shake_hand_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(shake_hand_resp& a, shake_hand_resp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    shake_hand_resp::shake_hand_resp(const shake_hand_resp& other6) {
        body = other6.body;
        __isset = other6.__isset;
    }
    shake_hand_resp& shake_hand_resp::operator=(const shake_hand_resp& other7) {
        body = other7.body;
        __isset = other7.__isset;
        return *this;
    }
    void shake_hand_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "shake_hand_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    multisig_sign_item::~multisig_sign_item() throw() {
    }


    void multisig_sign_item::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void multisig_sign_item::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void multisig_sign_item::__set_sign(const std::string& val) {
        this->sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const multisig_sign_item& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t multisig_sign_item::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t multisig_sign_item::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("multisig_sign_item");

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(multisig_sign_item& a, multisig_sign_item& b) {
        using ::std::swap;
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
    }

    multisig_sign_item::multisig_sign_item(const multisig_sign_item& other8) {
        wallet = other8.wallet;
        nonce = other8.nonce;
        sign = other8.sign;
    }
    multisig_sign_item& multisig_sign_item::operator=(const multisig_sign_item& other9) {
        wallet = other9.wallet;
        nonce = other9.nonce;
        sign = other9.sign;
        return *this;
    }
    void multisig_sign_item::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "multisig_sign_item(";
        out << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ")";
    }


    node_list_images_req_data::~node_list_images_req_data() throw() {
    }


    void node_list_images_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_list_images_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_list_images_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_list_images_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_list_images_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_list_images_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_list_images_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_list_images_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_list_images_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_list_images_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_list_images_req_data::__set_image_server(const std::string& val) {
        this->image_server = val;
        __isset.image_server = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size10;
                        ::apache::thrift::protocol::TType _etype13;
                        xfer += iprot->readListBegin(_etype13, _size10);
                        this->peer_nodes_list.resize(_size10);
                        uint32_t _i14;
                        for (_i14 = 0; _i14 < _size10; ++_i14)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i14]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size15;
                        ::apache::thrift::protocol::TType _etype18;
                        xfer += iprot->readListBegin(_etype18, _size15);
                        this->multisig_wallets.resize(_size15);
                        uint32_t _i19;
                        for (_i19 = 0; _i19 < _size15; ++_i19)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i19]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size20;
                        ::apache::thrift::protocol::TType _etype23;
                        xfer += iprot->readListBegin(_etype23, _size20);
                        this->multisig_signs.resize(_size20);
                        uint32_t _i24;
                        for (_i24 = 0; _i24 < _size20; ++_i24)
                        {
                            xfer += this->multisig_signs[_i24].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->image_server);
                    this->__isset.image_server = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_images_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter25;
            for (_iter25 = this->peer_nodes_list.begin(); _iter25 != this->peer_nodes_list.end(); ++_iter25)
            {
                xfer += oprot->writeString((*_iter25));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter26;
            for (_iter26 = this->multisig_wallets.begin(); _iter26 != this->multisig_wallets.end(); ++_iter26)
            {
                xfer += oprot->writeString((*_iter26));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter27;
            for (_iter27 = this->multisig_signs.begin(); _iter27 != this->multisig_signs.end(); ++_iter27)
            {
                xfer += (*_iter27).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.image_server) {
            xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_STRING, 11);
            xfer += oprot->writeString(this->image_server);
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_req_data& a, node_list_images_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.image_server, b.image_server);
        swap(a.__isset, b.__isset);
    }

    node_list_images_req_data::node_list_images_req_data(const node_list_images_req_data& other28) {
        peer_nodes_list = other28.peer_nodes_list;
        additional = other28.additional;
        wallet = other28.wallet;
        nonce = other28.nonce;
        sign = other28.sign;
        multisig_wallets = other28.multisig_wallets;
        multisig_threshold = other28.multisig_threshold;
        multisig_signs = other28.multisig_signs;
        session_id = other28.session_id;
        session_id_sign = other28.session_id_sign;
        image_server = other28.image_server;
        __isset = other28.__isset;
    }
    node_list_images_req_data& node_list_images_req_data::operator=(const node_list_images_req_data& other29) {
        peer_nodes_list = other29.peer_nodes_list;
        additional = other29.additional;
        wallet = other29.wallet;
        nonce = other29.nonce;
        sign = other29.sign;
        multisig_wallets = other29.multisig_wallets;
        multisig_threshold = other29.multisig_threshold;
        multisig_signs = other29.multisig_signs;
        session_id = other29.session_id;
        session_id_sign = other29.session_id_sign;
        image_server = other29.image_server;
        __isset = other29.__isset;
        return *this;
    }
    void node_list_images_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
        out << ")";
    }


    node_list_images_req_body::~node_list_images_req_body() throw() {
    }


    void node_list_images_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_images_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_req_body& a, node_list_images_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_images_req_body::node_list_images_req_body(const node_list_images_req_body& other30) {
        data = other30.data;
    }
    node_list_images_req_body& node_list_images_req_body::operator=(const node_list_images_req_body& other31) {
        data = other31.data;
        return *this;
    }
    void node_list_images_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_images_req::~node_list_images_req() throw() {
    }


    void node_list_images_req::__set_body(const node_list_images_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_images_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_req& a, node_list_images_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_images_req::node_list_images_req(const node_list_images_req& other32) {
        body = other32.body;
        __isset = other32.__isset;
    }
    node_list_images_req& node_list_images_req::operator=(const node_list_images_req& other33) {
        body = other33.body;
        __isset = other33.__isset;
        return *this;
    }
    void node_list_images_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_images_rsp_body::~node_list_images_rsp_body() throw() {
    }


    void node_list_images_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_images_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_rsp_body& a, node_list_images_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_images_rsp_body::node_list_images_rsp_body(const node_list_images_rsp_body& other34) {
        data = other34.data;
    }
    node_list_images_rsp_body& node_list_images_rsp_body::operator=(const node_list_images_rsp_body& other35) {
        data = other35.data;
        return *this;
    }
    void node_list_images_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_images_rsp::~node_list_images_rsp() throw() {
    }


    void node_list_images_rsp::__set_body(const node_list_images_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_images_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_images_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_images_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_images_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_images_rsp& a, node_list_images_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_images_rsp::node_list_images_rsp(const node_list_images_rsp& other36) {
        body = other36.body;
        __isset = other36.__isset;
    }
    node_list_images_rsp& node_list_images_rsp::operator=(const node_list_images_rsp& other37) {
        body = other37.body;
        __isset = other37.__isset;
        return *this;
    }
    void node_list_images_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_images_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_download_image_req_data::~node_download_image_req_data() throw() {
    }


    void node_download_image_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_download_image_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_download_image_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_download_image_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_download_image_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_download_image_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_download_image_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_download_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_download_image_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_download_image_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_download_image_req_data::__set_image_server(const std::string& val) {
        this->image_server = val;
        __isset.image_server = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size38;
                        ::apache::thrift::protocol::TType _etype41;
                        xfer += iprot->readListBegin(_etype41, _size38);
                        this->peer_nodes_list.resize(_size38);
                        uint32_t _i42;
                        for (_i42 = 0; _i42 < _size38; ++_i42)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i42]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size43;
                        ::apache::thrift::protocol::TType _etype46;
                        xfer += iprot->readListBegin(_etype46, _size43);
                        this->multisig_wallets.resize(_size43);
                        uint32_t _i47;
                        for (_i47 = 0; _i47 < _size43; ++_i47)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i47]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size48;
                        ::apache::thrift::protocol::TType _etype51;
                        xfer += iprot->readListBegin(_etype51, _size48);
                        this->multisig_signs.resize(_size48);
                        uint32_t _i52;
                        for (_i52 = 0; _i52 < _size48; ++_i52)
                        {
                            xfer += this->multisig_signs[_i52].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->image_server);
                    this->__isset.image_server = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter53;
            for (_iter53 = this->peer_nodes_list.begin(); _iter53 != this->peer_nodes_list.end(); ++_iter53)
            {
                xfer += oprot->writeString((*_iter53));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter54;
            for (_iter54 = this->multisig_wallets.begin(); _iter54 != this->multisig_wallets.end(); ++_iter54)
            {
                xfer += oprot->writeString((*_iter54));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter55;
            for (_iter55 = this->multisig_signs.begin(); _iter55 != this->multisig_signs.end(); ++_iter55)
            {
                xfer += (*_iter55).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.image_server) {
            xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_STRING, 11);
            xfer += oprot->writeString(this->image_server);
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_req_data& a, node_download_image_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.image_server, b.image_server);
        swap(a.__isset, b.__isset);
    }

    node_download_image_req_data::node_download_image_req_data(const node_download_image_req_data& other56) {
        peer_nodes_list = other56.peer_nodes_list;
        additional = other56.additional;
        wallet = other56.wallet;
        nonce = other56.nonce;
        sign = other56.sign;
        multisig_wallets = other56.multisig_wallets;
        multisig_threshold = other56.multisig_threshold;
        multisig_signs = other56.multisig_signs;
        session_id = other56.session_id;
        session_id_sign = other56.session_id_sign;
        image_server = other56.image_server;
        __isset = other56.__isset;
    }
    node_download_image_req_data& node_download_image_req_data::operator=(const node_download_image_req_data& other57) {
        peer_nodes_list = other57.peer_nodes_list;
        additional = other57.additional;
        wallet = other57.wallet;
        nonce = other57.nonce;
        sign = other57.sign;
        multisig_wallets = other57.multisig_wallets;
        multisig_threshold = other57.multisig_threshold;
        multisig_signs = other57.multisig_signs;
        session_id = other57.session_id;
        session_id_sign = other57.session_id_sign;
        image_server = other57.image_server;
        __isset = other57.__isset;
        return *this;
    }
    void node_download_image_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
        out << ")";
    }


    node_download_image_req_body::~node_download_image_req_body() throw() {
    }


    void node_download_image_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_req_body& a, node_download_image_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_download_image_req_body::node_download_image_req_body(const node_download_image_req_body& other58) {
        data = other58.data;
    }
    node_download_image_req_body& node_download_image_req_body::operator=(const node_download_image_req_body& other59) {
        data = other59.data;
        return *this;
    }
    void node_download_image_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_download_image_req::~node_download_image_req() throw() {
    }


    void node_download_image_req::__set_body(const node_download_image_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_download_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_req& a, node_download_image_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_download_image_req::node_download_image_req(const node_download_image_req& other60) {
        body = other60.body;
        __isset = other60.__isset;
    }
    node_download_image_req& node_download_image_req::operator=(const node_download_image_req& other61) {
        body = other61.body;
        __isset = other61.__isset;
        return *this;
    }
    void node_download_image_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_download_image_rsp_body::~node_download_image_rsp_body() throw() {
    }


    void node_download_image_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_rsp_body& a, node_download_image_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_download_image_rsp_body::node_download_image_rsp_body(const node_download_image_rsp_body& other62) {
        data = other62.data;
    }
    node_download_image_rsp_body& node_download_image_rsp_body::operator=(const node_download_image_rsp_body& other63) {
        data = other63.data;
        return *this;
    }
    void node_download_image_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_download_image_rsp::~node_download_image_rsp() throw() {
    }


    void node_download_image_rsp::__set_body(const node_download_image_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_download_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_rsp& a, node_download_image_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_download_image_rsp::node_download_image_rsp(const node_download_image_rsp& other64) {
        body = other64.body;
        __isset = other64.__isset;
    }
    node_download_image_rsp& node_download_image_rsp::operator=(const node_download_image_rsp& other65) {
        body = other65.body;
        __isset = other65.__isset;
        return *this;
    }
    void node_download_image_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_download_image_progress_req_data::~node_download_image_progress_req_data() throw() {
    }


    void node_download_image_progress_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_download_image_progress_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_download_image_progress_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_download_image_progress_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_download_image_progress_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_download_image_progress_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_download_image_progress_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_download_image_progress_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_download_image_progress_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_download_image_progress_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_progress_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_progress_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size66;
                        ::apache::thrift::protocol::TType _etype69;
                        xfer += iprot->readListBegin(_etype69, _size66);
                        this->peer_nodes_list.resize(_size66);
                        uint32_t _i70;
                        for (_i70 = 0; _i70 < _size66; ++_i70)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i70]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size71;
                        ::apache::thrift::protocol::TType _etype74;
                        xfer += iprot->readListBegin(_etype74, _size71);
                        this->multisig_wallets.resize(_size71);
                        uint32_t _i75;
                        for (_i75 = 0; _i75 < _size71; ++_i75)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i75]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size76;
                        ::apache::thrift::protocol::TType _etype79;
                        xfer += iprot->readListBegin(_etype79, _size76);
                        this->multisig_signs.resize(_size76);
                        uint32_t _i80;
                        for (_i80 = 0; _i80 < _size76; ++_i80)
                        {
                            xfer += this->multisig_signs[_i80].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_progress_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_progress_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter81;
            for (_iter81 = this->peer_nodes_list.begin(); _iter81 != this->peer_nodes_list.end(); ++_iter81)
            {
                xfer += oprot->writeString((*_iter81));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter82;
            for (_iter82 = this->multisig_wallets.begin(); _iter82 != this->multisig_wallets.end(); ++_iter82)
            {
                xfer += oprot->writeString((*_iter82));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter83;
            for (_iter83 = this->multisig_signs.begin(); _iter83 != this->multisig_signs.end(); ++_iter83)
            {
                xfer += (*_iter83).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_progress_req_data& a, node_download_image_progress_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_download_image_progress_req_data::node_download_image_progress_req_data(const node_download_image_progress_req_data& other84) {
        peer_nodes_list = other84.peer_nodes_list;
        additional = other84.additional;
        wallet = other84.wallet;
        nonce = other84.nonce;
        sign = other84.sign;
        multisig_wallets = other84.multisig_wallets;
        multisig_threshold = other84.multisig_threshold;
        multisig_signs = other84.multisig_signs;
        session_id = other84.session_id;
        session_id_sign = other84.session_id_sign;
    }
    node_download_image_progress_req_data& node_download_image_progress_req_data::operator=(const node_download_image_progress_req_data& other85) {
        peer_nodes_list = other85.peer_nodes_list;
        additional = other85.additional;
        wallet = other85.wallet;
        nonce = other85.nonce;
        sign = other85.sign;
        multisig_wallets = other85.multisig_wallets;
        multisig_threshold = other85.multisig_threshold;
        multisig_signs = other85.multisig_signs;
        session_id = other85.session_id;
        session_id_sign = other85.session_id_sign;
        return *this;
    }
    void node_download_image_progress_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_progress_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_download_image_progress_req_body::~node_download_image_progress_req_body() throw() {
    }


    void node_download_image_progress_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_progress_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_progress_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_progress_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_progress_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_progress_req_body& a, node_download_image_progress_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_download_image_progress_req_body::node_download_image_progress_req_body(const node_download_image_progress_req_body& other86) {
        data = other86.data;
    }
    node_download_image_progress_req_body& node_download_image_progress_req_body::operator=(const node_download_image_progress_req_body& other87) {
        data = other87.data;
        return *this;
    }
    void node_download_image_progress_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_progress_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_download_image_progress_req::~node_download_image_progress_req() throw() {
    }


    void node_download_image_progress_req::__set_body(const node_download_image_progress_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_progress_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_progress_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_download_image_progress_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_progress_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_progress_req& a, node_download_image_progress_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_download_image_progress_req::node_download_image_progress_req(const node_download_image_progress_req& other88) {
        body = other88.body;
        __isset = other88.__isset;
    }
    node_download_image_progress_req& node_download_image_progress_req::operator=(const node_download_image_progress_req& other89) {
        body = other89.body;
        __isset = other89.__isset;
        return *this;
    }
    void node_download_image_progress_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_progress_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_download_image_progress_rsp_body::~node_download_image_progress_rsp_body() throw() {
    }


    void node_download_image_progress_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_progress_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_progress_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_download_image_progress_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_progress_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_progress_rsp_body& a, node_download_image_progress_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_download_image_progress_rsp_body::node_download_image_progress_rsp_body(const node_download_image_progress_rsp_body& other90) {
        data = other90.data;
    }
    node_download_image_progress_rsp_body& node_download_image_progress_rsp_body::operator=(const node_download_image_progress_rsp_body& other91) {
        data = other91.data;
        return *this;
    }
    void node_download_image_progress_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_progress_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_download_image_progress_rsp::~node_download_image_progress_rsp() throw() {
    }


    void node_download_image_progress_rsp::__set_body(const node_download_image_progress_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_download_image_progress_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_download_image_progress_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_download_image_progress_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_download_image_progress_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_download_image_progress_rsp& a, node_download_image_progress_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_download_image_progress_rsp::node_download_image_progress_rsp(const node_download_image_progress_rsp& other92) {
        body = other92.body;
        __isset = other92.__isset;
    }
    node_download_image_progress_rsp& node_download_image_progress_rsp::operator=(const node_download_image_progress_rsp& other93) {
        body = other93.body;
        __isset = other93.__isset;
        return *this;
    }
    void node_download_image_progress_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_download_image_progress_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_download_image_req_data::~node_stop_download_image_req_data() throw() {
    }


    void node_stop_download_image_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_stop_download_image_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_stop_download_image_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_stop_download_image_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_stop_download_image_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_stop_download_image_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_stop_download_image_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_stop_download_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_stop_download_image_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_stop_download_image_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_download_image_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_download_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size94;
                        ::apache::thrift::protocol::TType _etype97;
                        xfer += iprot->readListBegin(_etype97, _size94);
                        this->peer_nodes_list.resize(_size94);
                        uint32_t _i98;
                        for (_i98 = 0; _i98 < _size94; ++_i98)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i98]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size99;
                        ::apache::thrift::protocol::TType _etype102;
                        xfer += iprot->readListBegin(_etype102, _size99);
                        this->multisig_wallets.resize(_size99);
                        uint32_t _i103;
                        for (_i103 = 0; _i103 < _size99; ++_i103)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i103]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size104;
                        ::apache::thrift::protocol::TType _etype107;
                        xfer += iprot->readListBegin(_etype107, _size104);
                        this->multisig_signs.resize(_size104);
                        uint32_t _i108;
                        for (_i108 = 0; _i108 < _size104; ++_i108)
                        {
                            xfer += this->multisig_signs[_i108].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_download_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_download_image_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter109;
            for (_iter109 = this->peer_nodes_list.begin(); _iter109 != this->peer_nodes_list.end(); ++_iter109)
            {
                xfer += oprot->writeString((*_iter109));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter110;
            for (_iter110 = this->multisig_wallets.begin(); _iter110 != this->multisig_wallets.end(); ++_iter110)
            {
                xfer += oprot->writeString((*_iter110));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter111;
            for (_iter111 = this->multisig_signs.begin(); _iter111 != this->multisig_signs.end(); ++_iter111)
            {
                xfer += (*_iter111).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_download_image_req_data& a, node_stop_download_image_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_stop_download_image_req_data::node_stop_download_image_req_data(const node_stop_download_image_req_data& other112) {
        peer_nodes_list = other112.peer_nodes_list;
        additional = other112.additional;
        wallet = other112.wallet;
        nonce = other112.nonce;
        sign = other112.sign;
        multisig_wallets = other112.multisig_wallets;
        multisig_threshold = other112.multisig_threshold;
        multisig_signs = other112.multisig_signs;
        session_id = other112.session_id;
        session_id_sign = other112.session_id_sign;
    }
    node_stop_download_image_req_data& node_stop_download_image_req_data::operator=(const node_stop_download_image_req_data& other113) {
        peer_nodes_list = other113.peer_nodes_list;
        additional = other113.additional;
        wallet = other113.wallet;
        nonce = other113.nonce;
        sign = other113.sign;
        multisig_wallets = other113.multisig_wallets;
        multisig_threshold = other113.multisig_threshold;
        multisig_signs = other113.multisig_signs;
        session_id = other113.session_id;
        session_id_sign = other113.session_id_sign;
        return *this;
    }
    void node_stop_download_image_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_download_image_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_stop_download_image_req_body::~node_stop_download_image_req_body() throw() {
    }


    void node_stop_download_image_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_download_image_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_download_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_download_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_download_image_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_download_image_req_body& a, node_stop_download_image_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_download_image_req_body::node_stop_download_image_req_body(const node_stop_download_image_req_body& other114) {
        data = other114.data;
    }
    node_stop_download_image_req_body& node_stop_download_image_req_body::operator=(const node_stop_download_image_req_body& other115) {
        data = other115.data;
        return *this;
    }
    void node_stop_download_image_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_download_image_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_download_image_req::~node_stop_download_image_req() throw() {
    }


    void node_stop_download_image_req::__set_body(const node_stop_download_image_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_download_image_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_download_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_download_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_download_image_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_download_image_req& a, node_stop_download_image_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_download_image_req::node_stop_download_image_req(const node_stop_download_image_req& other116) {
        body = other116.body;
        __isset = other116.__isset;
    }
    node_stop_download_image_req& node_stop_download_image_req::operator=(const node_stop_download_image_req& other117) {
        body = other117.body;
        __isset = other117.__isset;
        return *this;
    }
    void node_stop_download_image_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_download_image_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_download_image_rsp_body::~node_stop_download_image_rsp_body() throw() {
    }


    void node_stop_download_image_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_download_image_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_download_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_download_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_download_image_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_download_image_rsp_body& a, node_stop_download_image_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_download_image_rsp_body::node_stop_download_image_rsp_body(const node_stop_download_image_rsp_body& other118) {
        data = other118.data;
    }
    node_stop_download_image_rsp_body& node_stop_download_image_rsp_body::operator=(const node_stop_download_image_rsp_body& other119) {
        data = other119.data;
        return *this;
    }
    void node_stop_download_image_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_download_image_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_download_image_rsp::~node_stop_download_image_rsp() throw() {
    }


    void node_stop_download_image_rsp::__set_body(const node_stop_download_image_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_download_image_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_download_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_download_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_download_image_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_download_image_rsp& a, node_stop_download_image_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_download_image_rsp::node_stop_download_image_rsp(const node_stop_download_image_rsp& other120) {
        body = other120.body;
        __isset = other120.__isset;
    }
    node_stop_download_image_rsp& node_stop_download_image_rsp::operator=(const node_stop_download_image_rsp& other121) {
        body = other121.body;
        __isset = other121.__isset;
        return *this;
    }
    void node_stop_download_image_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_download_image_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_upload_image_req_data::~node_upload_image_req_data() throw() {
    }


    void node_upload_image_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_upload_image_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_upload_image_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_upload_image_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_upload_image_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_upload_image_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_upload_image_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_upload_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_upload_image_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_upload_image_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_upload_image_req_data::__set_image_server(const std::string& val) {
        this->image_server = val;
        __isset.image_server = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size122;
                        ::apache::thrift::protocol::TType _etype125;
                        xfer += iprot->readListBegin(_etype125, _size122);
                        this->peer_nodes_list.resize(_size122);
                        uint32_t _i126;
                        for (_i126 = 0; _i126 < _size122; ++_i126)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i126]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size127;
                        ::apache::thrift::protocol::TType _etype130;
                        xfer += iprot->readListBegin(_etype130, _size127);
                        this->multisig_wallets.resize(_size127);
                        uint32_t _i131;
                        for (_i131 = 0; _i131 < _size127; ++_i131)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i131]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size132;
                        ::apache::thrift::protocol::TType _etype135;
                        xfer += iprot->readListBegin(_etype135, _size132);
                        this->multisig_signs.resize(_size132);
                        uint32_t _i136;
                        for (_i136 = 0; _i136 < _size132; ++_i136)
                        {
                            xfer += this->multisig_signs[_i136].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->image_server);
                    this->__isset.image_server = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter137;
            for (_iter137 = this->peer_nodes_list.begin(); _iter137 != this->peer_nodes_list.end(); ++_iter137)
            {
                xfer += oprot->writeString((*_iter137));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter138;
            for (_iter138 = this->multisig_wallets.begin(); _iter138 != this->multisig_wallets.end(); ++_iter138)
            {
                xfer += oprot->writeString((*_iter138));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter139;
            for (_iter139 = this->multisig_signs.begin(); _iter139 != this->multisig_signs.end(); ++_iter139)
            {
                xfer += (*_iter139).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.image_server) {
            xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_STRING, 11);
            xfer += oprot->writeString(this->image_server);
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_req_data& a, node_upload_image_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.image_server, b.image_server);
        swap(a.__isset, b.__isset);
    }

    node_upload_image_req_data::node_upload_image_req_data(const node_upload_image_req_data& other140) {
        peer_nodes_list = other140.peer_nodes_list;
        additional = other140.additional;
        wallet = other140.wallet;
        nonce = other140.nonce;
        sign = other140.sign;
        multisig_wallets = other140.multisig_wallets;
        multisig_threshold = other140.multisig_threshold;
        multisig_signs = other140.multisig_signs;
        session_id = other140.session_id;
        session_id_sign = other140.session_id_sign;
        image_server = other140.image_server;
        __isset = other140.__isset;
    }
    node_upload_image_req_data& node_upload_image_req_data::operator=(const node_upload_image_req_data& other141) {
        peer_nodes_list = other141.peer_nodes_list;
        additional = other141.additional;
        wallet = other141.wallet;
        nonce = other141.nonce;
        sign = other141.sign;
        multisig_wallets = other141.multisig_wallets;
        multisig_threshold = other141.multisig_threshold;
        multisig_signs = other141.multisig_signs;
        session_id = other141.session_id;
        session_id_sign = other141.session_id_sign;
        image_server = other141.image_server;
        __isset = other141.__isset;
        return *this;
    }
    void node_upload_image_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
        out << ")";
    }


    node_upload_image_req_body::~node_upload_image_req_body() throw() {
    }


    void node_upload_image_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_req_body& a, node_upload_image_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_upload_image_req_body::node_upload_image_req_body(const node_upload_image_req_body& other142) {
        data = other142.data;
    }
    node_upload_image_req_body& node_upload_image_req_body::operator=(const node_upload_image_req_body& other143) {
        data = other143.data;
        return *this;
    }
    void node_upload_image_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_upload_image_req::~node_upload_image_req() throw() {
    }


    void node_upload_image_req::__set_body(const node_upload_image_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_upload_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_req& a, node_upload_image_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_upload_image_req::node_upload_image_req(const node_upload_image_req& other144) {
        body = other144.body;
        __isset = other144.__isset;
    }
    node_upload_image_req& node_upload_image_req::operator=(const node_upload_image_req& other145) {
        body = other145.body;
        __isset = other145.__isset;
        return *this;
    }
    void node_upload_image_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_upload_image_rsp_body::~node_upload_image_rsp_body() throw() {
    }


    void node_upload_image_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_rsp_body& a, node_upload_image_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_upload_image_rsp_body::node_upload_image_rsp_body(const node_upload_image_rsp_body& other146) {
        data = other146.data;
    }
    node_upload_image_rsp_body& node_upload_image_rsp_body::operator=(const node_upload_image_rsp_body& other147) {
        data = other147.data;
        return *this;
    }
    void node_upload_image_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_upload_image_rsp::~node_upload_image_rsp() throw() {
    }


    void node_upload_image_rsp::__set_body(const node_upload_image_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_upload_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_rsp& a, node_upload_image_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_upload_image_rsp::node_upload_image_rsp(const node_upload_image_rsp& other148) {
        body = other148.body;
        __isset = other148.__isset;
    }
    node_upload_image_rsp& node_upload_image_rsp::operator=(const node_upload_image_rsp& other149) {
        body = other149.body;
        __isset = other149.__isset;
        return *this;
    }
    void node_upload_image_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_upload_image_progress_req_data::~node_upload_image_progress_req_data() throw() {
    }


    void node_upload_image_progress_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_upload_image_progress_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_upload_image_progress_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_upload_image_progress_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_upload_image_progress_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_upload_image_progress_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_upload_image_progress_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_upload_image_progress_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_upload_image_progress_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_upload_image_progress_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_progress_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_progress_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size150;
                        ::apache::thrift::protocol::TType _etype153;
                        xfer += iprot->readListBegin(_etype153, _size150);
                        this->peer_nodes_list.resize(_size150);
                        uint32_t _i154;
                        for (_i154 = 0; _i154 < _size150; ++_i154)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i154]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size155;
                        ::apache::thrift::protocol::TType _etype158;
                        xfer += iprot->readListBegin(_etype158, _size155);
                        this->multisig_wallets.resize(_size155);
                        uint32_t _i159;
                        for (_i159 = 0; _i159 < _size155; ++_i159)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i159]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size160;
                        ::apache::thrift::protocol::TType _etype163;
                        xfer += iprot->readListBegin(_etype163, _size160);
                        this->multisig_signs.resize(_size160);
                        uint32_t _i164;
                        for (_i164 = 0; _i164 < _size160; ++_i164)
                        {
                            xfer += this->multisig_signs[_i164].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_progress_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_progress_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter165;
            for (_iter165 = this->peer_nodes_list.begin(); _iter165 != this->peer_nodes_list.end(); ++_iter165)
            {
                xfer += oprot->writeString((*_iter165));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter166;
            for (_iter166 = this->multisig_wallets.begin(); _iter166 != this->multisig_wallets.end(); ++_iter166)
            {
                xfer += oprot->writeString((*_iter166));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter167;
            for (_iter167 = this->multisig_signs.begin(); _iter167 != this->multisig_signs.end(); ++_iter167)
            {
                xfer += (*_iter167).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_progress_req_data& a, node_upload_image_progress_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_upload_image_progress_req_data::node_upload_image_progress_req_data(const node_upload_image_progress_req_data& other168) {
        peer_nodes_list = other168.peer_nodes_list;
        additional = other168.additional;
        wallet = other168.wallet;
        nonce = other168.nonce;
        sign = other168.sign;
        multisig_wallets = other168.multisig_wallets;
        multisig_threshold = other168.multisig_threshold;
        multisig_signs = other168.multisig_signs;
        session_id = other168.session_id;
        session_id_sign = other168.session_id_sign;
    }
    node_upload_image_progress_req_data& node_upload_image_progress_req_data::operator=(const node_upload_image_progress_req_data& other169) {
        peer_nodes_list = other169.peer_nodes_list;
        additional = other169.additional;
        wallet = other169.wallet;
        nonce = other169.nonce;
        sign = other169.sign;
        multisig_wallets = other169.multisig_wallets;
        multisig_threshold = other169.multisig_threshold;
        multisig_signs = other169.multisig_signs;
        session_id = other169.session_id;
        session_id_sign = other169.session_id_sign;
        return *this;
    }
    void node_upload_image_progress_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_progress_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_upload_image_progress_req_body::~node_upload_image_progress_req_body() throw() {
    }


    void node_upload_image_progress_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_progress_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_progress_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_progress_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_progress_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_progress_req_body& a, node_upload_image_progress_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_upload_image_progress_req_body::node_upload_image_progress_req_body(const node_upload_image_progress_req_body& other170) {
        data = other170.data;
    }
    node_upload_image_progress_req_body& node_upload_image_progress_req_body::operator=(const node_upload_image_progress_req_body& other171) {
        data = other171.data;
        return *this;
    }
    void node_upload_image_progress_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_progress_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_upload_image_progress_req::~node_upload_image_progress_req() throw() {
    }


    void node_upload_image_progress_req::__set_body(const node_upload_image_progress_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_progress_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_progress_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_upload_image_progress_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_progress_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_progress_req& a, node_upload_image_progress_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_upload_image_progress_req::node_upload_image_progress_req(const node_upload_image_progress_req& other172) {
        body = other172.body;
        __isset = other172.__isset;
    }
    node_upload_image_progress_req& node_upload_image_progress_req::operator=(const node_upload_image_progress_req& other173) {
        body = other173.body;
        __isset = other173.__isset;
        return *this;
    }
    void node_upload_image_progress_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_progress_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_upload_image_progress_rsp_body::~node_upload_image_progress_rsp_body() throw() {
    }


    void node_upload_image_progress_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_progress_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_progress_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_upload_image_progress_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_progress_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_progress_rsp_body& a, node_upload_image_progress_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_upload_image_progress_rsp_body::node_upload_image_progress_rsp_body(const node_upload_image_progress_rsp_body& other174) {
        data = other174.data;
    }
    node_upload_image_progress_rsp_body& node_upload_image_progress_rsp_body::operator=(const node_upload_image_progress_rsp_body& other175) {
        data = other175.data;
        return *this;
    }
    void node_upload_image_progress_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_progress_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_upload_image_progress_rsp::~node_upload_image_progress_rsp() throw() {
    }


    void node_upload_image_progress_rsp::__set_body(const node_upload_image_progress_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_upload_image_progress_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_upload_image_progress_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_upload_image_progress_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_upload_image_progress_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_upload_image_progress_rsp& a, node_upload_image_progress_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_upload_image_progress_rsp::node_upload_image_progress_rsp(const node_upload_image_progress_rsp& other176) {
        body = other176.body;
        __isset = other176.__isset;
    }
    node_upload_image_progress_rsp& node_upload_image_progress_rsp::operator=(const node_upload_image_progress_rsp& other177) {
        body = other177.body;
        __isset = other177.__isset;
        return *this;
    }
    void node_upload_image_progress_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_upload_image_progress_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_upload_image_req_data::~node_stop_upload_image_req_data() throw() {
    }


    void node_stop_upload_image_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_stop_upload_image_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_stop_upload_image_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_stop_upload_image_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_stop_upload_image_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_stop_upload_image_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_stop_upload_image_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_stop_upload_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_stop_upload_image_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_stop_upload_image_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_upload_image_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_upload_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size178;
                        ::apache::thrift::protocol::TType _etype181;
                        xfer += iprot->readListBegin(_etype181, _size178);
                        this->peer_nodes_list.resize(_size178);
                        uint32_t _i182;
                        for (_i182 = 0; _i182 < _size178; ++_i182)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i182]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size183;
                        ::apache::thrift::protocol::TType _etype186;
                        xfer += iprot->readListBegin(_etype186, _size183);
                        this->multisig_wallets.resize(_size183);
                        uint32_t _i187;
                        for (_i187 = 0; _i187 < _size183; ++_i187)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i187]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size188;
                        ::apache::thrift::protocol::TType _etype191;
                        xfer += iprot->readListBegin(_etype191, _size188);
                        this->multisig_signs.resize(_size188);
                        uint32_t _i192;
                        for (_i192 = 0; _i192 < _size188; ++_i192)
                        {
                            xfer += this->multisig_signs[_i192].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_upload_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_upload_image_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter193;
            for (_iter193 = this->peer_nodes_list.begin(); _iter193 != this->peer_nodes_list.end(); ++_iter193)
            {
                xfer += oprot->writeString((*_iter193));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter194;
            for (_iter194 = this->multisig_wallets.begin(); _iter194 != this->multisig_wallets.end(); ++_iter194)
            {
                xfer += oprot->writeString((*_iter194));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter195;
            for (_iter195 = this->multisig_signs.begin(); _iter195 != this->multisig_signs.end(); ++_iter195)
            {
                xfer += (*_iter195).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_upload_image_req_data& a, node_stop_upload_image_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_stop_upload_image_req_data::node_stop_upload_image_req_data(const node_stop_upload_image_req_data& other196) {
        peer_nodes_list = other196.peer_nodes_list;
        additional = other196.additional;
        wallet = other196.wallet;
        nonce = other196.nonce;
        sign = other196.sign;
        multisig_wallets = other196.multisig_wallets;
        multisig_threshold = other196.multisig_threshold;
        multisig_signs = other196.multisig_signs;
        session_id = other196.session_id;
        session_id_sign = other196.session_id_sign;
    }
    node_stop_upload_image_req_data& node_stop_upload_image_req_data::operator=(const node_stop_upload_image_req_data& other197) {
        peer_nodes_list = other197.peer_nodes_list;
        additional = other197.additional;
        wallet = other197.wallet;
        nonce = other197.nonce;
        sign = other197.sign;
        multisig_wallets = other197.multisig_wallets;
        multisig_threshold = other197.multisig_threshold;
        multisig_signs = other197.multisig_signs;
        session_id = other197.session_id;
        session_id_sign = other197.session_id_sign;
        return *this;
    }
    void node_stop_upload_image_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_upload_image_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_stop_upload_image_req_body::~node_stop_upload_image_req_body() throw() {
    }


    void node_stop_upload_image_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_upload_image_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_upload_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_upload_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_upload_image_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_upload_image_req_body& a, node_stop_upload_image_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_upload_image_req_body::node_stop_upload_image_req_body(const node_stop_upload_image_req_body& other198) {
        data = other198.data;
    }
    node_stop_upload_image_req_body& node_stop_upload_image_req_body::operator=(const node_stop_upload_image_req_body& other199) {
        data = other199.data;
        return *this;
    }
    void node_stop_upload_image_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_upload_image_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_upload_image_req::~node_stop_upload_image_req() throw() {
    }


    void node_stop_upload_image_req::__set_body(const node_stop_upload_image_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_upload_image_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_upload_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_upload_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_upload_image_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_upload_image_req& a, node_stop_upload_image_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_upload_image_req::node_stop_upload_image_req(const node_stop_upload_image_req& other200) {
        body = other200.body;
        __isset = other200.__isset;
    }
    node_stop_upload_image_req& node_stop_upload_image_req::operator=(const node_stop_upload_image_req& other201) {
        body = other201.body;
        __isset = other201.__isset;
        return *this;
    }
    void node_stop_upload_image_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_upload_image_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_upload_image_rsp_body::~node_stop_upload_image_rsp_body() throw() {
    }


    void node_stop_upload_image_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_upload_image_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_upload_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_upload_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_upload_image_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_upload_image_rsp_body& a, node_stop_upload_image_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_upload_image_rsp_body::node_stop_upload_image_rsp_body(const node_stop_upload_image_rsp_body& other202) {
        data = other202.data;
    }
    node_stop_upload_image_rsp_body& node_stop_upload_image_rsp_body::operator=(const node_stop_upload_image_rsp_body& other203) {
        data = other203.data;
        return *this;
    }
    void node_stop_upload_image_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_upload_image_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_upload_image_rsp::~node_stop_upload_image_rsp() throw() {
    }


    void node_stop_upload_image_rsp::__set_body(const node_stop_upload_image_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_upload_image_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_upload_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_upload_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_upload_image_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_upload_image_rsp& a, node_stop_upload_image_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_upload_image_rsp::node_stop_upload_image_rsp(const node_stop_upload_image_rsp& other204) {
        body = other204.body;
        __isset = other204.__isset;
    }
    node_stop_upload_image_rsp& node_stop_upload_image_rsp::operator=(const node_stop_upload_image_rsp& other205) {
        body = other205.body;
        __isset = other205.__isset;
        return *this;
    }
    void node_stop_upload_image_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_upload_image_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_image_req_data::~node_delete_image_req_data() throw() {
    }


    void node_delete_image_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_delete_image_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_delete_image_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_delete_image_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_delete_image_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_delete_image_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_delete_image_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_delete_image_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_delete_image_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_delete_image_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_image_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_image_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size206;
                        ::apache::thrift::protocol::TType _etype209;
                        xfer += iprot->readListBegin(_etype209, _size206);
                        this->peer_nodes_list.resize(_size206);
                        uint32_t _i210;
                        for (_i210 = 0; _i210 < _size206; ++_i210)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i210]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size211;
                        ::apache::thrift::protocol::TType _etype214;
                        xfer += iprot->readListBegin(_etype214, _size211);
                        this->multisig_wallets.resize(_size211);
                        uint32_t _i215;
                        for (_i215 = 0; _i215 < _size211; ++_i215)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i215]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size216;
                        ::apache::thrift::protocol::TType _etype219;
                        xfer += iprot->readListBegin(_etype219, _size216);
                        this->multisig_signs.resize(_size216);
                        uint32_t _i220;
                        for (_i220 = 0; _i220 < _size216; ++_i220)
                        {
                            xfer += this->multisig_signs[_i220].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_image_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_image_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter221;
            for (_iter221 = this->peer_nodes_list.begin(); _iter221 != this->peer_nodes_list.end(); ++_iter221)
            {
                xfer += oprot->writeString((*_iter221));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter222;
            for (_iter222 = this->multisig_wallets.begin(); _iter222 != this->multisig_wallets.end(); ++_iter222)
            {
                xfer += oprot->writeString((*_iter222));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter223;
            for (_iter223 = this->multisig_signs.begin(); _iter223 != this->multisig_signs.end(); ++_iter223)
            {
                xfer += (*_iter223).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_image_req_data& a, node_delete_image_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_delete_image_req_data::node_delete_image_req_data(const node_delete_image_req_data& other224) {
        peer_nodes_list = other224.peer_nodes_list;
        additional = other224.additional;
        wallet = other224.wallet;
        nonce = other224.nonce;
        sign = other224.sign;
        multisig_wallets = other224.multisig_wallets;
        multisig_threshold = other224.multisig_threshold;
        multisig_signs = other224.multisig_signs;
        session_id = other224.session_id;
        session_id_sign = other224.session_id_sign;
    }
    node_delete_image_req_data& node_delete_image_req_data::operator=(const node_delete_image_req_data& other225) {
        peer_nodes_list = other225.peer_nodes_list;
        additional = other225.additional;
        wallet = other225.wallet;
        nonce = other225.nonce;
        sign = other225.sign;
        multisig_wallets = other225.multisig_wallets;
        multisig_threshold = other225.multisig_threshold;
        multisig_signs = other225.multisig_signs;
        session_id = other225.session_id;
        session_id_sign = other225.session_id_sign;
        return *this;
    }
    void node_delete_image_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_image_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_delete_image_req_body::~node_delete_image_req_body() throw() {
    }


    void node_delete_image_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_image_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_image_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_image_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_image_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_image_req_body& a, node_delete_image_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_image_req_body::node_delete_image_req_body(const node_delete_image_req_body& other226) {
        data = other226.data;
    }
    node_delete_image_req_body& node_delete_image_req_body::operator=(const node_delete_image_req_body& other227) {
        data = other227.data;
        return *this;
    }
    void node_delete_image_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_image_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_image_req::~node_delete_image_req() throw() {
    }


    void node_delete_image_req::__set_body(const node_delete_image_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_image_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_image_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_image_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_image_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_image_req& a, node_delete_image_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_image_req::node_delete_image_req(const node_delete_image_req& other228) {
        body = other228.body;
        __isset = other228.__isset;
    }
    node_delete_image_req& node_delete_image_req::operator=(const node_delete_image_req& other229) {
        body = other229.body;
        __isset = other229.__isset;
        return *this;
    }
    void node_delete_image_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_image_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_image_rsp_body::~node_delete_image_rsp_body() throw() {
    }


    void node_delete_image_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_image_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_image_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_image_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_image_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_image_rsp_body& a, node_delete_image_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_image_rsp_body::node_delete_image_rsp_body(const node_delete_image_rsp_body& other230) {
        data = other230.data;
    }
    node_delete_image_rsp_body& node_delete_image_rsp_body::operator=(const node_delete_image_rsp_body& other231) {
        data = other231.data;
        return *this;
    }
    void node_delete_image_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_image_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_image_rsp::~node_delete_image_rsp() throw() {
    }


    void node_delete_image_rsp::__set_body(const node_delete_image_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_image_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_image_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_image_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_image_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_image_rsp& a, node_delete_image_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_image_rsp::node_delete_image_rsp(const node_delete_image_rsp& other232) {
        body = other232.body;
        __isset = other232.__isset;
    }
    node_delete_image_rsp& node_delete_image_rsp::operator=(const node_delete_image_rsp& other233) {
        body = other233.body;
        __isset = other233.__isset;
        return *this;
    }
    void node_delete_image_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_image_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_task_req_data::~node_list_task_req_data() throw() {
    }


    void node_list_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_list_task_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_list_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_list_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_list_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_list_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_list_task_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_list_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_list_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_list_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_list_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size234;
                        ::apache::thrift::protocol::TType _etype237;
                        xfer += iprot->readListBegin(_etype237, _size234);
                        this->peer_nodes_list.resize(_size234);
                        uint32_t _i238;
                        for (_i238 = 0; _i238 < _size234; ++_i238)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i238]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size239;
                        ::apache::thrift::protocol::TType _etype242;
                        xfer += iprot->readListBegin(_etype242, _size239);
                        this->multisig_wallets.resize(_size239);
                        uint32_t _i243;
                        for (_i243 = 0; _i243 < _size239; ++_i243)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i243]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size244;
                        ::apache::thrift::protocol::TType _etype247;
                        xfer += iprot->readListBegin(_etype247, _size244);
                        this->multisig_signs.resize(_size244);
                        uint32_t _i248;
                        for (_i248 = 0; _i248 < _size244; ++_i248)
                        {
                            xfer += this->multisig_signs[_i248].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter249;
            for (_iter249 = this->peer_nodes_list.begin(); _iter249 != this->peer_nodes_list.end(); ++_iter249)
            {
                xfer += oprot->writeString((*_iter249));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter250;
            for (_iter250 = this->multisig_wallets.begin(); _iter250 != this->multisig_wallets.end(); ++_iter250)
            {
                xfer += oprot->writeString((*_iter250));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter251;
            for (_iter251 = this->multisig_signs.begin(); _iter251 != this->multisig_signs.end(); ++_iter251)
            {
                xfer += (*_iter251).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req_data& a, node_list_task_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_list_task_req_data::node_list_task_req_data(const node_list_task_req_data& other252) {
        task_id = other252.task_id;
        peer_nodes_list = other252.peer_nodes_list;
        additional = other252.additional;
        wallet = other252.wallet;
        nonce = other252.nonce;
        sign = other252.sign;
        multisig_wallets = other252.multisig_wallets;
        multisig_threshold = other252.multisig_threshold;
        multisig_signs = other252.multisig_signs;
        session_id = other252.session_id;
        session_id_sign = other252.session_id_sign;
    }
    node_list_task_req_data& node_list_task_req_data::operator=(const node_list_task_req_data& other253) {
        task_id = other253.task_id;
        peer_nodes_list = other253.peer_nodes_list;
        additional = other253.additional;
        wallet = other253.wallet;
        nonce = other253.nonce;
        sign = other253.sign;
        multisig_wallets = other253.multisig_wallets;
        multisig_threshold = other253.multisig_threshold;
        multisig_signs = other253.multisig_signs;
        session_id = other253.session_id;
        session_id_sign = other253.session_id_sign;
        return *this;
    }
    void node_list_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_list_task_req_body::~node_list_task_req_body() throw() {
    }


    void node_list_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req_body& a, node_list_task_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_task_req_body::node_list_task_req_body(const node_list_task_req_body& other254) {
        data = other254.data;
    }
    node_list_task_req_body& node_list_task_req_body::operator=(const node_list_task_req_body& other255) {
        data = other255.data;
        return *this;
    }
    void node_list_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_task_req::~node_list_task_req() throw() {
    }


    void node_list_task_req::__set_body(const node_list_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_req& a, node_list_task_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_task_req::node_list_task_req(const node_list_task_req& other256) {
        body = other256.body;
        __isset = other256.__isset;
    }
    node_list_task_req& node_list_task_req::operator=(const node_list_task_req& other257) {
        body = other257.body;
        __isset = other257.__isset;
        return *this;
    }
    void node_list_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_task_rsp_body::~node_list_task_rsp_body() throw() {
    }


    void node_list_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_rsp_body& a, node_list_task_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_task_rsp_body::node_list_task_rsp_body(const node_list_task_rsp_body& other258) {
        data = other258.data;
    }
    node_list_task_rsp_body& node_list_task_rsp_body::operator=(const node_list_task_rsp_body& other259) {
        data = other259.data;
        return *this;
    }
    void node_list_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_task_rsp::~node_list_task_rsp() throw() {
    }


    void node_list_task_rsp::__set_body(const node_list_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_task_rsp& a, node_list_task_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_task_rsp::node_list_task_rsp(const node_list_task_rsp& other260) {
        body = other260.body;
        __isset = other260.__isset;
    }
    node_list_task_rsp& node_list_task_rsp::operator=(const node_list_task_rsp& other261) {
        body = other261.body;
        __isset = other261.__isset;
        return *this;
    }
    void node_list_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_task_req_data::~node_create_task_req_data() throw() {
    }


    void node_create_task_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_create_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_create_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_create_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_create_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_create_task_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_create_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_create_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_create_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_create_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_create_task_req_data::__set_image_server(const std::string& val) {
        this->image_server = val;
        __isset.image_server = true;
    }

    void node_create_task_req_data::__set_custom_image_name(const std::string& val) {
        this->custom_image_name = val;
        __isset.custom_image_name = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size262;
                        ::apache::thrift::protocol::TType _etype265;
                        xfer += iprot->readListBegin(_etype265, _size262);
                        this->peer_nodes_list.resize(_size262);
                        uint32_t _i266;
                        for (_i266 = 0; _i266 < _size262; ++_i266)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i266]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size267;
                        ::apache::thrift::protocol::TType _etype270;
                        xfer += iprot->readListBegin(_etype270, _size267);
                        this->multisig_wallets.resize(_size267);
                        uint32_t _i271;
                        for (_i271 = 0; _i271 < _size267; ++_i271)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i271]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size272;
                        ::apache::thrift::protocol::TType _etype275;
                        xfer += iprot->readListBegin(_etype275, _size272);
                        this->multisig_signs.resize(_size272);
                        uint32_t _i276;
                        for (_i276 = 0; _i276 < _size272; ++_i276)
                        {
                            xfer += this->multisig_signs[_i276].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->image_server);
                    this->__isset.image_server = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 12:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->custom_image_name);
                    this->__isset.custom_image_name = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter277;
            for (_iter277 = this->peer_nodes_list.begin(); _iter277 != this->peer_nodes_list.end(); ++_iter277)
            {
                xfer += oprot->writeString((*_iter277));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter278;
            for (_iter278 = this->multisig_wallets.begin(); _iter278 != this->multisig_wallets.end(); ++_iter278)
            {
                xfer += oprot->writeString((*_iter278));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter279;
            for (_iter279 = this->multisig_signs.begin(); _iter279 != this->multisig_signs.end(); ++_iter279)
            {
                xfer += (*_iter279).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.image_server) {
            xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_STRING, 11);
            xfer += oprot->writeString(this->image_server);
            xfer += oprot->writeFieldEnd();
        }
        if (this->__isset.custom_image_name) {
            xfer += oprot->writeFieldBegin("custom_image_name", ::apache::thrift::protocol::T_STRING, 12);
            xfer += oprot->writeString(this->custom_image_name);
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req_data& a, node_create_task_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.image_server, b.image_server);
        swap(a.custom_image_name, b.custom_image_name);
        swap(a.__isset, b.__isset);
    }

    node_create_task_req_data::node_create_task_req_data(const node_create_task_req_data& other280) {
        peer_nodes_list = other280.peer_nodes_list;
        additional = other280.additional;
        wallet = other280.wallet;
        nonce = other280.nonce;
        sign = other280.sign;
        multisig_wallets = other280.multisig_wallets;
        multisig_threshold = other280.multisig_threshold;
        multisig_signs = other280.multisig_signs;
        session_id = other280.session_id;
        session_id_sign = other280.session_id_sign;
        image_server = other280.image_server;
        custom_image_name = other280.custom_image_name;
        __isset = other280.__isset;
    }
    node_create_task_req_data& node_create_task_req_data::operator=(const node_create_task_req_data& other281) {
        peer_nodes_list = other281.peer_nodes_list;
        additional = other281.additional;
        wallet = other281.wallet;
        nonce = other281.nonce;
        sign = other281.sign;
        multisig_wallets = other281.multisig_wallets;
        multisig_threshold = other281.multisig_threshold;
        multisig_signs = other281.multisig_signs;
        session_id = other281.session_id;
        session_id_sign = other281.session_id_sign;
        image_server = other281.image_server;
        custom_image_name = other281.custom_image_name;
        __isset = other281.__isset;
        return *this;
    }
    void node_create_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
        out << ", " << "custom_image_name="; (__isset.custom_image_name ? (out << to_string(custom_image_name)) : (out << "<null>"));
        out << ")";
    }


    node_create_task_req_body::~node_create_task_req_body() throw() {
    }


    void node_create_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req_body& a, node_create_task_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_task_req_body::node_create_task_req_body(const node_create_task_req_body& other282) {
        data = other282.data;
    }
    node_create_task_req_body& node_create_task_req_body::operator=(const node_create_task_req_body& other283) {
        data = other283.data;
        return *this;
    }
    void node_create_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_task_req::~node_create_task_req() throw() {
    }


    void node_create_task_req::__set_body(const node_create_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_req& a, node_create_task_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_task_req::node_create_task_req(const node_create_task_req& other284) {
        body = other284.body;
        __isset = other284.__isset;
    }
    node_create_task_req& node_create_task_req::operator=(const node_create_task_req& other285) {
        body = other285.body;
        __isset = other285.__isset;
        return *this;
    }
    void node_create_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_task_rsp_body::~node_create_task_rsp_body() throw() {
    }


    void node_create_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_rsp_body& a, node_create_task_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_task_rsp_body::node_create_task_rsp_body(const node_create_task_rsp_body& other286) {
        data = other286.data;
    }
    node_create_task_rsp_body& node_create_task_rsp_body::operator=(const node_create_task_rsp_body& other287) {
        data = other287.data;
        return *this;
    }
    void node_create_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_task_rsp::~node_create_task_rsp() throw() {
    }


    void node_create_task_rsp::__set_body(const node_create_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_task_rsp& a, node_create_task_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_task_rsp::node_create_task_rsp(const node_create_task_rsp& other288) {
        body = other288.body;
        __isset = other288.__isset;
    }
    node_create_task_rsp& node_create_task_rsp::operator=(const node_create_task_rsp& other289) {
        body = other289.body;
        __isset = other289.__isset;
        return *this;
    }
    void node_create_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_start_task_req_data::~node_start_task_req_data() throw() {
    }


    void node_start_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_start_task_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_start_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_start_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_start_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_start_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_start_task_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_start_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_start_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_start_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_start_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size290;
                        ::apache::thrift::protocol::TType _etype293;
                        xfer += iprot->readListBegin(_etype293, _size290);
                        this->peer_nodes_list.resize(_size290);
                        uint32_t _i294;
                        for (_i294 = 0; _i294 < _size290; ++_i294)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i294]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size295;
                        ::apache::thrift::protocol::TType _etype298;
                        xfer += iprot->readListBegin(_etype298, _size295);
                        this->multisig_wallets.resize(_size295);
                        uint32_t _i299;
                        for (_i299 = 0; _i299 < _size295; ++_i299)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i299]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size300;
                        ::apache::thrift::protocol::TType _etype303;
                        xfer += iprot->readListBegin(_etype303, _size300);
                        this->multisig_signs.resize(_size300);
                        uint32_t _i304;
                        for (_i304 = 0; _i304 < _size300; ++_i304)
                        {
                            xfer += this->multisig_signs[_i304].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter305;
            for (_iter305 = this->peer_nodes_list.begin(); _iter305 != this->peer_nodes_list.end(); ++_iter305)
            {
                xfer += oprot->writeString((*_iter305));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter306;
            for (_iter306 = this->multisig_wallets.begin(); _iter306 != this->multisig_wallets.end(); ++_iter306)
            {
                xfer += oprot->writeString((*_iter306));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter307;
            for (_iter307 = this->multisig_signs.begin(); _iter307 != this->multisig_signs.end(); ++_iter307)
            {
                xfer += (*_iter307).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req_data& a, node_start_task_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_start_task_req_data::node_start_task_req_data(const node_start_task_req_data& other308) {
        task_id = other308.task_id;
        peer_nodes_list = other308.peer_nodes_list;
        additional = other308.additional;
        wallet = other308.wallet;
        nonce = other308.nonce;
        sign = other308.sign;
        multisig_wallets = other308.multisig_wallets;
        multisig_threshold = other308.multisig_threshold;
        multisig_signs = other308.multisig_signs;
        session_id = other308.session_id;
        session_id_sign = other308.session_id_sign;
    }
    node_start_task_req_data& node_start_task_req_data::operator=(const node_start_task_req_data& other309) {
        task_id = other309.task_id;
        peer_nodes_list = other309.peer_nodes_list;
        additional = other309.additional;
        wallet = other309.wallet;
        nonce = other309.nonce;
        sign = other309.sign;
        multisig_wallets = other309.multisig_wallets;
        multisig_threshold = other309.multisig_threshold;
        multisig_signs = other309.multisig_signs;
        session_id = other309.session_id;
        session_id_sign = other309.session_id_sign;
        return *this;
    }
    void node_start_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_start_task_req_body::~node_start_task_req_body() throw() {
    }


    void node_start_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req_body& a, node_start_task_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_start_task_req_body::node_start_task_req_body(const node_start_task_req_body& other310) {
        data = other310.data;
    }
    node_start_task_req_body& node_start_task_req_body::operator=(const node_start_task_req_body& other311) {
        data = other311.data;
        return *this;
    }
    void node_start_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_start_task_req::~node_start_task_req() throw() {
    }


    void node_start_task_req::__set_body(const node_start_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_start_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_req& a, node_start_task_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_start_task_req::node_start_task_req(const node_start_task_req& other312) {
        body = other312.body;
        __isset = other312.__isset;
    }
    node_start_task_req& node_start_task_req::operator=(const node_start_task_req& other313) {
        body = other313.body;
        __isset = other313.__isset;
        return *this;
    }
    void node_start_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_start_task_rsp_body::~node_start_task_rsp_body() throw() {
    }


    void node_start_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_start_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_rsp_body& a, node_start_task_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_start_task_rsp_body::node_start_task_rsp_body(const node_start_task_rsp_body& other314) {
        data = other314.data;
    }
    node_start_task_rsp_body& node_start_task_rsp_body::operator=(const node_start_task_rsp_body& other315) {
        data = other315.data;
        return *this;
    }
    void node_start_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_start_task_rsp::~node_start_task_rsp() throw() {
    }


    void node_start_task_rsp::__set_body(const node_start_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_start_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_start_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_start_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_start_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_start_task_rsp& a, node_start_task_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_start_task_rsp::node_start_task_rsp(const node_start_task_rsp& other316) {
        body = other316.body;
        __isset = other316.__isset;
    }
    node_start_task_rsp& node_start_task_rsp::operator=(const node_start_task_rsp& other317) {
        body = other317.body;
        __isset = other317.__isset;
        return *this;
    }
    void node_start_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_start_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_task_req_data::~node_stop_task_req_data() throw() {
    }


    void node_stop_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_stop_task_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_stop_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_stop_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_stop_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_stop_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_stop_task_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_stop_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_stop_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_stop_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_stop_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size318;
                        ::apache::thrift::protocol::TType _etype321;
                        xfer += iprot->readListBegin(_etype321, _size318);
                        this->peer_nodes_list.resize(_size318);
                        uint32_t _i322;
                        for (_i322 = 0; _i322 < _size318; ++_i322)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i322]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size323;
                        ::apache::thrift::protocol::TType _etype326;
                        xfer += iprot->readListBegin(_etype326, _size323);
                        this->multisig_wallets.resize(_size323);
                        uint32_t _i327;
                        for (_i327 = 0; _i327 < _size323; ++_i327)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i327]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size328;
                        ::apache::thrift::protocol::TType _etype331;
                        xfer += iprot->readListBegin(_etype331, _size328);
                        this->multisig_signs.resize(_size328);
                        uint32_t _i332;
                        for (_i332 = 0; _i332 < _size328; ++_i332)
                        {
                            xfer += this->multisig_signs[_i332].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter333;
            for (_iter333 = this->peer_nodes_list.begin(); _iter333 != this->peer_nodes_list.end(); ++_iter333)
            {
                xfer += oprot->writeString((*_iter333));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter334;
            for (_iter334 = this->multisig_wallets.begin(); _iter334 != this->multisig_wallets.end(); ++_iter334)
            {
                xfer += oprot->writeString((*_iter334));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter335;
            for (_iter335 = this->multisig_signs.begin(); _iter335 != this->multisig_signs.end(); ++_iter335)
            {
                xfer += (*_iter335).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req_data& a, node_stop_task_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_stop_task_req_data::node_stop_task_req_data(const node_stop_task_req_data& other336) {
        task_id = other336.task_id;
        peer_nodes_list = other336.peer_nodes_list;
        additional = other336.additional;
        wallet = other336.wallet;
        nonce = other336.nonce;
        sign = other336.sign;
        multisig_wallets = other336.multisig_wallets;
        multisig_threshold = other336.multisig_threshold;
        multisig_signs = other336.multisig_signs;
        session_id = other336.session_id;
        session_id_sign = other336.session_id_sign;
    }
    node_stop_task_req_data& node_stop_task_req_data::operator=(const node_stop_task_req_data& other337) {
        task_id = other337.task_id;
        peer_nodes_list = other337.peer_nodes_list;
        additional = other337.additional;
        wallet = other337.wallet;
        nonce = other337.nonce;
        sign = other337.sign;
        multisig_wallets = other337.multisig_wallets;
        multisig_threshold = other337.multisig_threshold;
        multisig_signs = other337.multisig_signs;
        session_id = other337.session_id;
        session_id_sign = other337.session_id_sign;
        return *this;
    }
    void node_stop_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_stop_task_req_body::~node_stop_task_req_body() throw() {
    }


    void node_stop_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req_body& a, node_stop_task_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_task_req_body::node_stop_task_req_body(const node_stop_task_req_body& other338) {
        data = other338.data;
    }
    node_stop_task_req_body& node_stop_task_req_body::operator=(const node_stop_task_req_body& other339) {
        data = other339.data;
        return *this;
    }
    void node_stop_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_task_req::~node_stop_task_req() throw() {
    }


    void node_stop_task_req::__set_body(const node_stop_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_req& a, node_stop_task_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_task_req::node_stop_task_req(const node_stop_task_req& other340) {
        body = other340.body;
        __isset = other340.__isset;
    }
    node_stop_task_req& node_stop_task_req::operator=(const node_stop_task_req& other341) {
        body = other341.body;
        __isset = other341.__isset;
        return *this;
    }
    void node_stop_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_stop_task_rsp_body::~node_stop_task_rsp_body() throw() {
    }


    void node_stop_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_stop_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_rsp_body& a, node_stop_task_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_stop_task_rsp_body::node_stop_task_rsp_body(const node_stop_task_rsp_body& other342) {
        data = other342.data;
    }
    node_stop_task_rsp_body& node_stop_task_rsp_body::operator=(const node_stop_task_rsp_body& other343) {
        data = other343.data;
        return *this;
    }
    void node_stop_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_stop_task_rsp::~node_stop_task_rsp() throw() {
    }


    void node_stop_task_rsp::__set_body(const node_stop_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_stop_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_stop_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_stop_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_stop_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_stop_task_rsp& a, node_stop_task_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_stop_task_rsp::node_stop_task_rsp(const node_stop_task_rsp& other344) {
        body = other344.body;
        __isset = other344.__isset;
    }
    node_stop_task_rsp& node_stop_task_rsp::operator=(const node_stop_task_rsp& other345) {
        body = other345.body;
        __isset = other345.__isset;
        return *this;
    }
    void node_stop_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_stop_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_restart_task_req_data::~node_restart_task_req_data() throw() {
    }


    void node_restart_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_restart_task_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_restart_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_restart_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_restart_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_restart_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_restart_task_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_restart_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_restart_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_restart_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_restart_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_restart_task_req_data::__set_force_reboot(const int16_t val) {
        this->force_reboot = val;
        __isset.force_reboot = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size346;
                        ::apache::thrift::protocol::TType _etype349;
                        xfer += iprot->readListBegin(_etype349, _size346);
                        this->peer_nodes_list.resize(_size346);
                        uint32_t _i350;
                        for (_i350 = 0; _i350 < _size346; ++_i350)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i350]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size351;
                        ::apache::thrift::protocol::TType _etype354;
                        xfer += iprot->readListBegin(_etype354, _size351);
                        this->multisig_wallets.resize(_size351);
                        uint32_t _i355;
                        for (_i355 = 0; _i355 < _size351; ++_i355)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i355]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size356;
                        ::apache::thrift::protocol::TType _etype359;
                        xfer += iprot->readListBegin(_etype359, _size356);
                        this->multisig_signs.resize(_size356);
                        uint32_t _i360;
                        for (_i360 = 0; _i360 < _size356; ++_i360)
                        {
                            xfer += this->multisig_signs[_i360].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 12:
                if (ftype == ::apache::thrift::protocol::T_I16) {
                    xfer += iprot->readI16(this->force_reboot);
                    this->__isset.force_reboot = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter361;
            for (_iter361 = this->peer_nodes_list.begin(); _iter361 != this->peer_nodes_list.end(); ++_iter361)
            {
                xfer += oprot->writeString((*_iter361));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter362;
            for (_iter362 = this->multisig_wallets.begin(); _iter362 != this->multisig_wallets.end(); ++_iter362)
            {
                xfer += oprot->writeString((*_iter362));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter363;
            for (_iter363 = this->multisig_signs.begin(); _iter363 != this->multisig_signs.end(); ++_iter363)
            {
                xfer += (*_iter363).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.force_reboot) {
            xfer += oprot->writeFieldBegin("force_reboot", ::apache::thrift::protocol::T_I16, 12);
            xfer += oprot->writeI16(this->force_reboot);
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req_data& a, node_restart_task_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.force_reboot, b.force_reboot);
        swap(a.__isset, b.__isset);
    }

    node_restart_task_req_data::node_restart_task_req_data(const node_restart_task_req_data& other364) {
        task_id = other364.task_id;
        peer_nodes_list = other364.peer_nodes_list;
        additional = other364.additional;
        wallet = other364.wallet;
        nonce = other364.nonce;
        sign = other364.sign;
        multisig_wallets = other364.multisig_wallets;
        multisig_threshold = other364.multisig_threshold;
        multisig_signs = other364.multisig_signs;
        session_id = other364.session_id;
        session_id_sign = other364.session_id_sign;
        force_reboot = other364.force_reboot;
        __isset = other364.__isset;
    }
    node_restart_task_req_data& node_restart_task_req_data::operator=(const node_restart_task_req_data& other365) {
        task_id = other365.task_id;
        peer_nodes_list = other365.peer_nodes_list;
        additional = other365.additional;
        wallet = other365.wallet;
        nonce = other365.nonce;
        sign = other365.sign;
        multisig_wallets = other365.multisig_wallets;
        multisig_threshold = other365.multisig_threshold;
        multisig_signs = other365.multisig_signs;
        session_id = other365.session_id;
        session_id_sign = other365.session_id_sign;
        force_reboot = other365.force_reboot;
        __isset = other365.__isset;
        return *this;
    }
    void node_restart_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "force_reboot="; (__isset.force_reboot ? (out << to_string(force_reboot)) : (out << "<null>"));
        out << ")";
    }


    node_restart_task_req_body::~node_restart_task_req_body() throw() {
    }


    void node_restart_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req_body& a, node_restart_task_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_restart_task_req_body::node_restart_task_req_body(const node_restart_task_req_body& other366) {
        data = other366.data;
    }
    node_restart_task_req_body& node_restart_task_req_body::operator=(const node_restart_task_req_body& other367) {
        data = other367.data;
        return *this;
    }
    void node_restart_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_restart_task_req::~node_restart_task_req() throw() {
    }


    void node_restart_task_req::__set_body(const node_restart_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_restart_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_req& a, node_restart_task_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_restart_task_req::node_restart_task_req(const node_restart_task_req& other368) {
        body = other368.body;
        __isset = other368.__isset;
    }
    node_restart_task_req& node_restart_task_req::operator=(const node_restart_task_req& other369) {
        body = other369.body;
        __isset = other369.__isset;
        return *this;
    }
    void node_restart_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_restart_task_rsp_body::~node_restart_task_rsp_body() throw() {
    }


    void node_restart_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_restart_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_rsp_body& a, node_restart_task_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_restart_task_rsp_body::node_restart_task_rsp_body(const node_restart_task_rsp_body& other370) {
        data = other370.data;
    }
    node_restart_task_rsp_body& node_restart_task_rsp_body::operator=(const node_restart_task_rsp_body& other371) {
        data = other371.data;
        return *this;
    }
    void node_restart_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_restart_task_rsp::~node_restart_task_rsp() throw() {
    }


    void node_restart_task_rsp::__set_body(const node_restart_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_restart_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_restart_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_restart_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_restart_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_restart_task_rsp& a, node_restart_task_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_restart_task_rsp::node_restart_task_rsp(const node_restart_task_rsp& other372) {
        body = other372.body;
        __isset = other372.__isset;
    }
    node_restart_task_rsp& node_restart_task_rsp::operator=(const node_restart_task_rsp& other373) {
        body = other373.body;
        __isset = other373.__isset;
        return *this;
    }
    void node_restart_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_restart_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_reset_task_req_data::~node_reset_task_req_data() throw() {
    }


    void node_reset_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_reset_task_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_reset_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_reset_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_reset_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_reset_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_reset_task_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_reset_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_reset_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_reset_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_reset_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size374;
                        ::apache::thrift::protocol::TType _etype377;
                        xfer += iprot->readListBegin(_etype377, _size374);
                        this->peer_nodes_list.resize(_size374);
                        uint32_t _i378;
                        for (_i378 = 0; _i378 < _size374; ++_i378)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i378]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size379;
                        ::apache::thrift::protocol::TType _etype382;
                        xfer += iprot->readListBegin(_etype382, _size379);
                        this->multisig_wallets.resize(_size379);
                        uint32_t _i383;
                        for (_i383 = 0; _i383 < _size379; ++_i383)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i383]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size384;
                        ::apache::thrift::protocol::TType _etype387;
                        xfer += iprot->readListBegin(_etype387, _size384);
                        this->multisig_signs.resize(_size384);
                        uint32_t _i388;
                        for (_i388 = 0; _i388 < _size384; ++_i388)
                        {
                            xfer += this->multisig_signs[_i388].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter389;
            for (_iter389 = this->peer_nodes_list.begin(); _iter389 != this->peer_nodes_list.end(); ++_iter389)
            {
                xfer += oprot->writeString((*_iter389));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter390;
            for (_iter390 = this->multisig_wallets.begin(); _iter390 != this->multisig_wallets.end(); ++_iter390)
            {
                xfer += oprot->writeString((*_iter390));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter391;
            for (_iter391 = this->multisig_signs.begin(); _iter391 != this->multisig_signs.end(); ++_iter391)
            {
                xfer += (*_iter391).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req_data& a, node_reset_task_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_reset_task_req_data::node_reset_task_req_data(const node_reset_task_req_data& other392) {
        task_id = other392.task_id;
        peer_nodes_list = other392.peer_nodes_list;
        additional = other392.additional;
        wallet = other392.wallet;
        nonce = other392.nonce;
        sign = other392.sign;
        multisig_wallets = other392.multisig_wallets;
        multisig_threshold = other392.multisig_threshold;
        multisig_signs = other392.multisig_signs;
        session_id = other392.session_id;
        session_id_sign = other392.session_id_sign;
    }
    node_reset_task_req_data& node_reset_task_req_data::operator=(const node_reset_task_req_data& other393) {
        task_id = other393.task_id;
        peer_nodes_list = other393.peer_nodes_list;
        additional = other393.additional;
        wallet = other393.wallet;
        nonce = other393.nonce;
        sign = other393.sign;
        multisig_wallets = other393.multisig_wallets;
        multisig_threshold = other393.multisig_threshold;
        multisig_signs = other393.multisig_signs;
        session_id = other393.session_id;
        session_id_sign = other393.session_id_sign;
        return *this;
    }
    void node_reset_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_reset_task_req_body::~node_reset_task_req_body() throw() {
    }


    void node_reset_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req_body& a, node_reset_task_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_reset_task_req_body::node_reset_task_req_body(const node_reset_task_req_body& other394) {
        data = other394.data;
    }
    node_reset_task_req_body& node_reset_task_req_body::operator=(const node_reset_task_req_body& other395) {
        data = other395.data;
        return *this;
    }
    void node_reset_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_reset_task_req::~node_reset_task_req() throw() {
    }


    void node_reset_task_req::__set_body(const node_reset_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_reset_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_req& a, node_reset_task_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_reset_task_req::node_reset_task_req(const node_reset_task_req& other396) {
        body = other396.body;
        __isset = other396.__isset;
    }
    node_reset_task_req& node_reset_task_req::operator=(const node_reset_task_req& other397) {
        body = other397.body;
        __isset = other397.__isset;
        return *this;
    }
    void node_reset_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_reset_task_rsp_body::~node_reset_task_rsp_body() throw() {
    }


    void node_reset_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_reset_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_rsp_body& a, node_reset_task_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_reset_task_rsp_body::node_reset_task_rsp_body(const node_reset_task_rsp_body& other398) {
        data = other398.data;
    }
    node_reset_task_rsp_body& node_reset_task_rsp_body::operator=(const node_reset_task_rsp_body& other399) {
        data = other399.data;
        return *this;
    }
    void node_reset_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_reset_task_rsp::~node_reset_task_rsp() throw() {
    }


    void node_reset_task_rsp::__set_body(const node_reset_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_reset_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_reset_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_reset_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_reset_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_reset_task_rsp& a, node_reset_task_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_reset_task_rsp::node_reset_task_rsp(const node_reset_task_rsp& other400) {
        body = other400.body;
        __isset = other400.__isset;
    }
    node_reset_task_rsp& node_reset_task_rsp::operator=(const node_reset_task_rsp& other401) {
        body = other401.body;
        __isset = other401.__isset;
        return *this;
    }
    void node_reset_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_reset_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_task_req_data::~node_delete_task_req_data() throw() {
    }


    void node_delete_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_delete_task_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_delete_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_delete_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_delete_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_delete_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_delete_task_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_delete_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_delete_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_delete_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_delete_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size402;
                        ::apache::thrift::protocol::TType _etype405;
                        xfer += iprot->readListBegin(_etype405, _size402);
                        this->peer_nodes_list.resize(_size402);
                        uint32_t _i406;
                        for (_i406 = 0; _i406 < _size402; ++_i406)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i406]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size407;
                        ::apache::thrift::protocol::TType _etype410;
                        xfer += iprot->readListBegin(_etype410, _size407);
                        this->multisig_wallets.resize(_size407);
                        uint32_t _i411;
                        for (_i411 = 0; _i411 < _size407; ++_i411)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i411]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size412;
                        ::apache::thrift::protocol::TType _etype415;
                        xfer += iprot->readListBegin(_etype415, _size412);
                        this->multisig_signs.resize(_size412);
                        uint32_t _i416;
                        for (_i416 = 0; _i416 < _size412; ++_i416)
                        {
                            xfer += this->multisig_signs[_i416].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter417;
            for (_iter417 = this->peer_nodes_list.begin(); _iter417 != this->peer_nodes_list.end(); ++_iter417)
            {
                xfer += oprot->writeString((*_iter417));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter418;
            for (_iter418 = this->multisig_wallets.begin(); _iter418 != this->multisig_wallets.end(); ++_iter418)
            {
                xfer += oprot->writeString((*_iter418));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter419;
            for (_iter419 = this->multisig_signs.begin(); _iter419 != this->multisig_signs.end(); ++_iter419)
            {
                xfer += (*_iter419).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req_data& a, node_delete_task_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_delete_task_req_data::node_delete_task_req_data(const node_delete_task_req_data& other420) {
        task_id = other420.task_id;
        peer_nodes_list = other420.peer_nodes_list;
        additional = other420.additional;
        wallet = other420.wallet;
        nonce = other420.nonce;
        sign = other420.sign;
        multisig_wallets = other420.multisig_wallets;
        multisig_threshold = other420.multisig_threshold;
        multisig_signs = other420.multisig_signs;
        session_id = other420.session_id;
        session_id_sign = other420.session_id_sign;
    }
    node_delete_task_req_data& node_delete_task_req_data::operator=(const node_delete_task_req_data& other421) {
        task_id = other421.task_id;
        peer_nodes_list = other421.peer_nodes_list;
        additional = other421.additional;
        wallet = other421.wallet;
        nonce = other421.nonce;
        sign = other421.sign;
        multisig_wallets = other421.multisig_wallets;
        multisig_threshold = other421.multisig_threshold;
        multisig_signs = other421.multisig_signs;
        session_id = other421.session_id;
        session_id_sign = other421.session_id_sign;
        return *this;
    }
    void node_delete_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_delete_task_req_body::~node_delete_task_req_body() throw() {
    }


    void node_delete_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req_body& a, node_delete_task_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_task_req_body::node_delete_task_req_body(const node_delete_task_req_body& other422) {
        data = other422.data;
    }
    node_delete_task_req_body& node_delete_task_req_body::operator=(const node_delete_task_req_body& other423) {
        data = other423.data;
        return *this;
    }
    void node_delete_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_task_req::~node_delete_task_req() throw() {
    }


    void node_delete_task_req::__set_body(const node_delete_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_req& a, node_delete_task_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_task_req::node_delete_task_req(const node_delete_task_req& other424) {
        body = other424.body;
        __isset = other424.__isset;
    }
    node_delete_task_req& node_delete_task_req::operator=(const node_delete_task_req& other425) {
        body = other425.body;
        __isset = other425.__isset;
        return *this;
    }
    void node_delete_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_task_rsp_body::~node_delete_task_rsp_body() throw() {
    }


    void node_delete_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_rsp_body& a, node_delete_task_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_task_rsp_body::node_delete_task_rsp_body(const node_delete_task_rsp_body& other426) {
        data = other426.data;
    }
    node_delete_task_rsp_body& node_delete_task_rsp_body::operator=(const node_delete_task_rsp_body& other427) {
        data = other427.data;
        return *this;
    }
    void node_delete_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_task_rsp::~node_delete_task_rsp() throw() {
    }


    void node_delete_task_rsp::__set_body(const node_delete_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_task_rsp& a, node_delete_task_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_task_rsp::node_delete_task_rsp(const node_delete_task_rsp& other428) {
        body = other428.body;
        __isset = other428.__isset;
    }
    node_delete_task_rsp& node_delete_task_rsp::operator=(const node_delete_task_rsp& other429) {
        body = other429.body;
        __isset = other429.__isset;
        return *this;
    }
    void node_delete_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_task_logs_req_data::~node_task_logs_req_data() throw() {
    }


    void node_task_logs_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_task_logs_req_data::__set_head_or_tail(const int16_t val) {
        this->head_or_tail = val;
    }

    void node_task_logs_req_data::__set_number_of_lines(const int32_t val) {
        this->number_of_lines = val;
    }

    void node_task_logs_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_task_logs_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_task_logs_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_task_logs_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_task_logs_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_task_logs_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_task_logs_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_task_logs_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_task_logs_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_task_logs_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_head_or_tail = false;
        bool isset_number_of_lines = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_I16) {
                    xfer += iprot->readI16(this->head_or_tail);
                    isset_head_or_tail = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->number_of_lines);
                    isset_number_of_lines = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size430;
                        ::apache::thrift::protocol::TType _etype433;
                        xfer += iprot->readListBegin(_etype433, _size430);
                        this->peer_nodes_list.resize(_size430);
                        uint32_t _i434;
                        for (_i434 = 0; _i434 < _size430; ++_i434)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i434]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size435;
                        ::apache::thrift::protocol::TType _etype438;
                        xfer += iprot->readListBegin(_etype438, _size435);
                        this->multisig_wallets.resize(_size435);
                        uint32_t _i439;
                        for (_i439 = 0; _i439 < _size435; ++_i439)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i439]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size440;
                        ::apache::thrift::protocol::TType _etype443;
                        xfer += iprot->readListBegin(_etype443, _size440);
                        this->multisig_signs.resize(_size440);
                        uint32_t _i444;
                        for (_i444 = 0; _i444 < _size440; ++_i444)
                        {
                            xfer += this->multisig_signs[_i444].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 12:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 13:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_head_or_tail)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_number_of_lines)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("head_or_tail", ::apache::thrift::protocol::T_I16, 2);
        xfer += oprot->writeI16(this->head_or_tail);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("number_of_lines", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->number_of_lines);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 4);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter445;
            for (_iter445 = this->peer_nodes_list.begin(); _iter445 != this->peer_nodes_list.end(); ++_iter445)
            {
                xfer += oprot->writeString((*_iter445));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 8);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter446;
            for (_iter446 = this->multisig_wallets.begin(); _iter446 != this->multisig_wallets.end(); ++_iter446)
            {
                xfer += oprot->writeString((*_iter446));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 10);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 11);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter447;
            for (_iter447 = this->multisig_signs.begin(); _iter447 != this->multisig_signs.end(); ++_iter447)
            {
                xfer += (*_iter447).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 12);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 13);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req_data& a, node_task_logs_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.head_or_tail, b.head_or_tail);
        swap(a.number_of_lines, b.number_of_lines);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_task_logs_req_data::node_task_logs_req_data(const node_task_logs_req_data& other448) {
        task_id = other448.task_id;
        head_or_tail = other448.head_or_tail;
        number_of_lines = other448.number_of_lines;
        peer_nodes_list = other448.peer_nodes_list;
        additional = other448.additional;
        wallet = other448.wallet;
        nonce = other448.nonce;
        sign = other448.sign;
        multisig_wallets = other448.multisig_wallets;
        multisig_threshold = other448.multisig_threshold;
        multisig_signs = other448.multisig_signs;
        session_id = other448.session_id;
        session_id_sign = other448.session_id_sign;
    }
    node_task_logs_req_data& node_task_logs_req_data::operator=(const node_task_logs_req_data& other449) {
        task_id = other449.task_id;
        head_or_tail = other449.head_or_tail;
        number_of_lines = other449.number_of_lines;
        peer_nodes_list = other449.peer_nodes_list;
        additional = other449.additional;
        wallet = other449.wallet;
        nonce = other449.nonce;
        sign = other449.sign;
        multisig_wallets = other449.multisig_wallets;
        multisig_threshold = other449.multisig_threshold;
        multisig_signs = other449.multisig_signs;
        session_id = other449.session_id;
        session_id_sign = other449.session_id_sign;
        return *this;
    }
    void node_task_logs_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "head_or_tail=" << to_string(head_or_tail);
        out << ", " << "number_of_lines=" << to_string(number_of_lines);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_task_logs_req_body::~node_task_logs_req_body() throw() {
    }


    void node_task_logs_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req_body& a, node_task_logs_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_task_logs_req_body::node_task_logs_req_body(const node_task_logs_req_body& other450) {
        data = other450.data;
    }
    node_task_logs_req_body& node_task_logs_req_body::operator=(const node_task_logs_req_body& other451) {
        data = other451.data;
        return *this;
    }
    void node_task_logs_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_task_logs_req::~node_task_logs_req() throw() {
    }


    void node_task_logs_req::__set_body(const node_task_logs_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_task_logs_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_req& a, node_task_logs_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_task_logs_req::node_task_logs_req(const node_task_logs_req& other452) {
        body = other452.body;
        __isset = other452.__isset;
    }
    node_task_logs_req& node_task_logs_req::operator=(const node_task_logs_req& other453) {
        body = other453.body;
        __isset = other453.__isset;
        return *this;
    }
    void node_task_logs_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_task_logs_rsp_body::~node_task_logs_rsp_body() throw() {
    }


    void node_task_logs_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_task_logs_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_rsp_body& a, node_task_logs_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_task_logs_rsp_body::node_task_logs_rsp_body(const node_task_logs_rsp_body& other454) {
        data = other454.data;
    }
    node_task_logs_rsp_body& node_task_logs_rsp_body::operator=(const node_task_logs_rsp_body& other455) {
        data = other455.data;
        return *this;
    }
    void node_task_logs_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_task_logs_rsp::~node_task_logs_rsp() throw() {
    }


    void node_task_logs_rsp::__set_body(const node_task_logs_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_task_logs_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_task_logs_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_task_logs_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_task_logs_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_task_logs_rsp& a, node_task_logs_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_task_logs_rsp::node_task_logs_rsp(const node_task_logs_rsp& other456) {
        body = other456.body;
        __isset = other456.__isset;
    }
    node_task_logs_rsp& node_task_logs_rsp::operator=(const node_task_logs_rsp& other457) {
        body = other457.body;
        __isset = other457.__isset;
        return *this;
    }
    void node_task_logs_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_task_logs_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_modify_task_req_data::~node_modify_task_req_data() throw() {
    }


    void node_modify_task_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_modify_task_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_modify_task_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_modify_task_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_modify_task_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_modify_task_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_modify_task_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_modify_task_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_modify_task_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_modify_task_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_modify_task_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size458;
                        ::apache::thrift::protocol::TType _etype461;
                        xfer += iprot->readListBegin(_etype461, _size458);
                        this->peer_nodes_list.resize(_size458);
                        uint32_t _i462;
                        for (_i462 = 0; _i462 < _size458; ++_i462)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i462]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size463;
                        ::apache::thrift::protocol::TType _etype466;
                        xfer += iprot->readListBegin(_etype466, _size463);
                        this->multisig_wallets.resize(_size463);
                        uint32_t _i467;
                        for (_i467 = 0; _i467 < _size463; ++_i467)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i467]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size468;
                        ::apache::thrift::protocol::TType _etype471;
                        xfer += iprot->readListBegin(_etype471, _size468);
                        this->multisig_signs.resize(_size468);
                        uint32_t _i472;
                        for (_i472 = 0; _i472 < _size468; ++_i472)
                        {
                            xfer += this->multisig_signs[_i472].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter473;
            for (_iter473 = this->peer_nodes_list.begin(); _iter473 != this->peer_nodes_list.end(); ++_iter473)
            {
                xfer += oprot->writeString((*_iter473));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter474;
            for (_iter474 = this->multisig_wallets.begin(); _iter474 != this->multisig_wallets.end(); ++_iter474)
            {
                xfer += oprot->writeString((*_iter474));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter475;
            for (_iter475 = this->multisig_signs.begin(); _iter475 != this->multisig_signs.end(); ++_iter475)
            {
                xfer += (*_iter475).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req_data& a, node_modify_task_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_modify_task_req_data::node_modify_task_req_data(const node_modify_task_req_data& other476) {
        task_id = other476.task_id;
        peer_nodes_list = other476.peer_nodes_list;
        additional = other476.additional;
        wallet = other476.wallet;
        nonce = other476.nonce;
        sign = other476.sign;
        multisig_wallets = other476.multisig_wallets;
        multisig_threshold = other476.multisig_threshold;
        multisig_signs = other476.multisig_signs;
        session_id = other476.session_id;
        session_id_sign = other476.session_id_sign;
    }
    node_modify_task_req_data& node_modify_task_req_data::operator=(const node_modify_task_req_data& other477) {
        task_id = other477.task_id;
        peer_nodes_list = other477.peer_nodes_list;
        additional = other477.additional;
        wallet = other477.wallet;
        nonce = other477.nonce;
        sign = other477.sign;
        multisig_wallets = other477.multisig_wallets;
        multisig_threshold = other477.multisig_threshold;
        multisig_signs = other477.multisig_signs;
        session_id = other477.session_id;
        session_id_sign = other477.session_id_sign;
        return *this;
    }
    void node_modify_task_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_modify_task_req_body::~node_modify_task_req_body() throw() {
    }


    void node_modify_task_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req_body& a, node_modify_task_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_modify_task_req_body::node_modify_task_req_body(const node_modify_task_req_body& other478) {
        data = other478.data;
    }
    node_modify_task_req_body& node_modify_task_req_body::operator=(const node_modify_task_req_body& other479) {
        data = other479.data;
        return *this;
    }
    void node_modify_task_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_modify_task_req::~node_modify_task_req() throw() {
    }


    void node_modify_task_req::__set_body(const node_modify_task_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_modify_task_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_req& a, node_modify_task_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_modify_task_req::node_modify_task_req(const node_modify_task_req& other480) {
        body = other480.body;
        __isset = other480.__isset;
    }
    node_modify_task_req& node_modify_task_req::operator=(const node_modify_task_req& other481) {
        body = other481.body;
        __isset = other481.__isset;
        return *this;
    }
    void node_modify_task_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_modify_task_rsp_body::~node_modify_task_rsp_body() throw() {
    }


    void node_modify_task_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_modify_task_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_rsp_body& a, node_modify_task_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_modify_task_rsp_body::node_modify_task_rsp_body(const node_modify_task_rsp_body& other482) {
        data = other482.data;
    }
    node_modify_task_rsp_body& node_modify_task_rsp_body::operator=(const node_modify_task_rsp_body& other483) {
        data = other483.data;
        return *this;
    }
    void node_modify_task_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_modify_task_rsp::~node_modify_task_rsp() throw() {
    }


    void node_modify_task_rsp::__set_body(const node_modify_task_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_modify_task_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_modify_task_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_modify_task_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_modify_task_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_modify_task_rsp& a, node_modify_task_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_modify_task_rsp::node_modify_task_rsp(const node_modify_task_rsp& other484) {
        body = other484.body;
        __isset = other484.__isset;
    }
    node_modify_task_rsp& node_modify_task_rsp::operator=(const node_modify_task_rsp& other485) {
        body = other485.body;
        __isset = other485.__isset;
        return *this;
    }
    void node_modify_task_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_modify_task_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_session_id_req_data::~node_session_id_req_data() throw() {
    }


    void node_session_id_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_session_id_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_session_id_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_session_id_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_session_id_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_session_id_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_session_id_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_session_id_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size486;
                        ::apache::thrift::protocol::TType _etype489;
                        xfer += iprot->readListBegin(_etype489, _size486);
                        this->peer_nodes_list.resize(_size486);
                        uint32_t _i490;
                        for (_i490 = 0; _i490 < _size486; ++_i490)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i490]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size491;
                        ::apache::thrift::protocol::TType _etype494;
                        xfer += iprot->readListBegin(_etype494, _size491);
                        this->multisig_wallets.resize(_size491);
                        uint32_t _i495;
                        for (_i495 = 0; _i495 < _size491; ++_i495)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i495]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size496;
                        ::apache::thrift::protocol::TType _etype499;
                        xfer += iprot->readListBegin(_etype499, _size496);
                        this->multisig_signs.resize(_size496);
                        uint32_t _i500;
                        for (_i500 = 0; _i500 < _size496; ++_i500)
                        {
                            xfer += this->multisig_signs[_i500].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter501;
            for (_iter501 = this->peer_nodes_list.begin(); _iter501 != this->peer_nodes_list.end(); ++_iter501)
            {
                xfer += oprot->writeString((*_iter501));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter502;
            for (_iter502 = this->multisig_wallets.begin(); _iter502 != this->multisig_wallets.end(); ++_iter502)
            {
                xfer += oprot->writeString((*_iter502));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter503;
            for (_iter503 = this->multisig_signs.begin(); _iter503 != this->multisig_signs.end(); ++_iter503)
            {
                xfer += (*_iter503).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req_data& a, node_session_id_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
    }

    node_session_id_req_data::node_session_id_req_data(const node_session_id_req_data& other504) {
        peer_nodes_list = other504.peer_nodes_list;
        additional = other504.additional;
        wallet = other504.wallet;
        nonce = other504.nonce;
        sign = other504.sign;
        multisig_wallets = other504.multisig_wallets;
        multisig_threshold = other504.multisig_threshold;
        multisig_signs = other504.multisig_signs;
    }
    node_session_id_req_data& node_session_id_req_data::operator=(const node_session_id_req_data& other505) {
        peer_nodes_list = other505.peer_nodes_list;
        additional = other505.additional;
        wallet = other505.wallet;
        nonce = other505.nonce;
        sign = other505.sign;
        multisig_wallets = other505.multisig_wallets;
        multisig_threshold = other505.multisig_threshold;
        multisig_signs = other505.multisig_signs;
        return *this;
    }
    void node_session_id_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ")";
    }


    node_session_id_req_body::~node_session_id_req_body() throw() {
    }


    void node_session_id_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req_body& a, node_session_id_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_session_id_req_body::node_session_id_req_body(const node_session_id_req_body& other506) {
        data = other506.data;
    }
    node_session_id_req_body& node_session_id_req_body::operator=(const node_session_id_req_body& other507) {
        data = other507.data;
        return *this;
    }
    void node_session_id_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_session_id_req::~node_session_id_req() throw() {
    }


    void node_session_id_req::__set_body(const node_session_id_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_session_id_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_req& a, node_session_id_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_session_id_req::node_session_id_req(const node_session_id_req& other508) {
        body = other508.body;
        __isset = other508.__isset;
    }
    node_session_id_req& node_session_id_req::operator=(const node_session_id_req& other509) {
        body = other509.body;
        __isset = other509.__isset;
        return *this;
    }
    void node_session_id_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_session_id_rsp_body::~node_session_id_rsp_body() throw() {
    }


    void node_session_id_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_session_id_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_rsp_body& a, node_session_id_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_session_id_rsp_body::node_session_id_rsp_body(const node_session_id_rsp_body& other510) {
        data = other510.data;
    }
    node_session_id_rsp_body& node_session_id_rsp_body::operator=(const node_session_id_rsp_body& other511) {
        data = other511.data;
        return *this;
    }
    void node_session_id_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_session_id_rsp::~node_session_id_rsp() throw() {
    }


    void node_session_id_rsp::__set_body(const node_session_id_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_session_id_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_session_id_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_session_id_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_session_id_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_session_id_rsp& a, node_session_id_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_session_id_rsp::node_session_id_rsp(const node_session_id_rsp& other512) {
        body = other512.body;
        __isset = other512.__isset;
    }
    node_session_id_rsp& node_session_id_rsp::operator=(const node_session_id_rsp& other513) {
        body = other513.body;
        __isset = other513.__isset;
        return *this;
    }
    void node_session_id_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_session_id_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_query_node_info_req_data::~node_query_node_info_req_data() throw() {
    }


    void node_query_node_info_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_query_node_info_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_query_node_info_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_query_node_info_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_query_node_info_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_query_node_info_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_query_node_info_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_query_node_info_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_query_node_info_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_query_node_info_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }

    void node_query_node_info_req_data::__set_image_server(const std::string& val) {
        this->image_server = val;
        __isset.image_server = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size514;
                        ::apache::thrift::protocol::TType _etype517;
                        xfer += iprot->readListBegin(_etype517, _size514);
                        this->peer_nodes_list.resize(_size514);
                        uint32_t _i518;
                        for (_i518 = 0; _i518 < _size514; ++_i518)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i518]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size519;
                        ::apache::thrift::protocol::TType _etype522;
                        xfer += iprot->readListBegin(_etype522, _size519);
                        this->multisig_wallets.resize(_size519);
                        uint32_t _i523;
                        for (_i523 = 0; _i523 < _size519; ++_i523)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i523]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size524;
                        ::apache::thrift::protocol::TType _etype527;
                        xfer += iprot->readListBegin(_etype527, _size524);
                        this->multisig_signs.resize(_size524);
                        uint32_t _i528;
                        for (_i528 = 0; _i528 < _size524; ++_i528)
                        {
                            xfer += this->multisig_signs[_i528].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->image_server);
                    this->__isset.image_server = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter529;
            for (_iter529 = this->peer_nodes_list.begin(); _iter529 != this->peer_nodes_list.end(); ++_iter529)
            {
                xfer += oprot->writeString((*_iter529));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter530;
            for (_iter530 = this->multisig_wallets.begin(); _iter530 != this->multisig_wallets.end(); ++_iter530)
            {
                xfer += oprot->writeString((*_iter530));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter531;
            for (_iter531 = this->multisig_signs.begin(); _iter531 != this->multisig_signs.end(); ++_iter531)
            {
                xfer += (*_iter531).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.image_server) {
            xfer += oprot->writeFieldBegin("image_server", ::apache::thrift::protocol::T_STRING, 11);
            xfer += oprot->writeString(this->image_server);
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req_data& a, node_query_node_info_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
        swap(a.image_server, b.image_server);
        swap(a.__isset, b.__isset);
    }

    node_query_node_info_req_data::node_query_node_info_req_data(const node_query_node_info_req_data& other532) {
        peer_nodes_list = other532.peer_nodes_list;
        additional = other532.additional;
        wallet = other532.wallet;
        nonce = other532.nonce;
        sign = other532.sign;
        multisig_wallets = other532.multisig_wallets;
        multisig_threshold = other532.multisig_threshold;
        multisig_signs = other532.multisig_signs;
        session_id = other532.session_id;
        session_id_sign = other532.session_id_sign;
        image_server = other532.image_server;
        __isset = other532.__isset;
    }
    node_query_node_info_req_data& node_query_node_info_req_data::operator=(const node_query_node_info_req_data& other533) {
        peer_nodes_list = other533.peer_nodes_list;
        additional = other533.additional;
        wallet = other533.wallet;
        nonce = other533.nonce;
        sign = other533.sign;
        multisig_wallets = other533.multisig_wallets;
        multisig_threshold = other533.multisig_threshold;
        multisig_signs = other533.multisig_signs;
        session_id = other533.session_id;
        session_id_sign = other533.session_id_sign;
        image_server = other533.image_server;
        __isset = other533.__isset;
        return *this;
    }
    void node_query_node_info_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ", " << "image_server="; (__isset.image_server ? (out << to_string(image_server)) : (out << "<null>"));
        out << ")";
    }


    node_query_node_info_req_body::~node_query_node_info_req_body() throw() {
    }


    void node_query_node_info_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req_body& a, node_query_node_info_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_query_node_info_req_body::node_query_node_info_req_body(const node_query_node_info_req_body& other534) {
        data = other534.data;
    }
    node_query_node_info_req_body& node_query_node_info_req_body::operator=(const node_query_node_info_req_body& other535) {
        data = other535.data;
        return *this;
    }
    void node_query_node_info_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_query_node_info_req::~node_query_node_info_req() throw() {
    }


    void node_query_node_info_req::__set_body(const node_query_node_info_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_query_node_info_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_req& a, node_query_node_info_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_query_node_info_req::node_query_node_info_req(const node_query_node_info_req& other536) {
        body = other536.body;
        __isset = other536.__isset;
    }
    node_query_node_info_req& node_query_node_info_req::operator=(const node_query_node_info_req& other537) {
        body = other537.body;
        __isset = other537.__isset;
        return *this;
    }
    void node_query_node_info_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_query_node_info_rsp_body::~node_query_node_info_rsp_body() throw() {
    }


    void node_query_node_info_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_query_node_info_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_rsp_body& a, node_query_node_info_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_query_node_info_rsp_body::node_query_node_info_rsp_body(const node_query_node_info_rsp_body& other538) {
        data = other538.data;
    }
    node_query_node_info_rsp_body& node_query_node_info_rsp_body::operator=(const node_query_node_info_rsp_body& other539) {
        data = other539.data;
        return *this;
    }
    void node_query_node_info_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_query_node_info_rsp::~node_query_node_info_rsp() throw() {
    }


    void node_query_node_info_rsp::__set_body(const node_query_node_info_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_query_node_info_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_query_node_info_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_query_node_info_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_query_node_info_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_query_node_info_rsp& a, node_query_node_info_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_query_node_info_rsp::node_query_node_info_rsp(const node_query_node_info_rsp& other540) {
        body = other540.body;
        __isset = other540.__isset;
    }
    node_query_node_info_rsp& node_query_node_info_rsp::operator=(const node_query_node_info_rsp& other541) {
        body = other541.body;
        __isset = other541.__isset;
        return *this;
    }
    void node_query_node_info_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_query_node_info_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_service_info::~node_service_info() throw() {
    }


    void node_service_info::__set_service_list(const std::vector<std::string>& val) {
        this->service_list = val;
    }

    void node_service_info::__set_name(const std::string& val) {
        this->name = val;
        __isset.name = true;
    }

    void node_service_info::__set_time_stamp(const int64_t val) {
        this->time_stamp = val;
        __isset.time_stamp = true;
    }

    void node_service_info::__set_kvs(const std::map<std::string, std::string>& val) {
        this->kvs = val;
        __isset.kvs = true;
    }
    std::ostream& operator<<(std::ostream& out, const node_service_info& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_service_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->service_list.clear();
                        uint32_t _size542;
                        ::apache::thrift::protocol::TType _etype545;
                        xfer += iprot->readListBegin(_etype545, _size542);
                        this->service_list.resize(_size542);
                        uint32_t _i546;
                        for (_i546 = 0; _i546 < _size542; ++_i546)
                        {
                            xfer += iprot->readString(this->service_list[_i546]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_service_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->name);
                    this->__isset.name = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_I64) {
                    xfer += iprot->readI64(this->time_stamp);
                    this->__isset.time_stamp = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_MAP) {
                    {
                        this->kvs.clear();
                        uint32_t _size547;
                        ::apache::thrift::protocol::TType _ktype548;
                        ::apache::thrift::protocol::TType _vtype549;
                        xfer += iprot->readMapBegin(_ktype548, _vtype549, _size547);
                        uint32_t _i551;
                        for (_i551 = 0; _i551 < _size547; ++_i551)
                        {
                            std::string _key552;
                            xfer += iprot->readString(_key552);
                            std::string& _val553 = this->kvs[_key552];
                            xfer += iprot->readString(_val553);
                        }
                        xfer += iprot->readMapEnd();
                    }
                    this->__isset.kvs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_service_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_service_info");

        xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
            std::vector<std::string> ::const_iterator _iter554;
            for (_iter554 = this->service_list.begin(); _iter554 != this->service_list.end(); ++_iter554)
            {
                xfer += oprot->writeString((*_iter554));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        if (this->__isset.name) {
            xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
            xfer += oprot->writeString(this->name);
            xfer += oprot->writeFieldEnd();
        }
        if (this->__isset.time_stamp) {
            xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 3);
            xfer += oprot->writeI64(this->time_stamp);
            xfer += oprot->writeFieldEnd();
        }
        if (this->__isset.kvs) {
            xfer += oprot->writeFieldBegin("kvs", ::apache::thrift::protocol::T_MAP, 4);
            {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kvs.size()));
                std::map<std::string, std::string> ::const_iterator _iter555;
                for (_iter555 = this->kvs.begin(); _iter555 != this->kvs.end(); ++_iter555)
                {
                    xfer += oprot->writeString(_iter555->first);
                    xfer += oprot->writeString(_iter555->second);
                }
                xfer += oprot->writeMapEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_service_info& a, node_service_info& b) {
        using ::std::swap;
        swap(a.service_list, b.service_list);
        swap(a.name, b.name);
        swap(a.time_stamp, b.time_stamp);
        swap(a.kvs, b.kvs);
        swap(a.__isset, b.__isset);
    }

    node_service_info::node_service_info(const node_service_info& other556) {
        service_list = other556.service_list;
        name = other556.name;
        time_stamp = other556.time_stamp;
        kvs = other556.kvs;
        __isset = other556.__isset;
    }
    node_service_info& node_service_info::operator=(const node_service_info& other557) {
        service_list = other557.service_list;
        name = other557.name;
        time_stamp = other557.time_stamp;
        kvs = other557.kvs;
        __isset = other557.__isset;
        return *this;
    }
    void node_service_info::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_service_info(";
        out << "service_list=" << to_string(service_list);
        out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
        out << ", " << "time_stamp="; (__isset.time_stamp ? (out << to_string(time_stamp)) : (out << "<null>"));
        out << ", " << "kvs="; (__isset.kvs ? (out << to_string(kvs)) : (out << "<null>"));
        out << ")";
    }


    service_broadcast_req_body::~service_broadcast_req_body() throw() {
    }


    void service_broadcast_req_body::__set_node_service_info_map(const std::map<std::string, node_service_info>& val) {
        this->node_service_info_map = val;
    }
    std::ostream& operator<<(std::ostream& out, const service_broadcast_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t service_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_service_info_map = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_MAP) {
                    {
                        this->node_service_info_map.clear();
                        uint32_t _size558;
                        ::apache::thrift::protocol::TType _ktype559;
                        ::apache::thrift::protocol::TType _vtype560;
                        xfer += iprot->readMapBegin(_ktype559, _vtype560, _size558);
                        uint32_t _i562;
                        for (_i562 = 0; _i562 < _size558; ++_i562)
                        {
                            std::string _key563;
                            xfer += iprot->readString(_key563);
                            node_service_info& _val564 = this->node_service_info_map[_key563];
                            xfer += _val564.read(iprot);
                        }
                        xfer += iprot->readMapEnd();
                    }
                    isset_node_service_info_map = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_service_info_map)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t service_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("service_broadcast_req_body");

        xfer += oprot->writeFieldBegin("node_service_info_map", ::apache::thrift::protocol::T_MAP, 1);
        {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_service_info_map.size()));
            std::map<std::string, node_service_info> ::const_iterator _iter565;
            for (_iter565 = this->node_service_info_map.begin(); _iter565 != this->node_service_info_map.end(); ++_iter565)
            {
                xfer += oprot->writeString(_iter565->first);
                xfer += _iter565->second.write(oprot);
            }
            xfer += oprot->writeMapEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(service_broadcast_req_body& a, service_broadcast_req_body& b) {
        using ::std::swap;
        swap(a.node_service_info_map, b.node_service_info_map);
    }

    service_broadcast_req_body::service_broadcast_req_body(const service_broadcast_req_body& other566) {
        node_service_info_map = other566.node_service_info_map;
    }
    service_broadcast_req_body& service_broadcast_req_body::operator=(const service_broadcast_req_body& other567) {
        node_service_info_map = other567.node_service_info_map;
        return *this;
    }
    void service_broadcast_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "service_broadcast_req_body(";
        out << "node_service_info_map=" << to_string(node_service_info_map);
        out << ")";
    }


    service_broadcast_req::~service_broadcast_req() throw() {
    }


    void service_broadcast_req::__set_body(const service_broadcast_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const service_broadcast_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t service_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t service_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("service_broadcast_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(service_broadcast_req& a, service_broadcast_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    service_broadcast_req::service_broadcast_req(const service_broadcast_req& other568) {
        body = other568.body;
        __isset = other568.__isset;
    }
    service_broadcast_req& service_broadcast_req::operator=(const service_broadcast_req& other569) {
        body = other569.body;
        __isset = other569.__isset;
        return *this;
    }
    void service_broadcast_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "service_broadcast_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    ver_req_body::~ver_req_body() throw() {
    }


    void ver_req_body::__set_node_id(const std::string& val) {
        this->node_id = val;
    }

    void ver_req_body::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void ver_req_body::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }

    void ver_req_body::__set_time_stamp(const int64_t val) {
        this->time_stamp = val;
    }

    void ver_req_body::__set_addr_me(const network_address& val) {
        this->addr_me = val;
    }

    void ver_req_body::__set_addr_you(const network_address& val) {
        this->addr_you = val;
    }

    void ver_req_body::__set_start_height(const int64_t val) {
        this->start_height = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;
        bool isset_time_stamp = false;
        bool isset_addr_me = false;
        bool isset_addr_you = false;
        bool isset_start_height = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->node_id);
                    isset_node_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->core_version);
                    isset_core_version = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->protocol_version);
                    isset_protocol_version = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_I64) {
                    xfer += iprot->readI64(this->time_stamp);
                    isset_time_stamp = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->addr_me.read(iprot);
                    isset_addr_me = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->addr_you.read(iprot);
                    isset_addr_you = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I64) {
                    xfer += iprot->readI64(this->start_height);
                    isset_start_height = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_time_stamp)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr_me)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr_you)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_start_height)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t ver_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_req_body");

        xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_I64, 4);
        xfer += oprot->writeI64(this->time_stamp);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr_me", ::apache::thrift::protocol::T_STRUCT, 5);
        xfer += this->addr_me.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr_you", ::apache::thrift::protocol::T_STRUCT, 6);
        xfer += this->addr_you.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("start_height", ::apache::thrift::protocol::T_I64, 7);
        xfer += oprot->writeI64(this->start_height);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_req_body& a, ver_req_body& b) {
        using ::std::swap;
        swap(a.node_id, b.node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
        swap(a.time_stamp, b.time_stamp);
        swap(a.addr_me, b.addr_me);
        swap(a.addr_you, b.addr_you);
        swap(a.start_height, b.start_height);
    }

    ver_req_body::ver_req_body(const ver_req_body& other570) {
        node_id = other570.node_id;
        core_version = other570.core_version;
        protocol_version = other570.protocol_version;
        time_stamp = other570.time_stamp;
        addr_me = other570.addr_me;
        addr_you = other570.addr_you;
        start_height = other570.start_height;
    }
    ver_req_body& ver_req_body::operator=(const ver_req_body& other571) {
        node_id = other571.node_id;
        core_version = other571.core_version;
        protocol_version = other571.protocol_version;
        time_stamp = other571.time_stamp;
        addr_me = other571.addr_me;
        addr_you = other571.addr_you;
        start_height = other571.start_height;
        return *this;
    }
    void ver_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_req_body(";
        out << "node_id=" << to_string(node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ", " << "time_stamp=" << to_string(time_stamp);
        out << ", " << "addr_me=" << to_string(addr_me);
        out << ", " << "addr_you=" << to_string(addr_you);
        out << ", " << "start_height=" << to_string(start_height);
        out << ")";
    }


    ver_req::~ver_req() throw() {
    }


    void ver_req::__set_body(const ver_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t ver_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_req& a, ver_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    ver_req::ver_req(const ver_req& other572) {
        body = other572.body;
        __isset = other572.__isset;
    }
    ver_req& ver_req::operator=(const ver_req& other573) {
        body = other573.body;
        __isset = other573.__isset;
        return *this;
    }
    void ver_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    ver_resp_body::~ver_resp_body() throw() {
    }


    void ver_resp_body::__set_node_id(const std::string& val) {
        this->node_id = val;
    }

    void ver_resp_body::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void ver_resp_body::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_resp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->node_id);
                    isset_node_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->core_version);
                    isset_core_version = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->protocol_version);
                    isset_protocol_version = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t ver_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_resp_body");

        xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_resp_body& a, ver_resp_body& b) {
        using ::std::swap;
        swap(a.node_id, b.node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
    }

    ver_resp_body::ver_resp_body(const ver_resp_body& other574) {
        node_id = other574.node_id;
        core_version = other574.core_version;
        protocol_version = other574.protocol_version;
    }
    ver_resp_body& ver_resp_body::operator=(const ver_resp_body& other575) {
        node_id = other575.node_id;
        core_version = other575.core_version;
        protocol_version = other575.protocol_version;
        return *this;
    }
    void ver_resp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_resp_body(";
        out << "node_id=" << to_string(node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ")";
    }


    ver_resp::~ver_resp() throw() {
    }


    void ver_resp::__set_body(const ver_resp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const ver_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t ver_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t ver_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("ver_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(ver_resp& a, ver_resp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    ver_resp::ver_resp(const ver_resp& other576) {
        body = other576.body;
        __isset = other576.__isset;
    }
    ver_resp& ver_resp::operator=(const ver_resp& other577) {
        body = other577.body;
        __isset = other577.__isset;
        return *this;
    }
    void ver_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "ver_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    peer_node_info::~peer_node_info() throw() {
    }


    void peer_node_info::__set_peer_node_id(const std::string& val) {
        this->peer_node_id = val;
    }

    void peer_node_info::__set_core_version(const int32_t val) {
        this->core_version = val;
    }

    void peer_node_info::__set_protocol_version(const int32_t val) {
        this->protocol_version = val;
    }

    void peer_node_info::__set_live_time_stamp(const int32_t val) {
        this->live_time_stamp = val;
    }

    void peer_node_info::__set_addr(const network_address& val) {
        this->addr = val;
    }

    void peer_node_info::__set_service_list(const std::vector<std::string>& val) {
        this->service_list = val;
        __isset.service_list = true;
    }
    std::ostream& operator<<(std::ostream& out, const peer_node_info& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_node_id = false;
        bool isset_core_version = false;
        bool isset_protocol_version = false;
        bool isset_live_time_stamp = false;
        bool isset_addr = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->peer_node_id);
                    isset_peer_node_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->core_version);
                    isset_core_version = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->protocol_version);
                    isset_protocol_version = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->live_time_stamp);
                    isset_live_time_stamp = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->addr.read(iprot);
                    isset_addr = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->service_list.clear();
                        uint32_t _size578;
                        ::apache::thrift::protocol::TType _etype581;
                        xfer += iprot->readListBegin(_etype581, _size578);
                        this->service_list.resize(_size578);
                        uint32_t _i582;
                        for (_i582 = 0; _i582 < _size578; ++_i582)
                        {
                            xfer += iprot->readString(this->service_list[_i582]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    this->__isset.service_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_node_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_core_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_protocol_version)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_live_time_stamp)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_addr)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t peer_node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_node_info");

        xfer += oprot->writeFieldBegin("peer_node_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->peer_node_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("core_version", ::apache::thrift::protocol::T_I32, 2);
        xfer += oprot->writeI32(this->core_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 3);
        xfer += oprot->writeI32(this->protocol_version);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("live_time_stamp", ::apache::thrift::protocol::T_I32, 4);
        xfer += oprot->writeI32(this->live_time_stamp);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRUCT, 5);
        xfer += this->addr.write(oprot);
        xfer += oprot->writeFieldEnd();

        if (this->__isset.service_list) {
            xfer += oprot->writeFieldBegin("service_list", ::apache::thrift::protocol::T_LIST, 6);
            {
                xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_list.size()));
                std::vector<std::string> ::const_iterator _iter583;
                for (_iter583 = this->service_list.begin(); _iter583 != this->service_list.end(); ++_iter583)
                {
                    xfer += oprot->writeString((*_iter583));
                }
                xfer += oprot->writeListEnd();
            }
            xfer += oprot->writeFieldEnd();
        }
        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_node_info& a, peer_node_info& b) {
        using ::std::swap;
        swap(a.peer_node_id, b.peer_node_id);
        swap(a.core_version, b.core_version);
        swap(a.protocol_version, b.protocol_version);
        swap(a.live_time_stamp, b.live_time_stamp);
        swap(a.addr, b.addr);
        swap(a.service_list, b.service_list);
        swap(a.__isset, b.__isset);
    }

    peer_node_info::peer_node_info(const peer_node_info& other584) {
        peer_node_id = other584.peer_node_id;
        core_version = other584.core_version;
        protocol_version = other584.protocol_version;
        live_time_stamp = other584.live_time_stamp;
        addr = other584.addr;
        service_list = other584.service_list;
        __isset = other584.__isset;
    }
    peer_node_info& peer_node_info::operator=(const peer_node_info& other585) {
        peer_node_id = other585.peer_node_id;
        core_version = other585.core_version;
        protocol_version = other585.protocol_version;
        live_time_stamp = other585.live_time_stamp;
        addr = other585.addr;
        service_list = other585.service_list;
        __isset = other585.__isset;
        return *this;
    }
    void peer_node_info::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_node_info(";
        out << "peer_node_id=" << to_string(peer_node_id);
        out << ", " << "core_version=" << to_string(core_version);
        out << ", " << "protocol_version=" << to_string(protocol_version);
        out << ", " << "live_time_stamp=" << to_string(live_time_stamp);
        out << ", " << "addr=" << to_string(addr);
        out << ", " << "service_list="; (__isset.service_list ? (out << to_string(service_list)) : (out << "<null>"));
        out << ")";
    }


    get_peer_nodes_req::~get_peer_nodes_req() throw() {
    }


    void get_peer_nodes_req::__set_body(const empty& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t get_peer_nodes_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_req& a, get_peer_nodes_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    get_peer_nodes_req::get_peer_nodes_req(const get_peer_nodes_req& other586) {
        body = other586.body;
        __isset = other586.__isset;
    }
    get_peer_nodes_req& get_peer_nodes_req::operator=(const get_peer_nodes_req& other587) {
        body = other587.body;
        __isset = other587.__isset;
        return *this;
    }
    void get_peer_nodes_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    get_peer_nodes_resp_body::~get_peer_nodes_resp_body() throw() {
    }


    void get_peer_nodes_resp_body::__set_peer_nodes_list(const std::vector<peer_node_info>& val) {
        this->peer_nodes_list = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_resp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size588;
                        ::apache::thrift::protocol::TType _etype591;
                        xfer += iprot->readListBegin(_etype591, _size588);
                        this->peer_nodes_list.resize(_size588);
                        uint32_t _i592;
                        for (_i592 = 0; _i592 < _size588; ++_i592)
                        {
                            xfer += this->peer_nodes_list[_i592].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t get_peer_nodes_resp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_resp_body");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<peer_node_info> ::const_iterator _iter593;
            for (_iter593 = this->peer_nodes_list.begin(); _iter593 != this->peer_nodes_list.end(); ++_iter593)
            {
                xfer += (*_iter593).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_resp_body& a, get_peer_nodes_resp_body& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
    }

    get_peer_nodes_resp_body::get_peer_nodes_resp_body(const get_peer_nodes_resp_body& other594) {
        peer_nodes_list = other594.peer_nodes_list;
    }
    get_peer_nodes_resp_body& get_peer_nodes_resp_body::operator=(const get_peer_nodes_resp_body& other595) {
        peer_nodes_list = other595.peer_nodes_list;
        return *this;
    }
    void get_peer_nodes_resp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_resp_body(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ")";
    }


    get_peer_nodes_resp::~get_peer_nodes_resp() throw() {
    }


    void get_peer_nodes_resp::__set_body(const get_peer_nodes_resp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const get_peer_nodes_resp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t get_peer_nodes_resp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t get_peer_nodes_resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("get_peer_nodes_resp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(get_peer_nodes_resp& a, get_peer_nodes_resp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    get_peer_nodes_resp::get_peer_nodes_resp(const get_peer_nodes_resp& other596) {
        body = other596.body;
        __isset = other596.__isset;
    }
    get_peer_nodes_resp& get_peer_nodes_resp::operator=(const get_peer_nodes_resp& other597) {
        body = other597.body;
        __isset = other597.__isset;
        return *this;
    }
    void get_peer_nodes_resp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "get_peer_nodes_resp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    peer_nodes_broadcast_req_body::~peer_nodes_broadcast_req_body() throw() {
    }


    void peer_nodes_broadcast_req_body::__set_peer_nodes_list(const std::vector<peer_node_info>& val) {
        this->peer_nodes_list = val;
    }
    std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_nodes_broadcast_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size598;
                        ::apache::thrift::protocol::TType _etype601;
                        xfer += iprot->readListBegin(_etype601, _size598);
                        this->peer_nodes_list.resize(_size598);
                        uint32_t _i602;
                        for (_i602 = 0; _i602 < _size598; ++_i602)
                        {
                            xfer += this->peer_nodes_list[_i602].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t peer_nodes_broadcast_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_nodes_broadcast_req_body");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<peer_node_info> ::const_iterator _iter603;
            for (_iter603 = this->peer_nodes_list.begin(); _iter603 != this->peer_nodes_list.end(); ++_iter603)
            {
                xfer += (*_iter603).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_nodes_broadcast_req_body& a, peer_nodes_broadcast_req_body& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
    }

    peer_nodes_broadcast_req_body::peer_nodes_broadcast_req_body(const peer_nodes_broadcast_req_body& other604) {
        peer_nodes_list = other604.peer_nodes_list;
    }
    peer_nodes_broadcast_req_body& peer_nodes_broadcast_req_body::operator=(const peer_nodes_broadcast_req_body& other605) {
        peer_nodes_list = other605.peer_nodes_list;
        return *this;
    }
    void peer_nodes_broadcast_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_nodes_broadcast_req_body(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ")";
    }


    peer_nodes_broadcast_req::~peer_nodes_broadcast_req() throw() {
    }


    void peer_nodes_broadcast_req::__set_body(const peer_nodes_broadcast_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const peer_nodes_broadcast_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t peer_nodes_broadcast_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t peer_nodes_broadcast_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("peer_nodes_broadcast_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(peer_nodes_broadcast_req& a, peer_nodes_broadcast_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    peer_nodes_broadcast_req::peer_nodes_broadcast_req(const peer_nodes_broadcast_req& other606) {
        body = other606.body;
        __isset = other606.__isset;
    }
    peer_nodes_broadcast_req& peer_nodes_broadcast_req::operator=(const peer_nodes_broadcast_req& other607) {
        body = other607.body;
        __isset = other607.__isset;
        return *this;
    }
    void peer_nodes_broadcast_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "peer_nodes_broadcast_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_snapshot_req_data::~node_list_snapshot_req_data() throw() {
    }


    void node_list_snapshot_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_list_snapshot_req_data::__set_snapshot_name(const std::string& val) {
        this->snapshot_name = val;
    }

    void node_list_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_list_snapshot_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_list_snapshot_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_list_snapshot_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_list_snapshot_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_list_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_list_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_list_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_list_snapshot_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_list_snapshot_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_snapshot_name = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->snapshot_name);
                    isset_snapshot_name = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size608;
                        ::apache::thrift::protocol::TType _etype611;
                        xfer += iprot->readListBegin(_etype611, _size608);
                        this->peer_nodes_list.resize(_size608);
                        uint32_t _i612;
                        for (_i612 = 0; _i612 < _size608; ++_i612)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i612]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size613;
                        ::apache::thrift::protocol::TType _etype616;
                        xfer += iprot->readListBegin(_etype616, _size613);
                        this->multisig_wallets.resize(_size613);
                        uint32_t _i617;
                        for (_i617 = 0; _i617 < _size613; ++_i617)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i617]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size618;
                        ::apache::thrift::protocol::TType _etype621;
                        xfer += iprot->readListBegin(_etype621, _size618);
                        this->multisig_signs.resize(_size618);
                        uint32_t _i622;
                        for (_i622 = 0; _i622 < _size618; ++_i622)
                        {
                            xfer += this->multisig_signs[_i622].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 12:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_snapshot_name)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->snapshot_name);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 3);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter623;
            for (_iter623 = this->peer_nodes_list.begin(); _iter623 != this->peer_nodes_list.end(); ++_iter623)
            {
                xfer += oprot->writeString((*_iter623));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter624;
            for (_iter624 = this->multisig_wallets.begin(); _iter624 != this->multisig_wallets.end(); ++_iter624)
            {
                xfer += oprot->writeString((*_iter624));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 9);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 10);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter625;
            for (_iter625 = this->multisig_signs.begin(); _iter625 != this->multisig_signs.end(); ++_iter625)
            {
                xfer += (*_iter625).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 12);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_req_data& a, node_list_snapshot_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.snapshot_name, b.snapshot_name);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_list_snapshot_req_data::node_list_snapshot_req_data(const node_list_snapshot_req_data& other626) {
        task_id = other626.task_id;
        snapshot_name = other626.snapshot_name;
        peer_nodes_list = other626.peer_nodes_list;
        additional = other626.additional;
        wallet = other626.wallet;
        nonce = other626.nonce;
        sign = other626.sign;
        multisig_wallets = other626.multisig_wallets;
        multisig_threshold = other626.multisig_threshold;
        multisig_signs = other626.multisig_signs;
        session_id = other626.session_id;
        session_id_sign = other626.session_id_sign;
    }
    node_list_snapshot_req_data& node_list_snapshot_req_data::operator=(const node_list_snapshot_req_data& other627) {
        task_id = other627.task_id;
        snapshot_name = other627.snapshot_name;
        peer_nodes_list = other627.peer_nodes_list;
        additional = other627.additional;
        wallet = other627.wallet;
        nonce = other627.nonce;
        sign = other627.sign;
        multisig_wallets = other627.multisig_wallets;
        multisig_threshold = other627.multisig_threshold;
        multisig_signs = other627.multisig_signs;
        session_id = other627.session_id;
        session_id_sign = other627.session_id_sign;
        return *this;
    }
    void node_list_snapshot_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "snapshot_name=" << to_string(snapshot_name);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_list_snapshot_req_body::~node_list_snapshot_req_body() throw() {
    }


    void node_list_snapshot_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_req_body& a, node_list_snapshot_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_snapshot_req_body::node_list_snapshot_req_body(const node_list_snapshot_req_body& other628) {
        data = other628.data;
    }
    node_list_snapshot_req_body& node_list_snapshot_req_body::operator=(const node_list_snapshot_req_body& other629) {
        data = other629.data;
        return *this;
    }
    void node_list_snapshot_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_snapshot_req::~node_list_snapshot_req() throw() {
    }


    void node_list_snapshot_req::__set_body(const node_list_snapshot_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_req& a, node_list_snapshot_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_snapshot_req::node_list_snapshot_req(const node_list_snapshot_req& other630) {
        body = other630.body;
        __isset = other630.__isset;
    }
    node_list_snapshot_req& node_list_snapshot_req::operator=(const node_list_snapshot_req& other631) {
        body = other631.body;
        __isset = other631.__isset;
        return *this;
    }
    void node_list_snapshot_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_snapshot_rsp_body::~node_list_snapshot_rsp_body() throw() {
    }


    void node_list_snapshot_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_rsp_body& a, node_list_snapshot_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_snapshot_rsp_body::node_list_snapshot_rsp_body(const node_list_snapshot_rsp_body& other632) {
        data = other632.data;
    }
    node_list_snapshot_rsp_body& node_list_snapshot_rsp_body::operator=(const node_list_snapshot_rsp_body& other633) {
        data = other633.data;
        return *this;
    }
    void node_list_snapshot_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_snapshot_rsp::~node_list_snapshot_rsp() throw() {
    }


    void node_list_snapshot_rsp::__set_body(const node_list_snapshot_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_snapshot_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_snapshot_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_snapshot_rsp& a, node_list_snapshot_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_snapshot_rsp::node_list_snapshot_rsp(const node_list_snapshot_rsp& other634) {
        body = other634.body;
        __isset = other634.__isset;
    }
    node_list_snapshot_rsp& node_list_snapshot_rsp::operator=(const node_list_snapshot_rsp& other635) {
        body = other635.body;
        __isset = other635.__isset;
        return *this;
    }
    void node_list_snapshot_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_snapshot_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_snapshot_req_data::~node_create_snapshot_req_data() throw() {
    }


    void node_create_snapshot_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_create_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_create_snapshot_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_create_snapshot_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_create_snapshot_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_create_snapshot_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_create_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_create_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_create_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_create_snapshot_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_create_snapshot_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size636;
                        ::apache::thrift::protocol::TType _etype639;
                        xfer += iprot->readListBegin(_etype639, _size636);
                        this->peer_nodes_list.resize(_size636);
                        uint32_t _i640;
                        for (_i640 = 0; _i640 < _size636; ++_i640)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i640]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size641;
                        ::apache::thrift::protocol::TType _etype644;
                        xfer += iprot->readListBegin(_etype644, _size641);
                        this->multisig_wallets.resize(_size641);
                        uint32_t _i645;
                        for (_i645 = 0; _i645 < _size641; ++_i645)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i645]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size646;
                        ::apache::thrift::protocol::TType _etype649;
                        xfer += iprot->readListBegin(_etype649, _size646);
                        this->multisig_signs.resize(_size646);
                        uint32_t _i650;
                        for (_i650 = 0; _i650 < _size646; ++_i650)
                        {
                            xfer += this->multisig_signs[_i650].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 2);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter651;
            for (_iter651 = this->peer_nodes_list.begin(); _iter651 != this->peer_nodes_list.end(); ++_iter651)
            {
                xfer += oprot->writeString((*_iter651));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 7);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter652;
            for (_iter652 = this->multisig_wallets.begin(); _iter652 != this->multisig_wallets.end(); ++_iter652)
            {
                xfer += oprot->writeString((*_iter652));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 8);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 9);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter653;
            for (_iter653 = this->multisig_signs.begin(); _iter653 != this->multisig_signs.end(); ++_iter653)
            {
                xfer += (*_iter653).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_req_data& a, node_create_snapshot_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_create_snapshot_req_data::node_create_snapshot_req_data(const node_create_snapshot_req_data& other654) {
        task_id = other654.task_id;
        peer_nodes_list = other654.peer_nodes_list;
        additional = other654.additional;
        wallet = other654.wallet;
        nonce = other654.nonce;
        sign = other654.sign;
        multisig_wallets = other654.multisig_wallets;
        multisig_threshold = other654.multisig_threshold;
        multisig_signs = other654.multisig_signs;
        session_id = other654.session_id;
        session_id_sign = other654.session_id_sign;
    }
    node_create_snapshot_req_data& node_create_snapshot_req_data::operator=(const node_create_snapshot_req_data& other655) {
        task_id = other655.task_id;
        peer_nodes_list = other655.peer_nodes_list;
        additional = other655.additional;
        wallet = other655.wallet;
        nonce = other655.nonce;
        sign = other655.sign;
        multisig_wallets = other655.multisig_wallets;
        multisig_threshold = other655.multisig_threshold;
        multisig_signs = other655.multisig_signs;
        session_id = other655.session_id;
        session_id_sign = other655.session_id_sign;
        return *this;
    }
    void node_create_snapshot_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_create_snapshot_req_body::~node_create_snapshot_req_body() throw() {
    }


    void node_create_snapshot_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_req_body& a, node_create_snapshot_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_snapshot_req_body::node_create_snapshot_req_body(const node_create_snapshot_req_body& other656) {
        data = other656.data;
    }
    node_create_snapshot_req_body& node_create_snapshot_req_body::operator=(const node_create_snapshot_req_body& other657) {
        data = other657.data;
        return *this;
    }
    void node_create_snapshot_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_snapshot_req::~node_create_snapshot_req() throw() {
    }


    void node_create_snapshot_req::__set_body(const node_create_snapshot_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_req& a, node_create_snapshot_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_snapshot_req::node_create_snapshot_req(const node_create_snapshot_req& other658) {
        body = other658.body;
        __isset = other658.__isset;
    }
    node_create_snapshot_req& node_create_snapshot_req::operator=(const node_create_snapshot_req& other659) {
        body = other659.body;
        __isset = other659.__isset;
        return *this;
    }
    void node_create_snapshot_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_create_snapshot_rsp_body::~node_create_snapshot_rsp_body() throw() {
    }


    void node_create_snapshot_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_create_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_rsp_body& a, node_create_snapshot_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_create_snapshot_rsp_body::node_create_snapshot_rsp_body(const node_create_snapshot_rsp_body& other660) {
        data = other660.data;
    }
    node_create_snapshot_rsp_body& node_create_snapshot_rsp_body::operator=(const node_create_snapshot_rsp_body& other661) {
        data = other661.data;
        return *this;
    }
    void node_create_snapshot_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_create_snapshot_rsp::~node_create_snapshot_rsp() throw() {
    }


    void node_create_snapshot_rsp::__set_body(const node_create_snapshot_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_create_snapshot_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_create_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_create_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_create_snapshot_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_create_snapshot_rsp& a, node_create_snapshot_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_create_snapshot_rsp::node_create_snapshot_rsp(const node_create_snapshot_rsp& other662) {
        body = other662.body;
        __isset = other662.__isset;
    }
    node_create_snapshot_rsp& node_create_snapshot_rsp::operator=(const node_create_snapshot_rsp& other663) {
        body = other663.body;
        __isset = other663.__isset;
        return *this;
    }
    void node_create_snapshot_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_create_snapshot_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_snapshot_req_data::~node_delete_snapshot_req_data() throw() {
    }


    void node_delete_snapshot_req_data::__set_task_id(const std::string& val) {
        this->task_id = val;
    }

    void node_delete_snapshot_req_data::__set_snapshot_name(const std::string& val) {
        this->snapshot_name = val;
    }

    void node_delete_snapshot_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_delete_snapshot_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_delete_snapshot_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_delete_snapshot_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_delete_snapshot_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_delete_snapshot_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_delete_snapshot_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_delete_snapshot_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_delete_snapshot_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_delete_snapshot_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_task_id = false;
        bool isset_snapshot_name = false;
        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->task_id);
                    isset_task_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->snapshot_name);
                    isset_snapshot_name = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size664;
                        ::apache::thrift::protocol::TType _etype667;
                        xfer += iprot->readListBegin(_etype667, _size664);
                        this->peer_nodes_list.resize(_size664);
                        uint32_t _i668;
                        for (_i668 = 0; _i668 < _size664; ++_i668)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i668]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size669;
                        ::apache::thrift::protocol::TType _etype672;
                        xfer += iprot->readListBegin(_etype672, _size669);
                        this->multisig_wallets.resize(_size669);
                        uint32_t _i673;
                        for (_i673 = 0; _i673 < _size669; ++_i673)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i673]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size674;
                        ::apache::thrift::protocol::TType _etype677;
                        xfer += iprot->readListBegin(_etype677, _size674);
                        this->multisig_signs.resize(_size674);
                        uint32_t _i678;
                        for (_i678 = 0; _i678 < _size674; ++_i678)
                        {
                            xfer += this->multisig_signs[_i678].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 11:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 12:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_task_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_snapshot_name)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_snapshot_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_req_data");

        xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->task_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->snapshot_name);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 3);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter679;
            for (_iter679 = this->peer_nodes_list.begin(); _iter679 != this->peer_nodes_list.end(); ++_iter679)
            {
                xfer += oprot->writeString((*_iter679));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 7);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter680;
            for (_iter680 = this->multisig_wallets.begin(); _iter680 != this->multisig_wallets.end(); ++_iter680)
            {
                xfer += oprot->writeString((*_iter680));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 9);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 10);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter681;
            for (_iter681 = this->multisig_signs.begin(); _iter681 != this->multisig_signs.end(); ++_iter681)
            {
                xfer += (*_iter681).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 11);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 12);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_req_data& a, node_delete_snapshot_req_data& b) {
        using ::std::swap;
        swap(a.task_id, b.task_id);
        swap(a.snapshot_name, b.snapshot_name);
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_delete_snapshot_req_data::node_delete_snapshot_req_data(const node_delete_snapshot_req_data& other682) {
        task_id = other682.task_id;
        snapshot_name = other682.snapshot_name;
        peer_nodes_list = other682.peer_nodes_list;
        additional = other682.additional;
        wallet = other682.wallet;
        nonce = other682.nonce;
        sign = other682.sign;
        multisig_wallets = other682.multisig_wallets;
        multisig_threshold = other682.multisig_threshold;
        multisig_signs = other682.multisig_signs;
        session_id = other682.session_id;
        session_id_sign = other682.session_id_sign;
    }
    node_delete_snapshot_req_data& node_delete_snapshot_req_data::operator=(const node_delete_snapshot_req_data& other683) {
        task_id = other683.task_id;
        snapshot_name = other683.snapshot_name;
        peer_nodes_list = other683.peer_nodes_list;
        additional = other683.additional;
        wallet = other683.wallet;
        nonce = other683.nonce;
        sign = other683.sign;
        multisig_wallets = other683.multisig_wallets;
        multisig_threshold = other683.multisig_threshold;
        multisig_signs = other683.multisig_signs;
        session_id = other683.session_id;
        session_id_sign = other683.session_id_sign;
        return *this;
    }
    void node_delete_snapshot_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_req_data(";
        out << "task_id=" << to_string(task_id);
        out << ", " << "snapshot_name=" << to_string(snapshot_name);
        out << ", " << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_delete_snapshot_req_body::~node_delete_snapshot_req_body() throw() {
    }


    void node_delete_snapshot_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_snapshot_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_req_body& a, node_delete_snapshot_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_snapshot_req_body::node_delete_snapshot_req_body(const node_delete_snapshot_req_body& other684) {
        data = other684.data;
    }
    node_delete_snapshot_req_body& node_delete_snapshot_req_body::operator=(const node_delete_snapshot_req_body& other685) {
        data = other685.data;
        return *this;
    }
    void node_delete_snapshot_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_snapshot_req::~node_delete_snapshot_req() throw() {
    }


    void node_delete_snapshot_req::__set_body(const node_delete_snapshot_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_snapshot_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_req& a, node_delete_snapshot_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_snapshot_req::node_delete_snapshot_req(const node_delete_snapshot_req& other686) {
        body = other686.body;
        __isset = other686.__isset;
    }
    node_delete_snapshot_req& node_delete_snapshot_req::operator=(const node_delete_snapshot_req& other687) {
        body = other687.body;
        __isset = other687.__isset;
        return *this;
    }
    void node_delete_snapshot_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_delete_snapshot_rsp_body::~node_delete_snapshot_rsp_body() throw() {
    }


    void node_delete_snapshot_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_delete_snapshot_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_rsp_body& a, node_delete_snapshot_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_delete_snapshot_rsp_body::node_delete_snapshot_rsp_body(const node_delete_snapshot_rsp_body& other688) {
        data = other688.data;
    }
    node_delete_snapshot_rsp_body& node_delete_snapshot_rsp_body::operator=(const node_delete_snapshot_rsp_body& other689) {
        data = other689.data;
        return *this;
    }
    void node_delete_snapshot_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_delete_snapshot_rsp::~node_delete_snapshot_rsp() throw() {
    }


    void node_delete_snapshot_rsp::__set_body(const node_delete_snapshot_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_delete_snapshot_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_delete_snapshot_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_delete_snapshot_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_delete_snapshot_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_delete_snapshot_rsp& a, node_delete_snapshot_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_delete_snapshot_rsp::node_delete_snapshot_rsp(const node_delete_snapshot_rsp& other690) {
        body = other690.body;
        __isset = other690.__isset;
    }
    node_delete_snapshot_rsp& node_delete_snapshot_rsp::operator=(const node_delete_snapshot_rsp& other691) {
        body = other691.body;
        __isset = other691.__isset;
        return *this;
    }
    void node_delete_snapshot_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_delete_snapshot_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_monitor_server_req_data::~node_list_monitor_server_req_data() throw() {
    }


    void node_list_monitor_server_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_list_monitor_server_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_list_monitor_server_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_list_monitor_server_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_list_monitor_server_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_list_monitor_server_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_list_monitor_server_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_list_monitor_server_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_list_monitor_server_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_list_monitor_server_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_monitor_server_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_monitor_server_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size692;
                        ::apache::thrift::protocol::TType _etype695;
                        xfer += iprot->readListBegin(_etype695, _size692);
                        this->peer_nodes_list.resize(_size692);
                        uint32_t _i696;
                        for (_i696 = 0; _i696 < _size692; ++_i696)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i696]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size697;
                        ::apache::thrift::protocol::TType _etype700;
                        xfer += iprot->readListBegin(_etype700, _size697);
                        this->multisig_wallets.resize(_size697);
                        uint32_t _i701;
                        for (_i701 = 0; _i701 < _size697; ++_i701)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i701]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size702;
                        ::apache::thrift::protocol::TType _etype705;
                        xfer += iprot->readListBegin(_etype705, _size702);
                        this->multisig_signs.resize(_size702);
                        uint32_t _i706;
                        for (_i706 = 0; _i706 < _size702; ++_i706)
                        {
                            xfer += this->multisig_signs[_i706].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_monitor_server_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_monitor_server_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter707;
            for (_iter707 = this->peer_nodes_list.begin(); _iter707 != this->peer_nodes_list.end(); ++_iter707)
            {
                xfer += oprot->writeString((*_iter707));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter708;
            for (_iter708 = this->multisig_wallets.begin(); _iter708 != this->multisig_wallets.end(); ++_iter708)
            {
                xfer += oprot->writeString((*_iter708));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter709;
            for (_iter709 = this->multisig_signs.begin(); _iter709 != this->multisig_signs.end(); ++_iter709)
            {
                xfer += (*_iter709).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_monitor_server_req_data& a, node_list_monitor_server_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_list_monitor_server_req_data::node_list_monitor_server_req_data(const node_list_monitor_server_req_data& other710) {
        peer_nodes_list = other710.peer_nodes_list;
        additional = other710.additional;
        wallet = other710.wallet;
        nonce = other710.nonce;
        sign = other710.sign;
        multisig_wallets = other710.multisig_wallets;
        multisig_threshold = other710.multisig_threshold;
        multisig_signs = other710.multisig_signs;
        session_id = other710.session_id;
        session_id_sign = other710.session_id_sign;
    }
    node_list_monitor_server_req_data& node_list_monitor_server_req_data::operator=(const node_list_monitor_server_req_data& other711) {
        peer_nodes_list = other711.peer_nodes_list;
        additional = other711.additional;
        wallet = other711.wallet;
        nonce = other711.nonce;
        sign = other711.sign;
        multisig_wallets = other711.multisig_wallets;
        multisig_threshold = other711.multisig_threshold;
        multisig_signs = other711.multisig_signs;
        session_id = other711.session_id;
        session_id_sign = other711.session_id_sign;
        return *this;
    }
    void node_list_monitor_server_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_monitor_server_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_list_monitor_server_req_body::~node_list_monitor_server_req_body() throw() {
    }


    void node_list_monitor_server_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_monitor_server_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_monitor_server_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_monitor_server_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_monitor_server_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_monitor_server_req_body& a, node_list_monitor_server_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_monitor_server_req_body::node_list_monitor_server_req_body(const node_list_monitor_server_req_body& other712) {
        data = other712.data;
    }
    node_list_monitor_server_req_body& node_list_monitor_server_req_body::operator=(const node_list_monitor_server_req_body& other713) {
        data = other713.data;
        return *this;
    }
    void node_list_monitor_server_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_monitor_server_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_monitor_server_req::~node_list_monitor_server_req() throw() {
    }


    void node_list_monitor_server_req::__set_body(const node_list_monitor_server_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_monitor_server_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_monitor_server_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_monitor_server_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_monitor_server_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_monitor_server_req& a, node_list_monitor_server_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_monitor_server_req::node_list_monitor_server_req(const node_list_monitor_server_req& other714) {
        body = other714.body;
        __isset = other714.__isset;
    }
    node_list_monitor_server_req& node_list_monitor_server_req::operator=(const node_list_monitor_server_req& other715) {
        body = other715.body;
        __isset = other715.__isset;
        return *this;
    }
    void node_list_monitor_server_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_monitor_server_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_list_monitor_server_rsp_body::~node_list_monitor_server_rsp_body() throw() {
    }


    void node_list_monitor_server_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_monitor_server_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_monitor_server_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_list_monitor_server_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_monitor_server_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_monitor_server_rsp_body& a, node_list_monitor_server_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_list_monitor_server_rsp_body::node_list_monitor_server_rsp_body(const node_list_monitor_server_rsp_body& other716) {
        data = other716.data;
    }
    node_list_monitor_server_rsp_body& node_list_monitor_server_rsp_body::operator=(const node_list_monitor_server_rsp_body& other717) {
        data = other717.data;
        return *this;
    }
    void node_list_monitor_server_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_monitor_server_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_list_monitor_server_rsp::~node_list_monitor_server_rsp() throw() {
    }


    void node_list_monitor_server_rsp::__set_body(const node_list_monitor_server_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_list_monitor_server_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_list_monitor_server_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_list_monitor_server_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_list_monitor_server_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_list_monitor_server_rsp& a, node_list_monitor_server_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_list_monitor_server_rsp::node_list_monitor_server_rsp(const node_list_monitor_server_rsp& other718) {
        body = other718.body;
        __isset = other718.__isset;
    }
    node_list_monitor_server_rsp& node_list_monitor_server_rsp::operator=(const node_list_monitor_server_rsp& other719) {
        body = other719.body;
        __isset = other719.__isset;
        return *this;
    }
    void node_list_monitor_server_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_list_monitor_server_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_set_monitor_server_req_data::~node_set_monitor_server_req_data() throw() {
    }


    void node_set_monitor_server_req_data::__set_peer_nodes_list(const std::vector<std::string>& val) {
        this->peer_nodes_list = val;
    }

    void node_set_monitor_server_req_data::__set_additional(const std::string& val) {
        this->additional = val;
    }

    void node_set_monitor_server_req_data::__set_wallet(const std::string& val) {
        this->wallet = val;
    }

    void node_set_monitor_server_req_data::__set_nonce(const std::string& val) {
        this->nonce = val;
    }

    void node_set_monitor_server_req_data::__set_sign(const std::string& val) {
        this->sign = val;
    }

    void node_set_monitor_server_req_data::__set_multisig_wallets(const std::vector<std::string>& val) {
        this->multisig_wallets = val;
    }

    void node_set_monitor_server_req_data::__set_multisig_threshold(const int32_t val) {
        this->multisig_threshold = val;
    }

    void node_set_monitor_server_req_data::__set_multisig_signs(const std::vector<multisig_sign_item>& val) {
        this->multisig_signs = val;
    }

    void node_set_monitor_server_req_data::__set_session_id(const std::string& val) {
        this->session_id = val;
    }

    void node_set_monitor_server_req_data::__set_session_id_sign(const std::string& val) {
        this->session_id_sign = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_set_monitor_server_req_data& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_set_monitor_server_req_data::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_peer_nodes_list = false;
        bool isset_additional = false;
        bool isset_wallet = false;
        bool isset_nonce = false;
        bool isset_sign = false;
        bool isset_multisig_wallets = false;
        bool isset_multisig_threshold = false;
        bool isset_multisig_signs = false;
        bool isset_session_id = false;
        bool isset_session_id_sign = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->peer_nodes_list.clear();
                        uint32_t _size720;
                        ::apache::thrift::protocol::TType _etype723;
                        xfer += iprot->readListBegin(_etype723, _size720);
                        this->peer_nodes_list.resize(_size720);
                        uint32_t _i724;
                        for (_i724 = 0; _i724 < _size720; ++_i724)
                        {
                            xfer += iprot->readString(this->peer_nodes_list[_i724]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_peer_nodes_list = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->additional);
                    isset_additional = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->wallet);
                    isset_wallet = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->nonce);
                    isset_nonce = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->sign);
                    isset_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 6:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_wallets.clear();
                        uint32_t _size725;
                        ::apache::thrift::protocol::TType _etype728;
                        xfer += iprot->readListBegin(_etype728, _size725);
                        this->multisig_wallets.resize(_size725);
                        uint32_t _i729;
                        for (_i729 = 0; _i729 < _size725; ++_i729)
                        {
                            xfer += iprot->readString(this->multisig_wallets[_i729]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_wallets = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 7:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->multisig_threshold);
                    isset_multisig_threshold = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 8:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->multisig_signs.clear();
                        uint32_t _size730;
                        ::apache::thrift::protocol::TType _etype733;
                        xfer += iprot->readListBegin(_etype733, _size730);
                        this->multisig_signs.resize(_size730);
                        uint32_t _i734;
                        for (_i734 = 0; _i734 < _size730; ++_i734)
                        {
                            xfer += this->multisig_signs[_i734].read(iprot);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_multisig_signs = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 9:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id);
                    isset_session_id = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 10:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->session_id_sign);
                    isset_session_id_sign = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_peer_nodes_list)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_additional)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_wallet)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_nonce)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_wallets)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_threshold)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_multisig_signs)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        if (!isset_session_id_sign)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_set_monitor_server_req_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_set_monitor_server_req_data");

        xfer += oprot->writeFieldBegin("peer_nodes_list", ::apache::thrift::protocol::T_LIST, 1);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->peer_nodes_list.size()));
            std::vector<std::string> ::const_iterator _iter735;
            for (_iter735 = this->peer_nodes_list.begin(); _iter735 != this->peer_nodes_list.end(); ++_iter735)
            {
                xfer += oprot->writeString((*_iter735));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("additional", ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->additional);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("wallet", ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->wallet);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->nonce);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("sign", ::apache::thrift::protocol::T_STRING, 5);
        xfer += oprot->writeString(this->sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_wallets", ::apache::thrift::protocol::T_LIST, 6);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->multisig_wallets.size()));
            std::vector<std::string> ::const_iterator _iter736;
            for (_iter736 = this->multisig_wallets.begin(); _iter736 != this->multisig_wallets.end(); ++_iter736)
            {
                xfer += oprot->writeString((*_iter736));
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_threshold", ::apache::thrift::protocol::T_I32, 7);
        xfer += oprot->writeI32(this->multisig_threshold);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("multisig_signs", ::apache::thrift::protocol::T_LIST, 8);
        {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->multisig_signs.size()));
            std::vector<multisig_sign_item> ::const_iterator _iter737;
            for (_iter737 = this->multisig_signs.begin(); _iter737 != this->multisig_signs.end(); ++_iter737)
            {
                xfer += (*_iter737).write(oprot);
            }
            xfer += oprot->writeListEnd();
        }
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 9);
        xfer += oprot->writeString(this->session_id);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldBegin("session_id_sign", ::apache::thrift::protocol::T_STRING, 10);
        xfer += oprot->writeString(this->session_id_sign);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_set_monitor_server_req_data& a, node_set_monitor_server_req_data& b) {
        using ::std::swap;
        swap(a.peer_nodes_list, b.peer_nodes_list);
        swap(a.additional, b.additional);
        swap(a.wallet, b.wallet);
        swap(a.nonce, b.nonce);
        swap(a.sign, b.sign);
        swap(a.multisig_wallets, b.multisig_wallets);
        swap(a.multisig_threshold, b.multisig_threshold);
        swap(a.multisig_signs, b.multisig_signs);
        swap(a.session_id, b.session_id);
        swap(a.session_id_sign, b.session_id_sign);
    }

    node_set_monitor_server_req_data::node_set_monitor_server_req_data(const node_set_monitor_server_req_data& other738) {
        peer_nodes_list = other738.peer_nodes_list;
        additional = other738.additional;
        wallet = other738.wallet;
        nonce = other738.nonce;
        sign = other738.sign;
        multisig_wallets = other738.multisig_wallets;
        multisig_threshold = other738.multisig_threshold;
        multisig_signs = other738.multisig_signs;
        session_id = other738.session_id;
        session_id_sign = other738.session_id_sign;
    }
    node_set_monitor_server_req_data& node_set_monitor_server_req_data::operator=(const node_set_monitor_server_req_data& other739) {
        peer_nodes_list = other739.peer_nodes_list;
        additional = other739.additional;
        wallet = other739.wallet;
        nonce = other739.nonce;
        sign = other739.sign;
        multisig_wallets = other739.multisig_wallets;
        multisig_threshold = other739.multisig_threshold;
        multisig_signs = other739.multisig_signs;
        session_id = other739.session_id;
        session_id_sign = other739.session_id_sign;
        return *this;
    }
    void node_set_monitor_server_req_data::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_set_monitor_server_req_data(";
        out << "peer_nodes_list=" << to_string(peer_nodes_list);
        out << ", " << "additional=" << to_string(additional);
        out << ", " << "wallet=" << to_string(wallet);
        out << ", " << "nonce=" << to_string(nonce);
        out << ", " << "sign=" << to_string(sign);
        out << ", " << "multisig_wallets=" << to_string(multisig_wallets);
        out << ", " << "multisig_threshold=" << to_string(multisig_threshold);
        out << ", " << "multisig_signs=" << to_string(multisig_signs);
        out << ", " << "session_id=" << to_string(session_id);
        out << ", " << "session_id_sign=" << to_string(session_id_sign);
        out << ")";
    }


    node_set_monitor_server_req_body::~node_set_monitor_server_req_body() throw() {
    }


    void node_set_monitor_server_req_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_set_monitor_server_req_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_set_monitor_server_req_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_set_monitor_server_req_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_set_monitor_server_req_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_set_monitor_server_req_body& a, node_set_monitor_server_req_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_set_monitor_server_req_body::node_set_monitor_server_req_body(const node_set_monitor_server_req_body& other740) {
        data = other740.data;
    }
    node_set_monitor_server_req_body& node_set_monitor_server_req_body::operator=(const node_set_monitor_server_req_body& other741) {
        data = other741.data;
        return *this;
    }
    void node_set_monitor_server_req_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_set_monitor_server_req_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_set_monitor_server_req::~node_set_monitor_server_req() throw() {
    }


    void node_set_monitor_server_req::__set_body(const node_set_monitor_server_req_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_set_monitor_server_req& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_set_monitor_server_req::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_set_monitor_server_req::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_set_monitor_server_req");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_set_monitor_server_req& a, node_set_monitor_server_req& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_set_monitor_server_req::node_set_monitor_server_req(const node_set_monitor_server_req& other742) {
        body = other742.body;
        __isset = other742.__isset;
    }
    node_set_monitor_server_req& node_set_monitor_server_req::operator=(const node_set_monitor_server_req& other743) {
        body = other743.body;
        __isset = other743.__isset;
        return *this;
    }
    void node_set_monitor_server_req::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_set_monitor_server_req(";
        out << "body=" << to_string(body);
        out << ")";
    }


    node_set_monitor_server_rsp_body::~node_set_monitor_server_rsp_body() throw() {
    }


    void node_set_monitor_server_rsp_body::__set_data(const std::string& val) {
        this->data = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_set_monitor_server_rsp_body& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_set_monitor_server_rsp_body::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;

        bool isset_data = false;

        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->data);
                    isset_data = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        if (!isset_data)
            throw TProtocolException(TProtocolException::INVALID_DATA);
        return xfer;
    }

    uint32_t node_set_monitor_server_rsp_body::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_set_monitor_server_rsp_body");

        xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
        xfer += oprot->writeString(this->data);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_set_monitor_server_rsp_body& a, node_set_monitor_server_rsp_body& b) {
        using ::std::swap;
        swap(a.data, b.data);
    }

    node_set_monitor_server_rsp_body::node_set_monitor_server_rsp_body(const node_set_monitor_server_rsp_body& other744) {
        data = other744.data;
    }
    node_set_monitor_server_rsp_body& node_set_monitor_server_rsp_body::operator=(const node_set_monitor_server_rsp_body& other745) {
        data = other745.data;
        return *this;
    }
    void node_set_monitor_server_rsp_body::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_set_monitor_server_rsp_body(";
        out << "data=" << to_string(data);
        out << ")";
    }


    node_set_monitor_server_rsp::~node_set_monitor_server_rsp() throw() {
    }


    void node_set_monitor_server_rsp::__set_body(const node_set_monitor_server_rsp_body& val) {
        this->body = val;
    }
    std::ostream& operator<<(std::ostream& out, const node_set_monitor_server_rsp& obj)
    {
        obj.printTo(out);
        return out;
    }


    uint32_t node_set_monitor_server_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

        ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
        uint32_t xfer = 0;
        std::string fname;
        ::apache::thrift::protocol::TType ftype;
        int16_t fid;

        xfer += iprot->readStructBegin(fname);

        using ::apache::thrift::protocol::TProtocolException;


        while (true)
        {
            xfer += iprot->readFieldBegin(fname, ftype, fid);
            if (ftype == ::apache::thrift::protocol::T_STOP) {
                break;
            }
            switch (fid)
            {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRUCT) {
                    xfer += this->body.read(iprot);
                    this->__isset.body = true;
                }
                else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
            }
            xfer += iprot->readFieldEnd();
        }

        xfer += iprot->readStructEnd();

        return xfer;
    }

    uint32_t node_set_monitor_server_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
        uint32_t xfer = 0;
        ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
        xfer += oprot->writeStructBegin("node_set_monitor_server_rsp");

        xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 1);
        xfer += this->body.write(oprot);
        xfer += oprot->writeFieldEnd();

        xfer += oprot->writeFieldStop();
        xfer += oprot->writeStructEnd();
        return xfer;
    }

    void swap(node_set_monitor_server_rsp& a, node_set_monitor_server_rsp& b) {
        using ::std::swap;
        swap(a.body, b.body);
        swap(a.__isset, b.__isset);
    }

    node_set_monitor_server_rsp::node_set_monitor_server_rsp(const node_set_monitor_server_rsp& other746) {
        body = other746.body;
        __isset = other746.__isset;
    }
    node_set_monitor_server_rsp& node_set_monitor_server_rsp::operator=(const node_set_monitor_server_rsp& other747) {
        body = other747.body;
        __isset = other747.__isset;
        return *this;
    }
    void node_set_monitor_server_rsp::printTo(std::ostream& out) const {
        using ::apache::thrift::to_string;
        out << "node_set_monitor_server_rsp(";
        out << "body=" << to_string(body);
        out << ")";
    }

} // namespace
