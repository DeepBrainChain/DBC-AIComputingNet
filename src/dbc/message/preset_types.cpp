/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "preset_types.h"

#include <algorithm>
#include <ostream>

// #include <thrift/TToString.h>

// The T_STOP of enum TType in dbc is not equal to the value of thrift official
// code: ::apache::thrift::protocol::T_STOP
#define ORIGIN_T_STOP 0

namespace occ {

int _kMessageTypeValues[] = {MessageType::PING,
                             MessageType::GET_HOST_INFO,
                             MessageType::SET_HOST_INFO,
                             MessageType::GET_USER_LIST,
                             MessageType::SET_USER_PASSWORD,
                             MessageType::GET_BOOT_MENU,
                             MessageType::SET_BOOT_MENU,
                             MessageType::GET_SMYOO_DEVICE_INFO,
                             MessageType::SET_SMYOO_DEVICE_POWER};
const char* _kMessageTypeNames[] = {
    "PING",          "GET_HOST_INFO",         "SET_HOST_INFO",
    "GET_USER_LIST", "SET_USER_PASSWORD",     "GET_BOOT_MENU",
    "SET_BOOT_MENU", "GET_SMYOO_DEVICE_INFO", "SET_SMYOO_DEVICE_POWER"};
const std::map<int, const char*> _MessageType_VALUES_TO_NAMES(
    ::apache::thrift::TEnumIterator(9, _kMessageTypeValues, _kMessageTypeNames),
    ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MessageType::type& val) {
    std::map<int, const char*>::const_iterator it =
        _MessageType_VALUES_TO_NAMES.find(val);
    if (it != _MessageType_VALUES_TO_NAMES.end()) {
        out << it->second;
    } else {
        out << static_cast<int>(val);
    }
    return out;
}

std::string to_string(const MessageType::type& val) {
    std::map<int, const char*>::const_iterator it =
        _MessageType_VALUES_TO_NAMES.find(val);
    if (it != _MessageType_VALUES_TO_NAMES.end()) {
        return std::string(it->second);
    } else {
        return std::to_string(static_cast<int>(val));
    }
}

ResultStruct::~ResultStruct() noexcept {}

void ResultStruct::__set_code(const int32_t val) { this->code = val; }

void ResultStruct::__set_message(const std::string& val) {
    this->message = val;
}
std::ostream& operator<<(std::ostream& out, const ResultStruct& obj) {
    obj.printTo(out);
    return out;
}

uint32_t ResultStruct::read(::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    bool isset_code = false;
    bool isset_message = false;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->code);
                    isset_code = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->message);
                    isset_message = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    if (!isset_code) throw TProtocolException(TProtocolException::INVALID_DATA);
    if (!isset_message)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    return xfer;
}

uint32_t ResultStruct::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("ResultStruct");

    xfer +=
        oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->code);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("message",
                                   ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(ResultStruct& a, ResultStruct& b) {
    using ::std::swap;
    swap(a.code, b.code);
    swap(a.message, b.message);
}

ResultStruct::ResultStruct(const ResultStruct& other0) {
    code = other0.code;
    message = other0.message;
}
ResultStruct& ResultStruct::operator=(const ResultStruct& other1) {
    code = other1.code;
    message = other1.message;
    return *this;
}
void ResultStruct::printTo(std::ostream& out) const {
    using ::apache::thrift::to_string;
    out << "ResultStruct(";
    out << "code=" << to_string(code);
    out << ", "
        << "message=" << to_string(message);
    out << ")";
}

Message::~Message() noexcept {}

void Message::__set_version(const int32_t val) { this->version = val; }

void Message::__set_type(const int32_t val) { this->type = val; }

void Message::__set_body(const std::string& val) { this->body = val; }

void Message::__set_host(const std::string& val) {
    this->host = val;
    __isset.host = true;
}
std::ostream& operator<<(std::ostream& out, const Message& obj) {
    obj.printTo(out);
    return out;
}

uint32_t Message::read(::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    bool isset_version = false;
    bool isset_type = false;
    bool isset_body = false;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->version);
                    isset_version = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->type);
                    isset_type = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->body);
                    isset_body = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->host);
                    this->__isset.host = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    if (!isset_version)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    if (!isset_type) throw TProtocolException(TProtocolException::INVALID_DATA);
    if (!isset_body) throw TProtocolException(TProtocolException::INVALID_DATA);
    return xfer;
}

uint32_t Message::write(::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("Message");

    xfer +=
        oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->version);
    xfer += oprot->writeFieldEnd();

    xfer +=
        oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->type);
    xfer += oprot->writeFieldEnd();

    xfer +=
        oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->body);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.host) {
        xfer += oprot->writeFieldBegin("host",
                                       ::apache::thrift::protocol::T_STRING, 4);
        xfer += oprot->writeString(this->host);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(Message& a, Message& b) {
    using ::std::swap;
    swap(a.version, b.version);
    swap(a.type, b.type);
    swap(a.body, b.body);
    swap(a.host, b.host);
    swap(a.__isset, b.__isset);
}

Message::Message(const Message& other2) {
    version = other2.version;
    type = other2.type;
    body = other2.body;
    host = other2.host;
    __isset = other2.__isset;
}
Message& Message::operator=(const Message& other3) {
    version = other3.version;
    type = other3.type;
    body = other3.body;
    host = other3.host;
    __isset = other3.__isset;
    return *this;
}
void Message::printTo(std::ostream& out) const {
    using ::apache::thrift::to_string;
    out << "Message(";
    out << "version=" << to_string(version);
    out << ", "
        << "type=" << to_string(type);
    out << ", "
        << "body=" << to_string(body);
    out << ", "
        << "host=";
    (__isset.host ? (out << to_string(host)) : (out << "<null>"));
    out << ")";
}

HostInfo::~HostInfo() noexcept {}

void HostInfo::__set_hostName(const std::string& val) { this->hostName = val; }

void HostInfo::__set_ipAddress(const std::string& val) {
    this->ipAddress = val;
}
std::ostream& operator<<(std::ostream& out, const HostInfo& obj) {
    obj.printTo(out);
    return out;
}

uint32_t HostInfo::read(::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    bool isset_hostName = false;
    bool isset_ipAddress = false;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->hostName);
                    isset_hostName = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->ipAddress);
                    isset_ipAddress = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    if (!isset_hostName)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    if (!isset_ipAddress)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    return xfer;
}

uint32_t HostInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("HostInfo");

    xfer += oprot->writeFieldBegin("hostName",
                                   ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->hostName);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("ipAddress",
                                   ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ipAddress);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(HostInfo& a, HostInfo& b) {
    using ::std::swap;
    swap(a.hostName, b.hostName);
    swap(a.ipAddress, b.ipAddress);
}

HostInfo::HostInfo(const HostInfo& other4) {
    hostName = other4.hostName;
    ipAddress = other4.ipAddress;
}
HostInfo& HostInfo::operator=(const HostInfo& other5) {
    hostName = other5.hostName;
    ipAddress = other5.ipAddress;
    return *this;
}
void HostInfo::printTo(std::ostream& out) const {
    using ::apache::thrift::to_string;
    out << "HostInfo(";
    out << "hostName=" << to_string(hostName);
    out << ", "
        << "ipAddress=" << to_string(ipAddress);
    out << ")";
}

UserList::~UserList() noexcept {}

void UserList::__set_users(const std::vector<std::string>& val) {
    this->users = val;
}
std::ostream& operator<<(std::ostream& out, const UserList& obj) {
    obj.printTo(out);
    return out;
}

uint32_t UserList::read(::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    bool isset_users = false;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->users.clear();
                        uint32_t _size6;
                        ::apache::thrift::protocol::TType _etype9;
                        xfer += iprot->readListBegin(_etype9, _size6);
                        this->users.resize(_size6);
                        uint32_t _i10;
                        for (_i10 = 0; _i10 < _size6; ++_i10) {
                            xfer += iprot->readString(this->users[_i10]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_users = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    if (!isset_users)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    return xfer;
}

uint32_t UserList::write(::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("UserList");

    xfer +=
        oprot->writeFieldBegin("users", ::apache::thrift::protocol::T_LIST, 1);
    {
        xfer +=
            oprot->writeListBegin(::apache::thrift::protocol::T_STRING,
                                  static_cast<uint32_t>(this->users.size()));
        std::vector<std::string>::const_iterator _iter11;
        for (_iter11 = this->users.begin(); _iter11 != this->users.end();
             ++_iter11) {
            xfer += oprot->writeString((*_iter11));
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(UserList& a, UserList& b) {
    using ::std::swap;
    swap(a.users, b.users);
}

UserList::UserList(const UserList& other12) { users = other12.users; }
UserList& UserList::operator=(const UserList& other13) {
    users = other13.users;
    return *this;
}
void UserList::printTo(std::ostream& out) const {
    using ::apache::thrift::to_string;
    out << "UserList(";
    out << "users=" << to_string(users);
    out << ")";
}

UserPassword::~UserPassword() noexcept {}

void UserPassword::__set_userName(const std::string& val) {
    this->userName = val;
}

void UserPassword::__set_password(const std::string& val) {
    this->password = val;
}
std::ostream& operator<<(std::ostream& out, const UserPassword& obj) {
    obj.printTo(out);
    return out;
}

uint32_t UserPassword::read(::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    bool isset_userName = false;
    bool isset_password = false;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->userName);
                    isset_userName = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->password);
                    isset_password = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    if (!isset_userName)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    if (!isset_password)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    return xfer;
}

uint32_t UserPassword::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("UserPassword");

    xfer += oprot->writeFieldBegin("userName",
                                   ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->userName);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("password",
                                   ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(UserPassword& a, UserPassword& b) {
    using ::std::swap;
    swap(a.userName, b.userName);
    swap(a.password, b.password);
}

UserPassword::UserPassword(const UserPassword& other14) {
    userName = other14.userName;
    password = other14.password;
}
UserPassword& UserPassword::operator=(const UserPassword& other15) {
    userName = other15.userName;
    password = other15.password;
    return *this;
}
void UserPassword::printTo(std::ostream& out) const {
    using ::apache::thrift::to_string;
    out << "UserPassword(";
    out << "userName=" << to_string(userName);
    out << ", "
        << "password=" << to_string(password);
    out << ")";
}

BootMenuList::~BootMenuList() noexcept {}

void BootMenuList::__set_menus(const std::vector<std::string>& val) {
    this->menus = val;
}
std::ostream& operator<<(std::ostream& out, const BootMenuList& obj) {
    obj.printTo(out);
    return out;
}

uint32_t BootMenuList::read(::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    bool isset_menus = false;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_LIST) {
                    {
                        this->menus.clear();
                        uint32_t _size16;
                        ::apache::thrift::protocol::TType _etype19;
                        xfer += iprot->readListBegin(_etype19, _size16);
                        this->menus.resize(_size16);
                        uint32_t _i20;
                        for (_i20 = 0; _i20 < _size16; ++_i20) {
                            xfer += iprot->readString(this->menus[_i20]);
                        }
                        xfer += iprot->readListEnd();
                    }
                    isset_menus = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    if (!isset_menus)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    return xfer;
}

uint32_t BootMenuList::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("BootMenuList");

    xfer +=
        oprot->writeFieldBegin("menus", ::apache::thrift::protocol::T_LIST, 1);
    {
        xfer +=
            oprot->writeListBegin(::apache::thrift::protocol::T_STRING,
                                  static_cast<uint32_t>(this->menus.size()));
        std::vector<std::string>::const_iterator _iter21;
        for (_iter21 = this->menus.begin(); _iter21 != this->menus.end();
             ++_iter21) {
            xfer += oprot->writeString((*_iter21));
        }
        xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(BootMenuList& a, BootMenuList& b) {
    using ::std::swap;
    swap(a.menus, b.menus);
}

BootMenuList::BootMenuList(const BootMenuList& other22) {
    menus = other22.menus;
}
BootMenuList& BootMenuList::operator=(const BootMenuList& other23) {
    menus = other23.menus;
    return *this;
}
void BootMenuList::printTo(std::ostream& out) const {
    using ::apache::thrift::to_string;
    out << "BootMenuList(";
    out << "menus=" << to_string(menus);
    out << ")";
}

BootMenu::~BootMenu() noexcept {}

void BootMenu::__set_menu(const std::string& val) { this->menu = val; }

void BootMenu::__set_superTube(const bool val) { this->superTube = val; }
std::ostream& operator<<(std::ostream& out, const BootMenu& obj) {
    obj.printTo(out);
    return out;
}

uint32_t BootMenu::read(::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    bool isset_menu = false;
    bool isset_superTube = false;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->menu);
                    isset_menu = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_BOOL) {
                    xfer += iprot->readBool(this->superTube);
                    isset_superTube = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    if (!isset_menu) throw TProtocolException(TProtocolException::INVALID_DATA);
    if (!isset_superTube)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    return xfer;
}

uint32_t BootMenu::write(::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("BootMenu");

    xfer +=
        oprot->writeFieldBegin("menu", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->menu);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("superTube",
                                   ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->superTube);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(BootMenu& a, BootMenu& b) {
    using ::std::swap;
    swap(a.menu, b.menu);
    swap(a.superTube, b.superTube);
}

BootMenu::BootMenu(const BootMenu& other24) {
    menu = other24.menu;
    superTube = other24.superTube;
}
BootMenu& BootMenu::operator=(const BootMenu& other25) {
    menu = other25.menu;
    superTube = other25.superTube;
    return *this;
}
void BootMenu::printTo(std::ostream& out) const {
    using ::apache::thrift::to_string;
    out << "BootMenu(";
    out << "menu=" << to_string(menu);
    out << ", "
        << "superTube=" << to_string(superTube);
    out << ")";
}

SmyooDeviceInfo::~SmyooDeviceInfo() noexcept {}

void SmyooDeviceInfo::__set_mcuname(const std::string& val) {
    this->mcuname = val;
}

void SmyooDeviceInfo::__set_note(const std::string& val) { this->note = val; }

void SmyooDeviceInfo::__set_isonline(const int32_t val) {
    this->isonline = val;
}

void SmyooDeviceInfo::__set_power(const int32_t val) { this->power = val; }

void SmyooDeviceInfo::__set_mcuid(const std::string& val) { this->mcuid = val; }
std::ostream& operator<<(std::ostream& out, const SmyooDeviceInfo& obj) {
    obj.printTo(out);
    return out;
}

uint32_t SmyooDeviceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    bool isset_mcuname = false;
    bool isset_note = false;
    bool isset_isonline = false;
    bool isset_power = false;
    bool isset_mcuid = false;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->mcuname);
                    isset_mcuname = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->note);
                    isset_note = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->isonline);
                    isset_isonline = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 4:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->power);
                    isset_power = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 5:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->mcuid);
                    isset_mcuid = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    if (!isset_mcuname)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    if (!isset_note) throw TProtocolException(TProtocolException::INVALID_DATA);
    if (!isset_isonline)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    if (!isset_power)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    if (!isset_mcuid)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    return xfer;
}

uint32_t SmyooDeviceInfo::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("SmyooDeviceInfo");

    xfer += oprot->writeFieldBegin("mcuname",
                                   ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->mcuname);
    xfer += oprot->writeFieldEnd();

    xfer +=
        oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->note);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("isonline",
                                   ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->isonline);
    xfer += oprot->writeFieldEnd();

    xfer +=
        oprot->writeFieldBegin("power", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->power);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldBegin("mcuid",
                                   ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->mcuid);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(SmyooDeviceInfo& a, SmyooDeviceInfo& b) {
    using ::std::swap;
    swap(a.mcuname, b.mcuname);
    swap(a.note, b.note);
    swap(a.isonline, b.isonline);
    swap(a.power, b.power);
    swap(a.mcuid, b.mcuid);
}

SmyooDeviceInfo::SmyooDeviceInfo(const SmyooDeviceInfo& other26) {
    mcuname = other26.mcuname;
    note = other26.note;
    isonline = other26.isonline;
    power = other26.power;
    mcuid = other26.mcuid;
}
SmyooDeviceInfo& SmyooDeviceInfo::operator=(const SmyooDeviceInfo& other27) {
    mcuname = other27.mcuname;
    note = other27.note;
    isonline = other27.isonline;
    power = other27.power;
    mcuid = other27.mcuid;
    return *this;
}
void SmyooDeviceInfo::printTo(std::ostream& out) const {
    using ::apache::thrift::to_string;
    out << "SmyooDeviceInfo(";
    out << "mcuname=" << to_string(mcuname);
    out << ", "
        << "note=" << to_string(note);
    out << ", "
        << "isonline=" << to_string(isonline);
    out << ", "
        << "power=" << to_string(power);
    out << ", "
        << "mcuid=" << to_string(mcuid);
    out << ")";
}

SmyooDevicePowerData::~SmyooDevicePowerData() noexcept {}

void SmyooDevicePowerData::__set_status(const int32_t val) {
    this->status = val;
}

void SmyooDevicePowerData::__set_mcuid(const std::string& val) {
    this->mcuid = val;
    __isset.mcuid = true;
}

void SmyooDevicePowerData::__set_mcuname(const std::string& val) {
    this->mcuname = val;
    __isset.mcuname = true;
}
std::ostream& operator<<(std::ostream& out, const SmyooDevicePowerData& obj) {
    obj.printTo(out);
    return out;
}

uint32_t SmyooDevicePowerData::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    bool isset_status = false;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->status);
                    isset_status = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->mcuid);
                    this->__isset.mcuid = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 3:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->mcuname);
                    this->__isset.mcuname = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    if (!isset_status)
        throw TProtocolException(TProtocolException::INVALID_DATA);
    return xfer;
}

uint32_t SmyooDevicePowerData::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("SmyooDevicePowerData");

    xfer +=
        oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->status);
    xfer += oprot->writeFieldEnd();

    if (this->__isset.mcuid) {
        xfer += oprot->writeFieldBegin("mcuid",
                                       ::apache::thrift::protocol::T_STRING, 2);
        xfer += oprot->writeString(this->mcuid);
        xfer += oprot->writeFieldEnd();
    }
    if (this->__isset.mcuname) {
        xfer += oprot->writeFieldBegin("mcuname",
                                       ::apache::thrift::protocol::T_STRING, 3);
        xfer += oprot->writeString(this->mcuname);
        xfer += oprot->writeFieldEnd();
    }
    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(SmyooDevicePowerData& a, SmyooDevicePowerData& b) {
    using ::std::swap;
    swap(a.status, b.status);
    swap(a.mcuid, b.mcuid);
    swap(a.mcuname, b.mcuname);
    swap(a.__isset, b.__isset);
}

SmyooDevicePowerData::SmyooDevicePowerData(
    const SmyooDevicePowerData& other28) {
    status = other28.status;
    mcuid = other28.mcuid;
    mcuname = other28.mcuname;
    __isset = other28.__isset;
}
SmyooDevicePowerData& SmyooDevicePowerData::operator=(
    const SmyooDevicePowerData& other29) {
    status = other29.status;
    mcuid = other29.mcuid;
    mcuname = other29.mcuname;
    __isset = other29.__isset;
    return *this;
}
void SmyooDevicePowerData::printTo(std::ostream& out) const {
    using ::apache::thrift::to_string;
    out << "SmyooDevicePowerData(";
    out << "status=" << to_string(status);
    out << ", "
        << "mcuid=";
    (__isset.mcuid ? (out << to_string(mcuid)) : (out << "<null>"));
    out << ", "
        << "mcuname=";
    (__isset.mcuname ? (out << to_string(mcuname)) : (out << "<null>"));
    out << ")";
}

InvalidMessageType::~InvalidMessageType() noexcept {}

void InvalidMessageType::__set_whatType(const int32_t val) {
    this->whatType = val;
}

void InvalidMessageType::__set_why(const std::string& val) { this->why = val; }
std::ostream& operator<<(std::ostream& out, const InvalidMessageType& obj) {
    obj.printTo(out);
    return out;
}

uint32_t InvalidMessageType::read(
    ::apache::thrift::protocol::TProtocol* iprot) {
    ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
    uint32_t xfer = 0;
    std::string fname;
    ::apache::thrift::protocol::TType ftype;
    int16_t fid;

    xfer += iprot->readStructBegin(fname);

    using ::apache::thrift::protocol::TProtocolException;

    while (true) {
        xfer += iprot->readFieldBegin(fname, ftype, fid);
        if (ftype == ORIGIN_T_STOP) {
            break;
        }
        switch (fid) {
            case 1:
                if (ftype == ::apache::thrift::protocol::T_I32) {
                    xfer += iprot->readI32(this->whatType);
                    this->__isset.whatType = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            case 2:
                if (ftype == ::apache::thrift::protocol::T_STRING) {
                    xfer += iprot->readString(this->why);
                    this->__isset.why = true;
                } else {
                    xfer += iprot->skip(ftype);
                }
                break;
            default:
                xfer += iprot->skip(ftype);
                break;
        }
        xfer += iprot->readFieldEnd();
    }

    xfer += iprot->readStructEnd();

    return xfer;
}

uint32_t InvalidMessageType::write(
    ::apache::thrift::protocol::TProtocol* oprot) const {
    uint32_t xfer = 0;
    ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
    xfer += oprot->writeStructBegin("InvalidMessageType");

    xfer += oprot->writeFieldBegin("whatType",
                                   ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->whatType);
    xfer += oprot->writeFieldEnd();

    xfer +=
        oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->why);
    xfer += oprot->writeFieldEnd();

    xfer += oprot->writeFieldStop();
    xfer += oprot->writeStructEnd();
    return xfer;
}

void swap(InvalidMessageType& a, InvalidMessageType& b) {
    using ::std::swap;
    swap(a.whatType, b.whatType);
    swap(a.why, b.why);
    swap(a.__isset, b.__isset);
}

InvalidMessageType::InvalidMessageType(const InvalidMessageType& other30)
    : TException() {
    whatType = other30.whatType;
    why = other30.why;
    __isset = other30.__isset;
}
InvalidMessageType& InvalidMessageType::operator=(
    const InvalidMessageType& other31) {
    whatType = other31.whatType;
    why = other31.why;
    __isset = other31.__isset;
    return *this;
}
void InvalidMessageType::printTo(std::ostream& out) const {
    using ::apache::thrift::to_string;
    out << "InvalidMessageType(";
    out << "whatType=" << to_string(whatType);
    out << ", "
        << "why=" << to_string(why);
    out << ")";
}

const char* InvalidMessageType::what() const noexcept {
    try {
        std::stringstream ss;
        ss << "TException - service has thrown: " << *this;
        this->thriftTExceptionMessageHolder_ = ss.str();
        return this->thriftTExceptionMessageHolder_.c_str();
    } catch (const std::exception&) {
        return "TException - service has thrown: InvalidMessageType";
    }
}

}  // namespace occ
